)if false
\documentclass{article}
\usepackage{axiom}
\usepackage{url}
\begin{document}
\title{lattice related mathematical structures}
\author{Martin J Baker}
\maketitle
\begin{abstract}
In this pamphlet are partial order, lattice structures and logic operations based on
them. Logic operations based on lattice structures
Finite lattices may be based on a poset (partial order)
so see 'UserDefinedPartialOrdering' package in setorder.spad
I have put a fuller explanation of this code here:
http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
\end{abstract}

This document is just experimental, I am just trying out various things, don't
worry about the detail its the big picture that I would like help with.

I am using Steven Vickers book [ref 1] as my reference.

There are a common set of lattice-like structures that occur in various branches
of mathematics such as orders, logic and sets. I would like to represent these
structures in FriCAS.

What I have done so far seems to be applicable to finite lattices but a lot of my
interest in this subject would be infinite structures. Especially structures
from Topology such as a 'frame' which is a complete lattice with infinite meets.
I am also interested in structures from computer science such as domain theory.

My strategy so far is to have two sorts of domains:
\begin{itemize}
\item posets - here the representation is the whole structure.
\item lattices - here the representation is an element of the structure.
\end{itemize}

So for the poset, the representation would be the whole structure, like this:
\begin{verbatim}
Rep := Record(set:List S,struct:List List Boolean)
\end{verbatim}

The lattice is an algebraicizing of this. The lattice constructor would take the poset
as a parameter.
)endif

)abbrev category PREORD Preorder
++ Description: implies operation with reflexivity and transitivity
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: reflexivity forall(x): x<=x
++ Axiom: transitivity forall(x,y,z): x<=y and y<=z implies x<=z
NNI==> NonNegativeInteger
Preorder: Category == SetCategory with
    implies:(s : %,NNI, NNI) -> Boolean


)abbrev domain POSET Poset
++ Author: Martin Baker
++ Description: holds a complete set together with a structure to codify
++   the partial order.
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Date Created: Aug 2015
++ Date Last Updated: Aug 2015
++ Basic Operations: 
++ Related packages: UserDefinedPartialOrdering in setorder.spad
++ Related categories: PartialOrder in catdef.spad
++ Related Domains: DirectedGraph in graph.spad
++ Also See:
++ AMS Classifications:
++ Keywords: poset partial order
++ Examples: power set structure
++ References:
++ Axiom: reflexivity forall(x): x<=x
++ Axiom: antisymmetry forall(x,y): x<=y and y<=x iff x=y
++ Axiom: transitivity forall(x,y,z): x<=y and y<=z implies x<=z

Poset(S) : Exports == Impl where
    S : SetCategory
    PI ==> PositiveInteger
    NNI==> NonNegativeInteger
    SINT==> SingleInteger

    Exports ==> Join(CoercibleTo(OutputForm), SetCategory) with
     poset : (set1:List S,struct1:List List Boolean) -> %
      ++ constructor where the set and structure is supplied
     addObject : (s : %, n : S) -> %
      ++ addObject!(s, n) adds object with coordinates n to the
      ++ graph s.
      ++ This is done in a non-mutable way, that is, the original
      ++ poset is not changed instead a new one is constructed.
     addArrow : (s : %, n1 : NNI, n2 : NNI) -> %
      ++ addArrow!(s, nm, n1, n2) adds an arrow to the graph s, where:
      ++ n1 is the index of the start object
      ++ n2 is the index of the end object
      ++ This is done in a non-mutable way, that is, the original
      ++ poset is not changed instead a new one is constructed.
     getVertices : (s : %) -> List S
      ++ getVertices(s) returns a list of all the vertices (or objects)
      ++ of the graph s.
     getVertexIndex :  (%, S) -> NNI
      ++ getVertexIndex(s, o) gives index of object o.
     getArrows : (s : %) -> List List Boolean
      ++ getArrows(s) returns a list of all the arrows (or edges)

     opposite : (s : %) -> %
      ++ constucts the opposite in the category theory sense of reversing
      ++ all the arrows

     powerSetStructure : (objs : S) -> %
      ++ powerSetStructure(set) is a constructor for a Poset
      ++ where each element is a set (implemented as a list)
      ++ and with a subset structure.
      ++ requires S to be a list.

     implies:(s : %,NNI, NNI) -> Boolean
     
     meet:(s : %,a:NNI,b:NNI) -> NNI
      ++ returns the meet of 'a' and 'b'
      ++ In this version of meet nodes are represented as index values.
      ++ In the general case, not every poset will have a meet in which case
      ++ 0 will be returned as an error indication.
     
     join:(s : %,a:NNI,b:NNI) -> NNI
      ++ returns the join of 'a' and 'b'
      ++ In this version of join nodes are represented as index values.
      ++ In the general case, not every poset will have a join in which case
      ++ 0 will be returned as an error indication.

     meet:(s : %,elements:List(NNI)) -> NNI
      ++ returns the meet of a subset of lattice given by list of elements

     join:(s : %,elements:List(NNI)) -> NNI
      ++ returns the join of a subset of lattice given by list of elements

     glb:(s : %,a:List NNI) -> NNI
      ++ 'greatest lower bound' or 'infimum'
      ++ In this version of glb nodes are represented as index values.
      ++ Not every subset of a poset will have a glb in which case
      ++ 0 will be returned as an error indication.

     lub:(s : %,a:List NNI) -> NNI
      ++ 'least upper bound' or 'supremum'
      ++ In this version of lub nodes are represented as index values.
      ++ Not every subset of a poset will have a lub in which case
      ++ 0 will be returned as an error indication.

     indexToObject:(s : %,index:NNI) -> S
      ++ returns the object at a given index

     objectToIndex:(s : %,obj:S) -> NNI
      ++ returns the index of a given object

     completeReflexivity:(s:%) -> %
      ++ Reflexivity requires forall(x): x<=x
      ++ This function inforces this by making sure that every element has
      ++ arrow to itself. That is, the leading diagonal is true.

     completeTransitivity:(s:%) -> %
      ++ Transitivity requires forall(x,y,z): x<=y and y<=z implies x<=z
      ++ This function inforces this by making sure that the composition
      ++ of any two arrows is also an arrow.

     isAntisymmetric?:(s:%) -> Boolean
      ++ Antisymmetric requires forall(x,y): x<=y and y<=x iff x=y
      ++ Returns true if this is the case for every element.

    Impl ==> add

      sayMsg ==> sayBrightly$Lisp

      -- This holds a complete set together with a structure to codify
      -- the partial order. The elements are put in a list so they
      -- can be enumerated and linked to the structure.
      -- The structure is a two dimensional array to determine
      -- is each element is connected to each other element.
      Rep := Record(set1:List S,struct1:List List Boolean)

      -- constructor where the set and structure is supplied
      poset(set1:List S,struct1:List List Boolean) : % ==
        [set1,struct1]

      -- local function to set a single value in the arrow matrix
      setArrow!(arr:List(List(Boolean)),a:NNI,b:NNI,c:Boolean):Void ==
        row:NNI := 1
        for x in arr repeat
          if row=a then
            setelt!(x,b,c)
            return void
          row=row+1
        void

      -- local function to test a single value in the arrow matrix
      isArrow?(arr:List(List(Boolean)),a:NNI,b:NNI):Boolean ==
        row:NNI := 1
        for x in arr repeat
          if row=a then
            val:Boolean := qelt(x,b)
            return val
          row=row+1
        false

      -- adds an object to this poset
      addObject(s : %, n : S) : % ==
        dim : NNI := #(s.set1) + 1
        obs : List S := concat(s.set1,n)
        arrows : List List Boolean := []
        for a in s.struct1 repeat
          a:List Boolean := concat(a,false)
          arrows := concat(arrows,a)
        emptyRow:List Boolean := [false for x in 1..dim]
        arrows := concat(arrows,emptyRow)
        [obs,arrows]

      -- adds an arrow to this graph, where:
      -- s is the graph where the arrow is to be added
      -- n1 is the index of the start object
      -- n2 is the index of the end object
      addArrow(s : %, n1 : NNI, n2 : NNI) : % ==
        a : List Boolean := qelt(s.struct1,n1)
        setelt!(a,n2,true)
        setelt!(s.struct1,n1,a)
        [s.set1,s.struct1]

      -- returns a list of all the vertices (or objects)
      getVertices(s : %) : List S ==
        s.set1

      -- returns a list of all the arrows (or edges)
      getArrows(s : %) : List List Boolean ==
        s.struct1

      -- constucts the opposite in the category theory sense of reversing
      -- all the arrows
      opposite(s : %) : % ==
        arr2 : List List Boolean := [nil]
        for x in s.struct1 repeat
          row: List Boolean := []
          for y in x repeat
            row := concat(row,false)
          arr2:=concat(arr2,row)
        for a in 1..#(s.struct1) repeat
          for b in 1..#(s.struct1) repeat
            if isArrow?(s.struct1,a,b) then setArrow!(arr2,b,a,true)
        [s.set1,arr2]

      implies(s : %,left:NNI,right:NNI) : Boolean ==
        a : List Boolean := qelt(s.struct1,left)
        b : Boolean := qelt(a,right)
        b

      -- local function to display a list
      listToString(a:List NNI):String ==
        res :String := "["
        for x in a repeat
          res := concat(res,string(x))
          res := concat(res,",")
        concat(res,"]")

      -- returns the join of 'a' and 'b'
      -- In this version of join nodes are represented as index values.
      -- In the general case, not every poset will have a join in which case
      -- 0 will be returned as an error indication.
      join(s : %,a:NNI,b:NNI): NNI ==
        res : List NNI := []
        -- flag for each element is true if >= from 'a'
        flaga : List Boolean := qelt(s.struct1,a)
        -- list of all element indexes which are >= from 'a'
        candidatesa: List NNI := []
        index:NNI := 1
        for x in flaga repeat
          if x then candidatesa:= concat(candidatesa,index)
          index := index +1
        -- flag for each element is true if >= from 'b'
        flagb : List Boolean := qelt(s.struct1,b)
        -- list of all element indexes which are >= from 'a'
        candidatesb: List NNI := []
        index := 1
        for x in flagb repeat
          if x then candidatesb:= concat(candidatesb,index)
          index := index +1
        res := setIntersection(candidatesa,candidatesb)
        glb(s,res)

     -- returns the meet of 'a' and 'b'
      -- In this version of meet nodes are represented as index values.
      -- In the general case, not every poset will have a meet in which case
      -- 0 will be returned as an error indication.
      meet(s : %,a:NNI,b:NNI): NNI ==
        res : List NNI := []
        -- flag for each element is true if >= to 'a'
        flaga : List Boolean := []
        -- flag for each element is true if >= to 'b'
        flagb : List Boolean := []
        for x in s.struct1 repeat
          flaga := concat(flaga,qelt(x,a)$List(Boolean))$List(Boolean)
        -- list of all element indexes which are >= than 'a'
        candidatesa: List NNI := []
        index:NNI := 1
        for x in flaga repeat
          if x then candidatesa:= concat(candidatesa,index)
          index := index +1
        for x in s.struct1 repeat
          flagb := concat(flagb,qelt(x,b)$List(Boolean))$List(Boolean)
        -- list of all element indexes which are >= than 'b'
        candidatesb: List NNI := []
        index := 1
        for x in flagb repeat
          if x then candidatesb:= concat(candidatesb,index)
          index := index +1
        res := setIntersection(candidatesa,candidatesb)
        --sayMsg concat("join candidatesa=",listToString(candidatesa))$String
        --sayMsg concat("join candidatesb=",listToString(candidatesb))$String
        --sayMsg concat("join res=",listToString(res))$String
        lub(s,res)

      -- returns the meet of a subset of lattice given by list of elements
      meet(s : %,elements:List(NNI)):NNI ==
        res : List NNI := []
        for e in elements repeat
          -- flag for each element is true if >= to 'e'
          flage : List Boolean := []
          for x in s.struct1 repeat
            flage := concat(flage,qelt(x,e)$List(Boolean))$List(Boolean)
          -- list of all element indexes which are >= than 'e'
          candidates: List NNI := []
          index:NNI := 1
          for x in flage repeat
            if x then candidates:= concat(candidates,index)
            index := index +1
        res := setIntersection(res,candidates)
        --sayMsg concat("join candidates=",listToString(candidates))$String
        --sayMsg concat("join res=",listToString(res))$String
        lub(s,res)

      -- returns the join of a subset of lattice given by list of elements
      join(s : %,elements:List(NNI)):NNI ==
        res : List NNI := []
        for e in elements repeat
          -- flag for each element is true if >= from 'e'
          flage : List Boolean := qelt(s.struct1,e)
          -- list of all element indexes which are >= from 'e'
          candidates: List NNI := []
          index:NNI := 1
          for x in flage repeat
            if x then candidates:= concat(candidates,index)
            index := index +1
          res := setIntersection(res,candidates)
        glb(s,res)

      -- 'greatest lower bound' or 'infimum'
      -- In this version of glb nodes are represented as index values.
      -- Not every subset of a poset will have a glb in which case
      -- 0 will be returned as an error indication.
      glb(s : %,a:List NNI):NNI ==
        if empty?(a) then return 0::NNI
        if #a=1 then return first(a)
        resultList:List(NNI) := copy(a)
        --sayMsg concat("lub res=",listToString(resultList))$String
        for x in a repeat
          --sayMsg concat("glb x=",string(x))$String
          for y in a repeat
            --sayMsg concat("glb y=",string(y))$String
            if implies(s,x,y) then
              if x ~= y then
                if entry?(x,resultList) then
                  --sayMsg concat("glb removing:",string(y))$String
                  resultList := remove(y,resultList)
                  --sayMsg concat("glb res=",listToString(resultList))$String
        if #resultList ~= 1 then return 0::NNI
        first(resultList)

      -- 'least upper bound' or 'supremum'
      -- In this version of lub nodes are represented as index values.
      -- Not every subset of a poset will have a lub in which case
      -- 0 will be returned as an error indication.
      lub(s : %,a:List NNI):NNI ==
        if empty?(a) then return 0::NNI
        if #a=1 then return first(a)
        resultList:List(NNI) := copy(a)
        for x in a repeat
          --sayMsg concat("lub x=",string(x))$String
          for y in a repeat
            --sayMsg concat("lub y=",string(y))$String
            if implies(s,x,y) then
              if x ~= y then
                if entry?(y,resultList) then
                  --sayMsg concat("lub removing:",string(x))$String
                  resultList := remove(x,resultList)
                  --sayMsg concat("lub res=",listToString(resultList))$String
        if  #resultList ~= 1 then return 0::NNI
        first(resultList)

      -- returns the object at a given index
      indexToObject(s : %,index:NNI):S ==
        --sayMsg concat("indexToObject",string(index))$String
        qelt(s.set1,index)

      -- returns the index of a given object
      objectToIndex(s : %,obj:S):NNI ==
        position(obj,s.set1)$List(S) pretend NNI

      -- Reflexivity requires forall(x): x<=x
      -- This function inforces this by making sure that every element has
      -- arrow to itself. That is, the leading diagonal is true.
      completeReflexivity(s:%):% ==
        set2:List S := s.set1
        struct2:List(List(Boolean)) := copy(s.struct1)
        for a in 1..(#set2) repeat
          setArrow!(struct2,a,a,true)
        [set2,struct2]

      -- Transitivity requires forall(x,y,z): x<=y and y<=z implies x<=z
      -- This function inforces this by making sure that the composition
      -- of any two arrows is also an arrow.
      completeTransitivity(s:%):% ==
        set2:List S := s.set1
        dim:NNI := #set2
        struct2:List(List(Boolean)) := copy(s.struct1)
        for a in 1..dim repeat
          for b in 1..dim repeat
            for c in 1..dim repeat
              if isArrow?(struct2,a,b) and isArrow?(struct2,b,c) then
                if not isArrow?(struct2,a,c) then
                  setArrow!(struct2,a,c,true)
        [set2,struct2]

      -- Antisymmetric requires forall(x,y): x<=y and y<=x iff x=y
      -- Returns true if this is the case for every element.
      isAntisymmetric?(s:%):Boolean ==
        dim:NNI := #(s.set1)
        struct2:List(List(Boolean)) := copy(s.struct1)
        for a in 1..dim repeat
          for b in 1..dim repeat
            if isArrow?(struct2,a,b) and isArrow?(struct2,b,a) then
              if a ~= b then return false
        true

      -- start of SetCategory definitions --

      hash(s : %) : SingleInteger == 0$SingleInteger

      -- return string representation
      -- I'm not sure how latex(s: %) is intended to be used but
      -- there is nothing specifically latex here, it just returns a
      -- string description of the graph.
      latex(n : %) : String ==
        -- s holds result that we are constructing
        s:String := ""
        s

      -- returns true if x equals y
      -- this is equality and not isomorphism
      -- that is it returns true only if exact index values and names are used
      -- in addition to the structure(arrows) being the same.
      _=(x : %, y : %) : Boolean ==
        if getVertices(x) ~= getVertices(y) then return false
        if getArrows(x) ~= getArrows(y) then return false
        true

      -- returns true if x is not equal to y
      _~_=(x : %, y : %) : Boolean == not(x = y)

      -- output
      coerce(s : %) : OutputForm ==
        mat:List List OutputForm := empty()$List(List(OutputForm))
        for a in s.struct1 repeat
          row:List OutputForm := empty()$List(OutputForm)
          for b in a repeat
            c:Symbol := if b then "true"::Symbol else "false"::Symbol
            row := concat(row,outputForm(c)$OutputForm)$List(OutputForm)
          mat := concat(mat,row)
        matrix(mat)

)abbrev category MEETLAT MeetSemilattice
++ Description: meet semilattice
++   Implementations in set, logic and orders
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: commutativity forall(x,y): x/\y=y/\x
++ Axiom: associativity forall(x,y,z): (x/\y)/\z=y/\(x/\z)
++ Axiom: unit forall x: x/\true()=x
++ Axiom: idempotence forall x: x/\x=x
MeetSemilattice: Category == SetCategory with
      _/_\: (%, %) -> %
        ++ returns the logical 'meet', e.g. 'and'.
      true: constant -> %
        ++ returns true.

)abbrev category JOINLAT JoinSemilattice
++ Description: join semilattice
++   Different from exterior Grassmann product operator as
++   that anticommutes.
++   need to check precidence when used as an infix operator
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: commutativity forall(x,y): x\/y=y\/x
++ Axiom: associativity forall(x,y,z): (x\/y)\/z=y\/(x\/z)
++ Axiom: unit forall x: x\/false()=x
++ Axiom: idempotence forall x: x\/x=x
JoinSemilattice: Category == SetCategory with
      _\_/: (%, %) -> %
        ++ returns the logical 'join', e.g. 'or'.
      false: constant -> %
        ++ returns false.

)abbrev category LAT Lattice
++ Description: lattice
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: absorptionMeetOverJoin forall(x,y): x/\(x\/y)=x
++ Axiom: absorptionJoinOverMeet forall(x,y): x\/(x/\y)=x
Lattice: Category == Join(MeetSemilattice,JoinSemilattice)

)abbrev category DISTLAT DistributiveLattice
++ Description: not every lattice is distributive so treat this
++              as a seperate case
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: distribution1 forall(x,y,z): x/\(y\/z)=(x/\y)\/(x/\z)
++ Axiom: distribution2 forall(x,y,z): x\/(y/\z)=(x\/y)/\(x\/z)
DistributiveLattice: Category == Lattice

)abbrev category FRAME Frame
++ Description: frames are used in topology and are the lattice
++              associated with the concept of a 'locale'.
++              see: [1]
++   A Frame is a Lattice where certain subsets are also Lattices
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: 
++ Axiom: 
++ Axiom: 
Frame(P:Poset(SetCategory)): Category == Lattice with
      meet:(List %) -> %
        ++ returns the logical 'meet' of some subset specified
        ++ by a list of elements.
      join:(List %) -> %
        ++ returns the logical 'join' of some subset specified
        ++ by a list of elements.

)abbrev domain FINLAT FiniteLattice
++ Author: Martin Baker
++ Description: This is the algebration of poset. A big difference between
++    this lattice domain and the poset domain is that, in this domain, the
++    REP holds a single node wheras in poset REP holds the whole poset.
FiniteLattice(S:SetCategory,p:Poset(S)) : Exports == Impl where
    NNI==> NonNegativeInteger
    Exports ==> Join(Lattice,CoercibleTo(OutputForm), SetCategory) with
     finiteLattice : (index:NNI) -> %
      ++ construct finite lattice element from index
     finiteLattice : (obj:S) -> %
      ++ construct finite lattice element from object

    Impl ==> add

      -- representation of element of lattice
      Rep := NNI

      -- construct finite lattice element from index
      finiteLattice(index:NNI) : % ==
        index

      -- construct finite lattice element from object
      finiteLattice(obj:S) : % ==
        objectToIndex(p,obj)$Poset(S)

      -- returns the logical 'meet', e.g. 'and'.
      _/_\(a:%,b:%) : % ==
        meet(p,a pretend NNI,b pretend NNI)$Poset(S)

      -- returns the logical 'join', e.g. 'or'.
      _\_/(a:%,b:%) : % ==
        join(p,a pretend NNI,b pretend NNI)$Poset(S)

      -- start of SetCategory definitions --

      hash(s : %) : SingleInteger == 0$SingleInteger

      -- return string representation
      -- I'm not sure how latex(s: %) is intended to be used but
      -- there is nothing specifically latex here, it just returns a
      -- string description of the graph.
      latex(n : %) : String ==
        -- s holds result that we are constructing
        s:String := ""
        s

      -- returns true if x equals y
      -- this is equality and not isomorphism
      -- that is it returns true only if exact index values and names are used
      -- in addition to the structure(arrows) being the same.
      _=(x : %, y : %) : Boolean ==
        (x pretend NNI)=(y pretend NNI)

      -- returns true if x is not equal to y
      _~_=(x : %, y : %) : Boolean == not(x = y)

      -- output
      coerce(s : %) : OutputForm ==
        index:NNI := s pretend NNI
        --if index=0 then return outputForm("error")
        obj:S := indexToObject(p,index)
        (obj::OutputForm)$S

)abbrev domain FINFRM FiniteFrame
++ Author: Martin Baker
++ Description: A Frame is a Lattice where certain subsets are also Lattices
FiniteFrame(S:SetCategory,p:Poset(S)) : Exports == Impl where
    NNI==> NonNegativeInteger
    --Exports ==> Join(Lattice,Frame(Poset(SetCategory)),CoercibleTo(OutputForm), SetCategory) with
    --Exports ==> Join(Lattice,FiniteLattice(SetCategory,Poset(SetCategory)),CoercibleTo(OutputForm), SetCategory) with
    -- *** FIX ME can't work out how to inherit from FiniteLattice
    Exports ==> Join(Lattice,CoercibleTo(OutputForm), SetCategory) with
     finiteFrame : (index:NNI) -> %
      ++ construct finite lattice element from index
     finiteFrame : (obj:S) -> %
      ++ construct finite lattice element from object

    -- *** FIX ME can't work out how to inherit from FiniteLattice
    --Impl == FiniteLattice(SetCategory,Poset(SetCategory)) add
    Impl == add

     -- *** FIX ME representation should really be inherited from FiniteLattice
     Rep := NNI

     -- returns the logical 'meet' of some subset specified
     -- by a list of elements.
     meet(elements:List(%)):% ==
       e:List(NNI) := [(x pretend NNI) for x in elements]
       meet(p,e)$Poset(S)

     -- returns the logical 'join' of some subset specified
     -- by a list of elements.
     join(elements:List(%)):% ==
       e:List(NNI) := [(x pretend NNI) for x in elements]
       join(p,e)$Poset(S)

)abbrev package POWSET Powerset
++ Author: Martin Baker
++ Date Created: Aug 2015
++ Date Last Updated: Aug 2015
++ Description:
++  Provides functions to construct powerset
++  Perhaps it should be called a 'powerlist' but since we do
++  not expect duplicates or reqire specific ordering it is
++  essentially the same.
PI ==> PositiveInteger
NNI==> NonNegativeInteger

Powerset(S : SetCategory) : with
  powerset:(List S) -> Poset(List(S))

 == add

  addDimensionToObjects(a:List(List(S)),newObj:S):List(List(S)) ==
    b:List(List(S)) := nil
    for x in a repeat
      x1:List(S) :=concat(x,newObj)
      b := concat(b,x1)
    concat(a,b)

  addDimensionToArrows(a:List(List(Boolean))):List(List(Boolean)) ==
    res:List(List(Boolean)) := [empty()$List(Boolean)]
    fst:Boolean := true
    for xrepeat in 1..2 repeat
      for x in a repeat
        thisRow:List(Boolean) := empty()$List(Boolean)
        for yrepeat in 1..2 repeat
          for y in x repeat
            topRight:Boolean := (xrepeat = 1) and (yrepeat = 2)
            thisRow := concat(thisRow,if topRight then false else y)
        if fst
          then
            res := [copy(thisRow)]
            fst := false
          else
            res := concat(res,copy(thisRow))$List(List(Boolean))
    res

  powerset(objs:List S):Poset(List(S)) ==
    eles:List(List(S)) := [nil]
    arrows: List(List(Boolean)):=[[true]]
    for x in objs repeat
      eles := addDimensionToObjects(eles,x)
      arrows := addDimensionToArrows(arrows)
    poset(eles,arrows)$Poset(List(S))

)if false
\section{Intuitionistic Logic}
The intuitionisticLogic domain implements a Heyting algebra implied
by intuitionistic logic similar to boolean algebra.

Intuitionistic or constructive logic is similar to classical logic
but where the law of excluded middle is not used.

The implementation starts with a 'free logic algebra' that is an
algebra where each combination of inputs to /\ , \/ and - generates
a new element. So an expression like T /\ T is just T /\ T and does
not simplify.

Then by adding "simplification rules" (should I have called them
relators?) then other logic algebras can be implemented (intuitional,
ternary, many-valued, boolean) just by adding the "rules".

These "rules" are hardcoded into the /\ , \/ and - implementations
(rather than implementing a true rule based system).

Simplification rules :

    ~T -> _|_
    ~(~T) -> T
    ~x /\ x -> _|_
    x /\ ~x -> _|_
    x /\ x -> x
    _|_ /\ x -> _|_
    x /\ _|_ -> _|_
    T \/ x -> T
    x \/ T -> T
    x \/ x -> x
    x /\ T -> x
    T /\ x -> x
    x \/ _|_ -> x
    _|_ \/ x -> x

where:

    T = true
    _|_ = false
    x = arbitrary proposition

An opton to generalise this code might be to implement the 'free
logic algebra' as a category, then intuitional, ternary, many-valued,
boolean could be domains which overload /\ , \/ and - with their own
sets of rules.

Note : Please be aware that changes may be made in the future to improve
      and correct intuitionistic logic domain, such as:
\begin{itemize}
\item investigate change of meaning of $=$ for intuitionistic logic to
     represent equivalence rather than equality.
\item implement more complete algorithm to decide if two (quantifier-free)
     intuitionistic formulas are equivalent.
\end{itemize}
\section{Intuitionistic Logic Tutorial}
Intuitionistic logic has many possible values : true $T$, false $_|_$ and
infinitely many other values generated by constructs such as inverse.
These can be constructed as follows:

\begin{verbatim}
(1) -> logicF()

   (1)  "_|_"
                                                             Type : ILogic
(2) -> logicT()

   (2)  "T"
                                                             Type : ILogic
(3) -> ~logicT()

   (3)  "_|_"
                                                             Type : ILogic
\end{verbatim}

This logic has different rules from boolean algebra and all constructions
do not reduce to true or false. To test out our constructs we will use
the following list:

\begin{verbatim}
(4) -> l:List ILogic := [logicF(),logicT(),proposition("a"),~proposition("a"),proposition("b"),~proposition("b")]

 LISP output:
((0 F) (0 T) (1 a) (3 NOT 1 a) (1 b) (3 NOT 1 b))
                                                       Type : List(ILogic)
\end{verbatim}

First we will try 'not':
\begin{verbatim}
(5) -> [(~j)::OutputForm for j in l]

   (5)  ["~(_|_)","_|_","~(a)","~(~(a))","~(b)","~(~(b))"]
                                                   Type : List(OutputForm)
\end{verbatim}

We can print a truth table for 'and' and 'or'. This is the same as
boolean logic for true/false values and extended for the unproven case.
\begin{verbatim}
(6) -> matrix[ [(k /\ j)::OutputForm for j in l] for k in l]

     (6)
    SUB
       matrix
       ["_|_","_|_","_|_","_|_","_|_","_|_"]
      ["_|_","T","a","~(a)","b","~(b)"]
      ["_|_","a","a","_|_","(a/\b)","(a/\~(b))"]
      ["_|_","~(a)","_|_","~(a)","(~(a)/\b)","(~(a)/\~(b))"]
      ["_|_","b","(b/\a)","(b/\~(a))","b","_|_"]
      ["_|_","~(b)","(~(b)/\a)","(~(b)/\~(a))","_|_","~(b)"]
                                                               Type : Symbol

Note : Its hard to read this table in text, it displays better as
html on this page:
http : //www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/

(7) -> matrix[ [(k \/ j)::OutputForm for j in l] for k in l]

     (7)
    SUB
       matrix
      ["_|_","T","a","~(a)","b","~(b)"]
      ["T","T","T","T","T","T"]
      ["a","T","a","(a\/~(a))","(a\/b)","(a\/~(b))"]
      ["~(a)","T","(~(a)\/a)","~(a)","(~(a)\/b)","(~(a)\/~(b))"]
      ["b","T","(b\/a)","(b\/~(a))","b","(b\/~(b))"]
      ["~(b)","T","(~(b)\/a)","(~(b)\/~(a))","(~(b)\/b)","~(b)"]

                                                               Type : Symbol
\end{verbatim}

'implies' produces the following truth table.
\begin{verbatim}
(8) -> matrix[ [implies(k, j)::OutputForm for j in l] for k in l]


   (8)
    SUB
       matrix
       ["T","T","(_|_->a)","(_|_->~(a))","(_|_->b)","(_|_->~(b))"]
       ["_|_","T","(T->a)","(T->~(a))","(T->b)","(T->~(b))"]
       ["(a->_|_)","(a->T)","(a->a)","(a->~(a))","(a->b)","(a->~(b))"]
       ["(~(a)->_|_)", "(~(a)->T)", "(~(a)->a)", "(~(a)->~(a))", "(~(a)->b)",
        "(~(a)->~(b))"]
       ["(b->_|_)","(b->T)","(b->a)","(b->~(a))","(b->b)","(b->~(b))"]
       ["(~(b)->_|_)", "(~(b)->T)", "(~(b)->a)", "(~(b)->~(a))", "(~(b)->b)",
        "(~(b)->~(b))"]
                                                               Type : Symbol
\end{verbatim}

Now that we can do intuitionistic logic with constant values we can
go on to represent theories. We can enter a symbolic value as follows:
\begin{verbatim}
(9) -> proposition("p1")

   (9)  "p1"
                                                             Type : ILogic
\end{verbatim}

When applying a symbolic value, then it may not possible to compress
as a single node, so the result remains as a tree. So (13) can be
reduced to a single value $_|_$, because the result does not depend
on \verb'a', however in (12) we cannot reduce to a single value.
\begin{verbatim}
(10) -> proposition("a") /\ proposition("b")

   (10)  "(a/\b)"
                                                             Type : ILogic
(11) -> implies(proposition("a"),proposition("b"))

   (11)  "(a->b)"
                                                             Type : ILogic
(12) -> proposition("a") /\ logicT()

   (12)  "a"
                                                             Type : ILogic
(13) -> proposition("a") /\ logicF()

   (13)  "_|_"
                                                             Type : ILogic
\end{verbatim}
\section{applying modus ponens}
modus ponens tells us that given : 'a' and 'a->b' then we can imply 'b'.
So we first assert 'a' and 'a->b' as follows:
\begin{verbatim}
(14) -> givens := proposition("a") /\ implies(proposition("a"),proposition("b"))

   (14)  "(a/\(a->b))"
                                                             Type : ILogic
\end{verbatim}
We then factor into seperate terms:
\begin{verbatim}
(15) -> fgivens := factor(givens)

 LISP output:
((1 a) (2 . UNPRINTABLE))
                                                       Type : List(ILogic)
\end{verbatim}
note : List ILOGIC to OutputForm is fixed in latest FriCAS so it will
now display : [a, a->b]

We now apply the deductions function to this list.
\begin{verbatim}
(16) -> deduct := deductions(fgivens)

 LISP output:
((1 b))
                                                       Type : List(ILogic)
\end{verbatim}
so we get the required deduction 'b'

\section{domain ILOGIC ILogic}
)endif

)abbrev domain ILOGIC ILogic
++ Author: Martin Baker
++ Date Created: March 2011
++ Date Last Updated: September 2011
++ Basic Operations:
++ Related Constructors:
++ Keywords: intuitionisticLogic
++ Description: ILogic is an algebra with
++ true, false and other 'unproven' values
++ References:
++ http: //www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/

ILogic() : Exports == Implementation where

 NNI==> NonNegativeInteger
 PR ==> Record(rft : %, pout : NNI)
   ++ parse result includes term returned and new index

 Exports == Join(Logic, CoercibleTo(OutputForm)) with
  logicT : () -> %
    ++ true is a logical constant.
  logicF : () -> %
    ++ false (contradiction) is a logical constant.
  proposition : (s : String) -> %
    ++ Constructs a proposition
  implies : (%, %) -> %
    ++ implies(a, b) returns the logical implication
    ++ of ILogic a and b.
    ++ a is premise, b is conclusion, result is false (contradiction)
    ++ if premise=true and conclusion=false
    ++ does not mean there is a causal connection
  redux : (n : %) -> %
    ++ attempt to simplify theory
    ++ apply recursively to subnodes
    ++ normally this should not be necessary since logic values are
    ++ interpreted when constructed
  factor : (n : %) -> List %
    ++ splits n into a list of factors which must be true for the
    ++ whole to be true.
    ++ This assumes that the top level is already a set of factors
    ++ seperated by /\ otherwise the result will just be a list with
    ++ one entry: 'n'.
    ++ This is used when converting ILogic to types by using the
    ++ Curry-Howard isomorphism.
  deductions : (ln : List %) -> List %
    ++ assumes ln contains a list of factors which must be true for
    ++ the whole to be true (such as the list produced by factor).
    ++ From this deductions attemps to produce a list of other
    ++ proposition that must also be true by using modus ponens.
    ++ This is used to determine the returned type when converting
    ++ ILogic to types by using the Curry-Howard isomorphism.
  "=": (a:%, b:%) -> Boolean
    ++ returns true (boolean true) if intuitionisticLogic values
    ++ are the same.
    ++ Translates from Intuitionistic Logic to Boolean Logic
  opType : (n : %) -> Symbol
    ++ if this is a compound op then opType returns the type of
    ++ that op:
    ++ "IMPLY"::Symbol =implies
    ++ "AND"::Symbol=/\
    ++ "OR"::Symbol=\/
    ++ "NOT"::Symbol=~
    ++ "OTHER"::Symbol=not compound op
  getChildren : (n : %) -> List %
    ++ returns child nodes if this is a compound term
    ++ otherwise returns []
  atom? : (n : %) -> Boolean
    ++ returns true if this is an atom, that is a leaf node
    ++ otherwise return false if this is a compound term
  value : (n : %) -> Symbol
    ++ returns:
    ++   "T"::Symbol = T
    ++   "F"::Symbol = _|_
    ++   "E"::Symbol = error
    ++   "P"::Symbol = proposition
    ++   "C"::Symbol = compound
    ++ Constructs lambda term and bind any variables with the name provided
  parseIL : (t1 : String) -> %
    ++ Constructs intuitionistic logic terms from a string
    ++ notation assumes format like this:
    ++ <term> : := var | <term>/\<term> | <term>\/<term> |
    ++            <term>-><term> | "("<term>")"
  parseIL2 : (t1 : String, pin : NNI) -> PR
    ++ Constructs intuitionistic logic terms from a string
    ++ notation assumes format like this:
    ++ <term2> : := var | "("<term>")"
    ++ <term> : := var | <term>/\<term> | <term>\/<term> |
    ++            <term>-><term> | "("<term>")"
  parseILTerm : (t1 : String, pin : NNI)->PR
    ++ parseTerm is used by parseIL. It would rarely be called
    ++ externally but it is here to allow it to call parseIL
    ++ that is to allow circular calls
  toString : (n : %) -> String
    ++ creates a string representaion of this term and its sub-terms
  toStringUnwrapped : (n : %) -> String
    ++ similar to 'toString' but does not put outer compound terms
    ++ in brackets
  coerce : (n : %) -> OutputForm
    ++ output

 Implementation == add

  Rep := Union(_
         const : Record(val : Symbol), _
         var : Record(str : String), _
         binaryOp : Record(typ : Symbol, c1 : %, c2 : %), _
         unaryOp : Record(typ : Symbol, c1 : %)_
         )
    ++ this allows us to represent an intuitionistic
    ++ expression as a tree structure where the nodes are
    ++ one of:
    ++ 1) const: Record(val: Symbol)
    ++   holds the true and false values:
    ++   "T"::Symbol = T
    ++   "F"::Symbol = _|_
    ++
    ++ 2) var: Record(str: String)
    ++   holds a proposition name
    ++
    ++ 3) binaryOp: Record(typ: Symbol, c1: %, c2: %)
    ++   holds binary operations:
    ++   "IMPLY"::Symbol =implies
    ++   "AND"::Symbol=/\
    ++   "OR"::Symbol=\/
    ++ 4) unaryOp: Record(typ: Symbol, c1: %)
    ++   holds unary operations the only one is
    ++   "NOT"::Symbol = ~

  -- Constructs a proposition
  proposition(s : String) : % == [[s]]

  -- literal constructors
  logicT() == [["T"::Symbol]]
  logicF() == [["F"::Symbol]]

  -- not operator: returns the logical complement
  -- in general case 'x' this will generate a new element '~x'
  -- but for specific cases we can apply the simplification rules:
  -- ~T -> F
  -- ~(~T) -> T
  ~ b ==
    -- apply rule: ~T -> F
    if (b case const) then
      if (b.const.val = "T"::Symbol) then return [["F"::Symbol]]
    -- apply rule: ~(~T) -> T
    if (b case unaryOp) then
      c : % := b.unaryOp.c1
      if (c case unaryOp) then
        d : % := c.unaryOp.c1
        if (d case const) then
          if (d.const.val = "T"::Symbol) then return [["F"::Symbol]]
    [["NOT"::Symbol,b]]

  -- /\ returns the logical 'meet', e.g. 'and'.
  --
  -- simplification rules:
  -- ~x /\ x -> F
  -- x /\ ~x -> F
  -- x /\ x -> x
  -- F /\ x -> F
  -- x /\ F -> F
  -- x /\ T -> x
  -- T /\ x -> x
  --
  _/_\(a : %, b : %) ==
    -- apply rule: F /\ x -> F
    if (a case const) then
      if (a.const.val = "F"::Symbol) then return [["F"::Symbol]]
    -- apply rule: x /\ F -> F
    if (b case const) then
      if (b.const.val = "F"::Symbol) then return [["F"::Symbol]]
    -- apply rule: x /\ x -> x
    if a = b then
      return a
    -- apply rule: x /\ ~x -> F
    if a=(~b) then
      return [["F"::Symbol]]
    -- apply rule: ~x /\ x -> F
    if (~a)=b then
      return [["F"::Symbol]]
    -- apply rule: x /\ T -> x
    if (b case const) then
      if (b.const.val = "T"::Symbol) then return a
    -- apply rule: T /\ x -> x
    if (a case const) then
      if (a.const.val = "T"::Symbol) then return b
    [["AND"::Symbol,a,b]]


  -- \/ returns the logical 'join', e.g. 'or'.
  --
  -- simplification rules:
  -- T \/ x -> T
  -- x \/ T -> T
  -- x \/ x -> x
  -- x \/ _|_ -> x
  -- _|_ \/ x -> x
  --
  _\_/(a : %, b : %) ==
    -- apply rule: T \/ x -> T
    if (a case const) then
      if (a.const.val = "T"::Symbol) then return [["T"::Symbol]]
    -- apply rule: x \/ T -> T
    if (b case const) then
      if (b.const.val = "T"::Symbol) then return [["T"::Symbol]]
    -- apply rule: x \/ x -> x
    if a = b then
      return a
    -- apply rule: x \/ _|_ -> x
    if (b case const) then
      if (b.const.val = "F"::Symbol) then return a
    -- apply rule: _|_ \/ x -> x
    if (a case const) then
      if (a.const.val = "F"::Symbol) then return b
    [["OR"::Symbol,a,b]]

  -- implies(a, b) returns the logical implication
  -- of ILogic a and b.
  -- a is premise, b is conclusion, result is false (contradiction)
  -- if premise=true and conclusion=false
  -- does not mean there is a causal connection
  implies(a : %, b : %) ==
    if (a case const) and (b case const) then
      if (a.const.val ~= "F"::Symbol) and (b.const.val = "F"::Symbol) then return [["F"::Symbol]]
      return [["T"::Symbol]]
    [["IMPLY"::Symbol,a,b]]

  -- attempt to simplify theory
  -- apply recursively to subnodes
  -- normally this should not be necessary since logic values are
  -- interpreted when constructed
  --
  -- simplification rules:
  -- ~T -> F
  -- ~(~T) -> T
  -- ~x /\ x -> F
  -- x /\ ~x -> F
  -- x /\ x -> x
  -- F /\ x -> F
  -- x /\ F -> F
  -- x /\ T -> x
  -- T /\ x -> x
  -- T \/ x -> T
  -- x \/ T -> T
  -- x \/ x -> x
  -- x \/ _|_ -> x
  -- _|_ \/ x -> x
  --
  redux(n : %) : % ==
    if n case const then
      return n
    if n case var then
      return n
    if n case binaryOp then
      if n.binaryOp.typ="IMPLY"::Symbol then
        return implies(redux(n.binaryOp.c1), redux(n.binaryOp.c2))
      if n.binaryOp.typ="AND"::Symbol then
        return _/_\(redux(n.binaryOp.c1), redux(n.binaryOp.c2))
      if n.binaryOp.typ="OR"::Symbol then
        return _\_/(redux(n.binaryOp.c1), redux(n.binaryOp.c2))
    if n case unaryOp then
      return ~(redux(n.unaryOp.c1))
    n

  -- splits n into a list of factors which must be true for the
  -- whole to be true.
  -- This assumes that the top level is already a set of factors
  -- seperated by /\ otherwise the result will just be a list with
  -- one entry: 'n'.
  -- This is used when converting ILogic to types by using the
  -- Curry-Howard isomorphism.
  factor(n : %) : List % ==
    if ~(n case binaryOp) then return [n]
    if ~(n.binaryOp.typ="AND"::Symbol) then return [n]
    ch : List % := getChildren(n)
    concat(factor(first ch), factor(second ch))

  -- remove duplicates. Return elements of 'b' except those that are
  -- in 'a'
  -- I would use duplicate removal built into List but that only
  -- works when the list is defined over SETCAT
  removeDup(a : List %, b : List %) : List % ==
    res : List % := []
    for b1 in b repeat
      fnd : Boolean := false()
      for a1 in a repeat
        if a1 = b1 then fnd := true()
      if not fnd then res := concat(res, b1)
    res

  -- a single iteration for deductions below.
  deductions1(ln : List %) : List % ==
    res : List % := []
    for n in ln repeat
      if n case binaryOp then
        if n.binaryOp.typ="IMPLY"::Symbol then
          ch : List % := getChildren(n)
          for n2 in ln repeat
            if (first ch)=n2 then res := concat(res, second ch)
    res

  -- assumes ln contains a list of factors which must be true for
  -- the whole to be true (such as the list produced by factor).
  -- From this deductions attemps to produce a list of other
  -- proposition that must also be true by using modus ponens.
  -- This is used to determine the returned type when converting
  -- ILogic to types by using the Curry-Howard isomorphism.
  deductions(ln : List %) : List % ==
    res : List % := []
    thisres : List % := deductions1(ln)
    res := concat(res, thisres)$(List %)
    -- these deductions may lead to further deductions so we
    -- need to apply again until there are no more deductions
    emptyres : Boolean := empty?(thisres)$(List %)
    loopbreaker := 1::NNI
    while not emptyres and (loopbreaker<20)repeat
      allres : List % := concat(ln, res)
      thisres := deductions1(allres)
      thisres := removeDup(res, thisres)
      thisres := removeDup(allres, thisres)
      res := concat(res, thisres)$(List %)
      emptyres := empty?(thisres)$(List %)
      loopbreaker := loopbreaker + 1
    res

  -- if this is a compound op then opType returns the type of that op:
  -- "IMPLY"::Symbol =implies
  -- "AND"::Symbol=/\
  -- "OR"::Symbol=\/
  -- "NOT"::Symbol=~
  -- "OTHER"::Symbol=not compound op
  opType(n : %) : Symbol ==
    if n case binaryOp then return n.binaryOp.typ
    if n case unaryOp then return "NOT"::Symbol
    "OTHER"::Symbol

  -- returns true if this is an atom, that is a leaf node
  -- otherwise return false if this is a compound term
  atom?(n : %) : Boolean == (n case var) or (n case const)

  -- returns:
  --   "F"::Symbol = _|_
  --   "T"::Symbol = T
  --   "E"::Symbol = error
  --   "P"::Symbol = proposition
  --   "C"::Symbol = compound
  value(n : %) : Symbol ==
    if n case const then
      if (n.const.val = "F"::Symbol) then return "F"::Symbol
      if (n.const.val = "T"::Symbol) then return "T"::Symbol
      return "E"::Symbol
    if n case var then
      return "P"::Symbol
    "C"::Symbol

  -- returns child nodes if this is a compound term
  -- otherwise returns []
  getChildren(n : %) : List % ==
    if atom?(n) then return []
    if n case binaryOp then
      return [n.binaryOp.c1, n.binaryOp.c2]
    if n case unaryOp then
      return [n.unaryOp.c1]

  -- returns true (boolean true) if intuitionisticLogic values
  -- are the same. The terms must match exactly not just be
  -- equivalent, that is x /\ 1 is not equal to x
  -- Translates from Intuitionistic Logic to Boolean Logic
  a = b ==
    if (a case const) and (b case const) then
      if (a.const.val = "F"::Symbol) and (b.const.val = "F"::Symbol) then return true
      if (a.const.val = "T"::Symbol) and (b.const.val = "T"::Symbol) then return true
      return false
    if (a case var) and (b case var) then
      -- variable node so compare names
      if a.var.str = b.var.str then return true
      return false
    if (a case binaryOp) and (b case binaryOp) then
      -- binary node which has two subnodes c1 and c2
      if (a.binaryOp.typ ~= b.binaryOp.typ) then return false
      if (a.binaryOp.c1 = b.binaryOp.c1) and (a.binaryOp.c2 = b.binaryOp.c2) then return true
      return false
    if (a case unaryOp) and (b case unaryOp) then
      -- unary node which has a subnode c1
      if (a.unaryOp.typ ~= b.unaryOp.typ) then return false
      if a.unaryOp.c1 = b.unaryOp.c1 then return true
      return false
    false

  parseBracketTerm(t1 : String, pin : NNI) : PR ==
    p1 := pin
    trm : % := logicT()
    ch := qelt(t1, p1)
    if not (ch = char("(")) then
      error "bracket term must start with ("
      return [trm, p1]
    p1 := p1 + (1::NNI)
    if p1 > maxIndex(t1) then
      error "opening but no closing bracket"
      return [trm, p1]
    r2 := parseILTerm(t1, p1)
    trm := r2.rft
    p1 := r2.pout
    ch := qelt(t1, p1)
    if not (ch = char(")")) then
      error "can't find closing bracket"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    [trm, p1]

  -- parse /\ term
  -- expects first term to be read already
  -- should now be pointing to /\ characters
  parseILand(t1 : String, pin : NNI, firstTerm : %) : PR ==
    p1 := pin
    pt : NNI := pin
    trm : % := logicT()
    ch := qelt(t1, p1)
    if not (ch = char("/")) then
      error "expecting /\"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    ch := qelt(t1, p1)
    if not (ch = char("\")) then
      error "expecting /\"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    --sayMsg concat("st ch=",ch::String)
    r : PR := parseILTerm(t1, p1)
    secondTerm := r.rft
    p1 := r.pout
    [_/_\(firstTerm, secondTerm), p1]

  -- parse \/ term
  -- expects first term to be read already
  -- should now be pointing to \/ characters
  parseILor(t1 : String, pin : NNI, firstTerm : %) : PR ==
    p1 := pin
    pt : NNI := pin
    trm : % := logicT()
    ch := qelt(t1, p1)
    if not (ch = char("\")) then
      error "expecting \/"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    ch := qelt(t1, p1)
    if not (ch = char("/")) then
      error "expecting \/"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    --sayMsg concat("st ch=",ch::String)
    r : PR := parseILTerm(t1, p1)
    secondTerm := r.rft
    p1 := r.pout
    [_\_/(firstTerm, secondTerm), p1]

  -- parse -> term
  -- expects first term to be read already
  -- should now be pointing to -> characters
  parseILfn(t1 : String, pin : NNI, firstTerm : %) : PR ==
    p1 := pin
    pt : NNI := pin
    trm : % := logicT()
    ch := qelt(t1, p1)
    if not (ch = char("-")) then
      error "expecting ->"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    ch := qelt(t1, p1)
    if not (ch = char(">")) then
      error "expecting ->"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    --sayMsg concat("st ch=",ch::String)
    r : PR := parseILTerm(t1, p1)
    secondTerm := r.rft
    p1 := r.pout
    [implies(firstTerm, secondTerm), p1]

  -- construct a type by parsing a string t1
  -- pin is index to string at start of parse
  parseILName(t1 : String, pin : NNI) : PR ==
    vnm:String := ""
    pt : NNI := pin
    ch := qelt(t1, pt)
    --sayMsg concat("st ch=",ch::String)
    while alphanumeric?(ch) repeat
      vnm := concat(vnm, ch)
      pt := pt + (1::NNI)
      if pt > maxIndex(t1) then
        return [proposition(vnm), pt]
      ch := qelt(t1, pt)
    [proposition(vnm), pt]

  parseILTerm(t1 : String, pin : NNI) : PR ==
    p1 := pin
    res : % := logicT()
    ch := qelt(t1, p1)
    --sayMsg concat(["parseTerm ch=",ch::String," p1=",string(p1)])$String
    -- first remove leading spaces
    while ch = char(" ") repeat
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        --sayMsg concat(["parseTerm(",t1,") 1 giving:",toString(res)])
        return [res, p1]
      ch := qelt(t1, p1)
    r : PR := [res, p1]
    if alphabetic?(ch) then r := parseILName(t1, p1)
    if ch = char("(") then r := parseBracketTerm(t1,p1)
    res := r.rft
    p1 := r.pout
    -- now check for compound term
    if p1 > maxIndex(t1) then
      --sayMsg concat(["parseTerm(",t1,") 2 giving:",toString(res)])
      return [res, p1]
    ch := qelt(t1, p1)
    if ch = char(" ") then
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        --sayMsg concat(["parseTerm(",t1,") 3 giving:",toString(res)])
        return [res, p1]
    ch := qelt(t1, p1)
    if ch = char("/") then
      r := parseILand(t1, p1, res)
      res := r.rft
      p1 := r.pout
    if ch = char("\") then
      r := parseILor(t1, p1, res)
      res := r.rft
      p1 := r.pout
    if ch = char("-") then
      r := parseILfn(t1, p1, res)
      res := r.rft
      p1 := r.pout
    [res, p1]

  -- Constructs intuitionistic logic terms from a string
  -- notation assumes format like this:
  -- <term> : := var | <term>/\<term> | <term>\/<term> |
  --            <term>-><term> | "("<term>")"
  parseIL2(t1 : String, pin : NNI) : PR ==
    p1 := pin
    res : % := logicT()
    ch := qelt(t1, p1)
    --sayMsg concat(["parseIL ch=",ch::String," p1=",string(p1)])$String
    -- first remove leading spaces
    while ch = char(" ") repeat
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        --sayMsg concat(["parseTerm(",t1,") 1 giving:",toString(res)])
        return [res, p1]
      ch := qelt(t1, p1)
    r : PR := [res, p1]
    if alphabetic?(ch) then r := parseILName(t1, p1)
    if ch = char("(") then r := parseBracketTerm(t1,p1)
    res := r.rft
    p1 := r.pout
    [res, p1]

  -- Constructs intuitionistic logic terms from a string
  -- notation assumes format like this:
  -- <term> : := var | <term>/\<term> | <term>\/<term> |
  --            <term>-><term> | "("<term>")"
  parseIL(t1 : String) : % ==
    r := parseILTerm(t1, minIndex(t1)::NNI)
    --sayMsg concat(["parseIL(",t1,") giving:",toString(tm)])
    r.rft

  -- return string representation
  toString(n : %) : String ==
    if n case const then
      if (n.const.val = "F"::Symbol) then return "__|__"
      if (n.const.val = "T"::Symbol) then return "T"
      return "?"
    if n case var then
      return n.var.str
      --sayMsg concat(["toString case i1=",s])
      --sayMsg n
    if n case binaryOp then
      -- binary node which has two subnodes c1 and c2
      s1:String := "->"
      if n.binaryOp.typ = "AND"::Symbol then s1 := "/\"
      if n.binaryOp.typ = "OR"::Symbol then s1 := "\/"
      return concat(["(",toString(n.binaryOp.c1),s1,toString(n.binaryOp.c2),")"])
    if n case unaryOp then
      -- unary node which has a subnode c1
     return concat(["~(",toString(n.unaryOp.c1),")"])
    "error"

  -- similar to 'toString' but does not put outer compound terms
  -- in brackets
  toStringUnwrapped(n : %) : String ==
    if n case const then
      if (n.const.val = "F"::Symbol) then return "__|__"
      if (n.const.val = "T"::Symbol) then return "T"
      return "?"
    if n case var then
      return n.var.str
      --sayMsg concat(["toString case i1=",s])
      --sayMsg n
    if n case binaryOp then
      -- binary node which has two subnodes c1 and c2
      s1:String := "->"
      if n.binaryOp.typ = "AND"::Symbol then s1 := "/\"
      if n.binaryOp.typ = "OR"::Symbol then s1 := "\/"
      return concat([toString(n.binaryOp.c1), s1, toString(n.binaryOp.c2)])
    if n case unaryOp then
      -- unary node which has a subnode c1
     return concat(["~(",toString(n.unaryOp.c1),")"])
    "error"

  -- output
  coerce(n : %) : OutputForm ==
    toString(n)::OutputForm

)abbrev domain BITST BitStreamFrame
++ Author: Martin Baker
++ Description: An example of a frame taken from Vickers section 3.7
BitStreamFrame() : Exports == Impl where
    NNI==> NonNegativeInteger
    Exports ==> Join(Lattice,CoercibleTo(OutputForm), SetCategory) with
     starts : (index:List(Boolean)) -> %
      ++ construct bit stream
     starts : (str:String) -> %
      ++ construct bit stream by parsing string containing 0,1 and *

    Impl == add

     -- A single bitstream is coded as 'List Boolean', this is the
     -- bit sequence starting from the first bit.
     -- This representaion holds all allowable bitstreams
     -- or'd together as a list of bitstreams.
     Rep := List(List(Boolean))

     -- construct bit stream
     starts(index:List(Boolean)):% ==
       [index]
      
     -- construct bit stream by parsing string containing 0,1 and *
     starts(str:String):% ==
       res:List(Boolean) := []
       cs:List Character := entries(str)
       for c in cs repeat
         if c=char("0") then res:=concat(res,false)
         if c=char("1") then res:=concat(res,true)
       [res]

     -- returns the logical 'meet', e.g. 'and'.
     _/_\(a:%,b:%) : % ==
       res: List(List(Boolean)) := concat(a pretend List(List(Boolean)),b pretend List(List(Boolean)))$List(List(Boolean))
       res

     -- returns the logical 'join', e.g. 'or'.
     _\_/(a:%,b:%) : % ==
       res: List(List(Boolean)) := concat(a pretend List(List(Boolean)),b pretend List(List(Boolean)))$List(List(Boolean))
       res

     -- start of SetCategory definitions --

     hash(s : %) : SingleInteger == 0$SingleInteger

     -- return string representation
     -- I'm not sure how latex(s: %) is intended to be used but
     -- there is nothing specifically latex here, it just returns a
     -- string description of the graph.
     latex(n : %) : String ==
       -- s holds result that we are constructing
       s:String := ""
       s

     -- returns true if x equals y
     -- this is equality and not isomorphism
     -- that is it returns true only if exact index values and names are used
     -- in addition to the structure(arrows) being the same.
     _=(x : %, y : %) : Boolean ==
       if #x ~= #y then return false
       len:NNI := #x
       for i in 1..len repeat
         if x.i ~= y.i then return false
       true

     -- returns true if x is not equal to y
     _~_=(x : %, y : %) : Boolean == not(x = y)

     -- output
     coerce(s : %) : OutputForm ==
       cs:List OutputForm := []
       for row in s repeat
         r:List OutputForm := ["starts:"::OutputForm]
         for x in row repeat
           ro:OutputForm := "0"::OutputForm
           if x then ro := "1"::OutputForm
           r:= concat(r,ro)
           --r:= concat(r," "::OutputForm)
         c:OutputForm := hconcat(r)
         cs:= concat(cs,c)
       vconcat(cs)

--Copyright (c) 2015, Martin J Baker.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of Martin J Baker. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


)if false
\eject
\begin{thebibliography}{99}
For more details see:
[1] Topology Via Logic - Steven Vickers ISBN 0 521 57651 2
[2] J. Lambek, P. J. Scott 1988
     Introduction to Higher-Order Categorical Logic ISBN : 0521356539
     This book shows the relationship between mathematical logic and category
     theory. Although this is not used in the current code, it suggests
     a promising generalisation.
[3] I have put a fuller explanation of this code here:
http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
\end{thebibliography}
\end{document}
)endif

