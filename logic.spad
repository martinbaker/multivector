)if false
\documentclass{article}
\usepackage{axiom}
\usepackage{url}
\begin{document}
\title{lattice related mathematical structures}
\author{Martin J Baker}
\maketitle
\begin{abstract}
In this pamphlet are partial order, lattice structures and logic operations based on
them. Logic operations based on lattice structures
Finite lattices may be based on a poset (partial order)
so see 'UserDefinedPartialOrdering' package in setorder.spad
I have put a fuller explanation of this code here:
http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
\end{abstract}

This document is just experimental, I am just trying out various things, don't
worry about the detail its the big picture that I would like help with.

I am using Steven Vickers book [ref 1] as my reference.

There are a common set of lattice-like structures that occur in various branches
of mathematics such as orders, logic and sets. I would like to represent these
structures in FriCAS.

What I have done so far seems to be applicable to finite lattices but a lot of my
interest in this subject would be infinite structures. Especially structures
from Topology such as a 'frame' which is a complete lattice with infinite meets.
I am also interested in structures from computer science such as domain theory.

My strategy so far is to have two sorts of domains:
\begin{itemize}
\item posets - here the representation is the whole structure.
\item lattices - here the representation is an element of the structure.
\end{itemize}

So for the poset, the representation would be the whole structure, like this:
\begin{verbatim}
Rep := Record(set:List S,struct:List List Boolean)
\end{verbatim}

The lattice is an algebraicizing of this. The lattice constructor would take the poset
as a parameter.
)endif

)abbrev domain POSET Poset
++ Author: Martin Baker
++ Description: holds a complete set together with a structure to codify
++   the partial order.
++ Date Created: July 2015
++ Date Last Updated: July 2015
++ Basic Operations: 
++ Related packages: UserDefinedPartialOrdering in setorder.spad
++ Related categories: PartialOrder in catdef.spad
++ Related Domains: DirectedGraph in graph.spad
++ Also See:
++ AMS Classifications:
++ Keywords: poset partial order
++ Examples: power set structure
++ References:
++ Axiom: reflexivity forall(x): x<=x
++ Axiom: antisymmetry forall(x,y): x<=y and y<=x implies x=y
++ Axiom: transitivity forall(x,y,z): x<=y and y<=z implies x<=z

Poset(S) : Exports == Impl where
    S : SetCategory
    PI ==> PositiveInteger
    NNI==> NonNegativeInteger
    SINT==> SingleInteger

    Exports ==> with
     addObject : (s : %, n : S) -> %
      ++ addObject!(s, n) adds object with coordinates n to the
      ++ graph s.
     addArrow : (s : %, n1 : NNI, n2 : NNI) -> %
      ++ addArrow!(s, nm, n1, n2) adds an arrow to the graph s, where:
      ++ n1 is the index of the start object
      ++ n2 is the index of the end object
     getVertices : (s : %) -> List S
      ++ getVertices(s) returns a list of all the vertices (or objects)
      ++ of the graph s.
     getVertexIndex :  (%, S) -> NNI
      ++ getVertexIndex(s, o) gives index of object o.
     getArrows : (s : %) -> List List Boolean
      ++ getArrows(s) returns a list of all the arrows (or edges)

     powerSetStructure : (objs : S) -> %
      ++ powerSetStructure(set) is a constructor for a Poset
      ++ where each element is a set (implemented as a list)
      ++ and with a subset structure.
      ++ requires S to be a list.

     _>_=:(s : %,NNI, NNI) -> Boolean

    Impl ==> add

      import from PrimitiveArray(NNI)

      -- This holds a complete set together with a structure to codify
      -- the partial order. The elements are put in a list so they
      -- can be enumerated and linked to the structure.
      -- The structure is a two dimensional array to determine
      -- is each element is connected to each other element.
      Rep := Record(set1:List S,struct1:List List Boolean)

      getLen(mylist:PrimitiveArray NNI):NNI == #mylist

      -- adds an object to this poset
      addObject(s : %, n : S) : % ==
        dim : NNI := #(s.set1) + 1
        obs : List S := concat(s.set1,n)
        arrows : List List Boolean := []
        for a in s.struct1 repeat
          a:List Boolean := concat(a,false)
          arrows := concat(arrows,a)
        emptyRow:List Boolean := [false for x in 1..dim]
        arrows := concat(arrows,emptyRow)
        [obs,arrows]

      -- adds an arrow to this graph, where:
      -- s is the graph where the arrow is to be added
      -- n1 is the index of the start object
      -- n2 is the index of the end object
      addArrow(s : %, n1 : NNI, n2 : NNI) : % ==
        a : List Boolean := qelt(s.struct1,n1)
        setelt!(a,n2,true)
        setelt!(s.struct1,n1,a)
        [s.set1,s.struct1]

      -- returns a list of all the vertices (or objects)
      getVertices(s : %) : List S ==
        s.set1

      -- returns a list of all the arrows (or edges)
      getArrows(s : %) : List List Boolean ==
        s.struct1

      _>_=(s : %,left:NNI,right:NNI) : Boolean ==
        a : List Boolean := qelt(s.struct1,left)
        b : Boolean := qelt(a,right)
        b

      powerSetStructure(objs : S) : % ==
        -- S must be list so make this explicit
        subsets : List S := []
        [subsets, []]

        -- powerlist in haskell
        -- powerList :: [a] -> [[a]]
        -- powerList :: [] = [[]]
        -- powerList :: (x:xs) = (powerList xs) ++ (map (x:) (powerList xs))
          
        --localPowerSets(j : NNI) : List(List(PI)) ==
        --  l : List List PI := list []
        --  j = 0 => l
        --  Sm := localPowerSets((j-1)::NNI)
        --  Sn : List List PI := []
        --  for x in Sm repeat Sn := cons(cons(j pretend PI, x), Sn)
        --  append(Sn, Sm)

        --powerSets(j : NNI) : List List PI == map(reverse, localPowerSets j)

        --Pn : List List PI := powerSets(n)


)abbrev category MEETLAT MeetSemilattice
++ Description: meet semilattice
++   Implementations in set, logic and orders
++ Axiom: commutativity forall(x,y): x/\y=y/\x
++ Axiom: associativity forall(x,y,z): (x/\y)/\z=y/\(x/\z)
++ Axiom: unit forall x: x/\true()=x
++ Axiom: idempotence forall x: x/\x=x
MeetSemilattice: Category == SetCategory with
        _/_\: (%, %) -> %
	++ returns the logical 'meet', e.g. 'and'.
        true: constant -> %
	++ returns true.

)abbrev category JOINLAT JoinSemilattice
++ Description: join semilattice
++   Different from exterior Grassmann product operator as
++   that anticommutes.
++   need to check precidence when used as an infix operator
++ Axiom: commutativity forall(x,y): x\/y=y\/x
++ Axiom: associativity forall(x,y,z): (x\/y)\/z=y\/(x\/z)
++ Axiom: unit forall x: x\/false()=x
++ Axiom: idempotence forall x: x\/x=x
JoinSemilattice: Category == SetCategory with
        _\_/: (%, %) -> %
	++ returns the logical 'join', e.g. 'or'.
        false: constant -> %
	++ returns false.

)abbrev category LAT Lattice
++ Description: lattice
++ Axiom: absorptionMeetOverJoin forall(x,y): x/\(x\/y)=x
++ Axiom: absorptionJoinOverMeet forall(x,y): x\/(x/\y)=x
Lattice: Category == Join(MeetSemilattice,JoinSemilattice)

)abbrev category DISTLAT DistributiveLattice
++ Description: not every lattice is distributive so treat this
++              as a seperate case
++ Axiom: distribution1 forall(x,y,z): x/\(y\/z)=(x/\y)\/(x/\z)
++ Axiom: distribution2 forall(x,y,z): x\/(y/\z)=(x\/y)/\(x\/z)
DistributiveLattice: Category == Lattice

)abbrev category FRAME Frame
++ Description: frames are used in topology and are the lattice
++              associated with the concept of a 'locale'.
++              see: [1]
++ A Frame is a Lattice where certain subsets are also Lattices
++ Axiom: 
++ Axiom: 
++ Axiom: 
Frame: Category == Lattice

)if false
\eject
\begin{thebibliography}{99}
For more details see:
[1] Topology Via Logic - Steven Vickers ISBN 0 521 57651 2
[2] J. Lambek, P. J. Scott 1988
     Introduction to Higher-Order Categorical Logic ISBN : 0521356539
     This book shows the relationship between mathematical logic and category
     theory. Although this is not used in the current code, it suggests
     a promising generalisation.
[3] I have put a fuller explanation of this code here:
http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
\end{thebibliography}
\end{document}
)endif

