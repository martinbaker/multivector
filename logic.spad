)if false
\documentclass{article}
\usepackage{axiom}
\usepackage{url}
\begin{document}
\title{lattice related mathematical structures}
\author{Martin J Baker}
\maketitle
\begin{abstract}
In this pamphlet are partial order, lattice structures and logic operations based on
them. Logic operations based on lattice structures
Finite lattices may be based on a poset (partial order)
so see 'UserDefinedPartialOrdering' package in setorder.spad
I have put a fuller explanation of this code here:
http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
\end{abstract}

This document is just experimental, I am just trying out various things, don't
worry about the detail its the big picture that I would like help with.

I am using Steven Vickers book [ref 1] as my reference.

There are a common set of lattice-like structures that occur in various branches
of mathematics such as orders, logic and sets. I would like to represent these
structures in FriCAS.

What I have done so far seems to be applicable to finite lattices but a lot of my
interest in this subject would be infinite structures. Especially structures
from Topology such as a 'frame' which is a complete lattice with infinite meets.
I am also interested in structures from computer science such as domain theory.

My strategy so far is to have two sorts of domains:
\begin{itemize}
\item posets - here the representation is the whole structure.
\item lattices - here the representation is an element of the structure.
\end{itemize}

So for the poset, the representation would be the whole structure, like this:
\begin{verbatim}
Rep := Record(set:List S,struct:List List Boolean)
\end{verbatim}

The lattice is an algebraicizing of this. The lattice constructor would take the poset
as a parameter.
)endif

)abbrev domain POSET Poset
++ Author: Martin Baker
++ Description: holds a complete set together with a structure to codify
++   the partial order.
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Date Created: July 2015
++ Date Last Updated: July 2015
++ Basic Operations: 
++ Related packages: UserDefinedPartialOrdering in setorder.spad
++ Related categories: PartialOrder in catdef.spad
++ Related Domains: DirectedGraph in graph.spad
++ Also See:
++ AMS Classifications:
++ Keywords: poset partial order
++ Examples: power set structure
++ References:
++ Axiom: reflexivity forall(x): x<=x
++ Axiom: antisymmetry forall(x,y): x<=y and y<=x implies x=y
++ Axiom: transitivity forall(x,y,z): x<=y and y<=z implies x<=z

Poset(S) : Exports == Impl where
    S : SetCategory
    PI ==> PositiveInteger
    NNI==> NonNegativeInteger
    SINT==> SingleInteger

    Exports ==> Join(CoercibleTo(OutputForm), SetCategory) with
     poset : (set1:List S,struct1:List List Boolean) -> %
      ++ constructor where the set and structure is supplied
     addObject : (s : %, n : S) -> %
      ++ addObject!(s, n) adds object with coordinates n to the
      ++ graph s.
      ++ This is done in a non-mutable way, that is, the original
      ++ poset is not changed instead a new one is constructed.
     addArrow : (s : %, n1 : NNI, n2 : NNI) -> %
      ++ addArrow!(s, nm, n1, n2) adds an arrow to the graph s, where:
      ++ n1 is the index of the start object
      ++ n2 is the index of the end object
      ++ This is done in a non-mutable way, that is, the original
      ++ poset is not changed instead a new one is constructed.
     getVertices : (s : %) -> List S
      ++ getVertices(s) returns a list of all the vertices (or objects)
      ++ of the graph s.
     getVertexIndex :  (%, S) -> NNI
      ++ getVertexIndex(s, o) gives index of object o.
     getArrows : (s : %) -> List List Boolean
      ++ getArrows(s) returns a list of all the arrows (or edges)

     powerSetStructure : (objs : S) -> %
      ++ powerSetStructure(set) is a constructor for a Poset
      ++ where each element is a set (implemented as a list)
      ++ and with a subset structure.
      ++ requires S to be a list.

     implies:(s : %,NNI, NNI) -> Boolean
     
     meet:(s : %,a:NNI,b:NNI) -> NNI
      ++ returns the meet of 'a' and 'b'
      ++ In this version of meet nodes are represented as index values.
      ++ In the general case, not every poset will have a meet in which case
      ++ 0 will be returned as an error indication.
     
     join:(s : %,a:NNI,b:NNI) -> NNI
      ++ returns the join of 'a' and 'b'
      ++ In this version of join nodes are represented as index values.
      ++ In the general case, not every poset will have a join in which case
      ++ 0 will be returned as an error indication.

     glb:(s : %,a:List NNI) -> NNI
      ++ 'greatest lower bound' or 'infimum'
      ++ In this version of glb nodes are represented as index values.
      ++ Not every subset of a poset will have a glb in which case
      ++ 0 will be returned as an error indication.

     lub:(s : %,a:List NNI) -> NNI
      ++ 'least upper bound' or 'supremum'
      ++ In this version of lub nodes are represented as index values.
      ++ Not every subset of a poset will have a lub in which case
      ++ 0 will be returned as an error indication.

    Impl ==> add

      sayMsg ==> sayBrightly$Lisp

      -- This holds a complete set together with a structure to codify
      -- the partial order. The elements are put in a list so they
      -- can be enumerated and linked to the structure.
      -- The structure is a two dimensional array to determine
      -- is each element is connected to each other element.
      Rep := Record(set1:List S,struct1:List List Boolean)

      -- constructor where the set and structure is supplied
      poset(set1:List S,struct1:List List Boolean) : % ==
        [set1,struct1]

      -- adds an object to this poset
      addObject(s : %, n : S) : % ==
        dim : NNI := #(s.set1) + 1
        obs : List S := concat(s.set1,n)
        arrows : List List Boolean := []
        for a in s.struct1 repeat
          a:List Boolean := concat(a,false)
          arrows := concat(arrows,a)
        emptyRow:List Boolean := [false for x in 1..dim]
        arrows := concat(arrows,emptyRow)
        [obs,arrows]

      -- adds an arrow to this graph, where:
      -- s is the graph where the arrow is to be added
      -- n1 is the index of the start object
      -- n2 is the index of the end object
      addArrow(s : %, n1 : NNI, n2 : NNI) : % ==
        a : List Boolean := qelt(s.struct1,n1)
        setelt!(a,n2,true)
        setelt!(s.struct1,n1,a)
        [s.set1,s.struct1]

      -- returns a list of all the vertices (or objects)
      getVertices(s : %) : List S ==
        s.set1

      -- returns a list of all the arrows (or edges)
      getArrows(s : %) : List List Boolean ==
        s.struct1

      implies(s : %,left:NNI,right:NNI) : Boolean ==
        a : List Boolean := qelt(s.struct1,left)
        b : Boolean := qelt(a,right)
        b

      -- local function to display a list
      listToString(a:List NNI):String ==
        res :String := "["
        for x in a repeat
          res := concat(res,string(x))
          res := concat(res,",")
        concat(res,"]")

      -- returns the meet of 'a' and 'b'
      -- In this version of meet nodes are represented as index values.
      -- In the general case, not every poset will have a meet in which case
      -- 0 will be returned as an error indication.
      meet(s : %,a:NNI,b:NNI): NNI ==
        res : List NNI := []
        flaga : List Boolean := qelt(s.struct1,a)
        candidatesa: List NNI := []
        index:NNI := 1
        for x in flaga repeat
          if x then candidatesa:= concat(candidatesa,index)
          index := index +1
        flagb : List Boolean := qelt(s.struct1,b)
        candidatesb: List NNI := []
        index := 1
        for x in flagb repeat
          if x then candidatesb:= concat(candidatesb,index)
          index := index +1
        res := setIntersection(candidatesa,candidatesb)
        glb(s,res)

      -- returns the join of 'a' and 'b'
      -- In this version of join nodes are represented as index values.
      -- In the general case, not every poset will have a join in which case
      -- 0 will be returned as an error indication.
      join(s : %,a:NNI,b:NNI): NNI ==
        res : List NNI := []
        flaga : List Boolean := []
        flagb : List Boolean := []
        for x in s.struct1 repeat
          flaga := concat(flaga,qelt(x,a)$List(Boolean))$List(Boolean)
        candidatesa: List NNI := []
        index:NNI := 1
        for x in flaga repeat
          if x then candidatesa:= concat(candidatesa,index)
          index := index +1
        for x in s.struct1 repeat
          flagb := concat(flagb,qelt(x,b)$List(Boolean))$List(Boolean)
        candidatesb: List NNI := []
        index := 1
        for x in flagb repeat
          if x then candidatesb:= concat(candidatesb,index)
          index := index +1
        res := setIntersection(candidatesa,candidatesb)
        --sayMsg concat("join candidatesa=",listToString(candidatesa))$String
        --sayMsg concat("join candidatesb=",listToString(candidatesb))$String
        --sayMsg concat("join res=",listToString(res))$String
        lub(s,res)

      -- 'greatest lower bound' or 'infimum'
      -- In this version of glb nodes are represented as index values.
      -- Not every subset of a poset will have a glb in which case
      -- 0 will be returned as an error indication.
      glb(s : %,a:List NNI):NNI ==
        if empty?(a) then return 0::NNI
        if #a=1 then return first(a)
        resultList:List(NNI) := copy(a)
        --sayMsg concat("lub res=",listToString(resultList))$String
        for x in a repeat
          --sayMsg concat("glb x=",string(x))$String
          for y in a repeat
            --sayMsg concat("glb y=",string(y))$String
            if implies(s,x,y) then
              if x ~= y then
                if entry?(x,resultList) then
                  --sayMsg concat("glb removing:",string(y))$String
                  resultList := remove(y,resultList)
                  --sayMsg concat("glb res=",listToString(resultList))$String
        if #resultList ~= 1 then return 0::NNI
        first(resultList)

      -- 'least upper bound' or 'supremum'
      -- In this version of lub nodes are represented as index values.
      -- Not every subset of a poset will have a lub in which case
      -- 0 will be returned as an error indication.
      lub(s : %,a:List NNI):NNI ==
        if empty?(a) then return 0::NNI
        if #a=1 then return first(a)
        resultList:List(NNI) := copy(a)
        for x in a repeat
          sayMsg concat("lub x=",string(x))$String
          for y in a repeat
            sayMsg concat("lub y=",string(y))$String
            if implies(s,x,y) then
              if x ~= y then
                if entry?(y,resultList) then
                  sayMsg concat("lub removing:",string(x))$String
                  resultList := remove(x,resultList)
                  sayMsg concat("lub res=",listToString(resultList))$String
        if  #resultList ~= 1 then return 0::NNI
        first(resultList)

      powerSetStructure(objs : S) : % ==
        -- S must be list so make this explicit
        subsets : List S := []
        [subsets, []]

        -- powerlist in haskell
        -- powerList :: [a] -> [[a]]
        -- powerList :: [] = [[]]
        -- powerList :: (x:xs) = (powerList xs) ++ (map (x:) (powerList xs))
          
        --localPowerSets(j : NNI) : List(List(PI)) ==
        --  l : List List PI := list []
        --  j = 0 => l
        --  Sm := localPowerSets((j-1)::NNI)
        --  Sn : List List PI := []
        --  for x in Sm repeat Sn := cons(cons(j pretend PI, x), Sn)
        --  append(Sn, Sm)

        --powerSets(j : NNI) : List List PI == map(reverse, localPowerSets j)

        --Pn : List List PI := powerSets(n)

      -- start of SetCategory definitions --

      hash(s : %) : SingleInteger == 0$SingleInteger

      -- return string representation
      -- I'm not sure how latex(s: %) is intended to be used but
      -- there is nothing specifically latex here, it just returns a
      -- string description of the graph.
      latex(n : %) : String ==
        -- s holds result that we are constructing
        s:String := ""
        s

      -- returns true if x equals y
      -- this is equality and not isomorphism
      -- that is it returns true only if exact index values and names are used
      -- in addition to the structure(arrows) being the same.
      _=(x : %, y : %) : Boolean ==
        if getVertices(x) ~= getVertices(y) then return false
        if getArrows(x) ~= getArrows(y) then return false
        true

      -- returns true if x is not equal to y
      _~_=(x : %, y : %) : Boolean == not(x = y)

      -- output
      coerce(s : %) : OutputForm ==
        mat:List List OutputForm := empty()$List(List(OutputForm))
        for a in s.struct1 repeat
          row:List OutputForm := empty()$List(OutputForm)
          for b in a repeat
            c:Symbol := if b then "true"::Symbol else "false"::Symbol
            row := concat(row,outputForm(c)$OutputForm)$List(OutputForm)
          mat := concat(mat,row)
        matrix(mat)

)abbrev category MEETLAT MeetSemilattice
++ Description: meet semilattice
++   Implementations in set, logic and orders
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: commutativity forall(x,y): x/\y=y/\x
++ Axiom: associativity forall(x,y,z): (x/\y)/\z=y/\(x/\z)
++ Axiom: unit forall x: x/\true()=x
++ Axiom: idempotence forall x: x/\x=x
MeetSemilattice: Category == SetCategory with
        _/_\: (%, %) -> %
	++ returns the logical 'meet', e.g. 'and'.
        true: constant -> %
	++ returns true.

)abbrev category JOINLAT JoinSemilattice
++ Description: join semilattice
++   Different from exterior Grassmann product operator as
++   that anticommutes.
++   need to check precidence when used as an infix operator
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: commutativity forall(x,y): x\/y=y\/x
++ Axiom: associativity forall(x,y,z): (x\/y)\/z=y\/(x\/z)
++ Axiom: unit forall x: x\/false()=x
++ Axiom: idempotence forall x: x\/x=x
JoinSemilattice: Category == SetCategory with
        _\_/: (%, %) -> %
	++ returns the logical 'join', e.g. 'or'.
        false: constant -> %
	++ returns false.

)abbrev category LAT Lattice
++ Description: lattice
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: absorptionMeetOverJoin forall(x,y): x/\(x\/y)=x
++ Axiom: absorptionJoinOverMeet forall(x,y): x\/(x/\y)=x
Lattice: Category == Join(MeetSemilattice,JoinSemilattice)

)abbrev category DISTLAT DistributiveLattice
++ Description: not every lattice is distributive so treat this
++              as a seperate case
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: distribution1 forall(x,y,z): x/\(y\/z)=(x/\y)\/(x/\z)
++ Axiom: distribution2 forall(x,y,z): x\/(y/\z)=(x\/y)/\(x\/z)
DistributiveLattice: Category == Lattice

)abbrev category FRAME Frame
++ Description: frames are used in topology and are the lattice
++              associated with the concept of a 'locale'.
++              see: [1]
++   A Frame is a Lattice where certain subsets are also Lattices
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: 
++ Axiom: 
++ Axiom: 
Frame(P:Poset(SetCategory)): Category == Lattice

)abbrev domain FINLAT FiniteLattice
++ Author: Martin Baker
++ Description: This is the algebration of poset. A big difference between
++    this lattice domain and the poset domain is that, in this domain, the
++    REP holds a single node wheras in poset REP holds the whole poset.
FiniteLattice(S:SetCategory,p:Poset(S)) : Exports == Impl where
    NNI==> NonNegativeInteger
    Exports ==> Join(Lattice,CoercibleTo(OutputForm), SetCategory) with
     finiteLattice : (index:NNI) -> %
      ++ constructor

    Impl ==> add

      -- 
      Rep := NNI

      -- constructor where the set and structure is supplied
      finiteLattice(index:NNI) : % ==
        index

      -- returns the logical 'meet', e.g. 'and'.
      _/_\(a:%,b:%) : % ==
        meet(p,a pretend NNI,b pretend NNI)$Poset(S)

      -- returns the logical 'join', e.g. 'or'.
      _\_/(a:%,b:%) : % ==
        join(p,a pretend NNI,b pretend NNI)$Poset(S)

      -- start of SetCategory definitions --

      hash(s : %) : SingleInteger == 0$SingleInteger

      -- return string representation
      -- I'm not sure how latex(s: %) is intended to be used but
      -- there is nothing specifically latex here, it just returns a
      -- string description of the graph.
      latex(n : %) : String ==
        -- s holds result that we are constructing
        s:String := ""
        s

      -- returns true if x equals y
      -- this is equality and not isomorphism
      -- that is it returns true only if exact index values and names are used
      -- in addition to the structure(arrows) being the same.
      _=(x : %, y : %) : Boolean ==
        (x pretend NNI)=(y pretend NNI)

      -- returns true if x is not equal to y
      _~_=(x : %, y : %) : Boolean == not(x = y)

      -- output
      coerce(s : %) : OutputForm ==
        outputForm(s pretend Integer)

)if false
\eject
\begin{thebibliography}{99}
For more details see:
[1] Topology Via Logic - Steven Vickers ISBN 0 521 57651 2
[2] J. Lambek, P. J. Scott 1988
     Introduction to Higher-Order Categorical Logic ISBN : 0521356539
     This book shows the relationship between mathematical logic and category
     theory. Although this is not used in the current code, it suggests
     a promising generalisation.
[3] I have put a fuller explanation of this code here:
http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
\end{thebibliography}
\end{document}
)endif

