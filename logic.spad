)if false
\documentclass{article}
\usepackage{axiom}
\usepackage{url}
\begin{document}
\title{lattice related mathematical structures}
\author{Martin J Baker}
\maketitle
\begin{abstract}
In this pamphlet are partial order, lattice structures and logic operations based on
them. Logic operations based on lattice structures
Finite lattices may be based on a poset (partial order)
so see 'UserDefinedPartialOrdering' package in setorder.spad
I have put a fuller explanation of this code here:
http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
\end{abstract}

This document is just experimental, I am just trying out various things, don't
worry about the detail its the big picture that I would like help with.

I am using Steven Vickers book [ref 1] as my reference.

There are a common set of lattice-like structures that occur in various branches
of mathematics such as orders, logic and sets. I would like to represent these
structures in FriCAS.

What I have done so far seems to be applicable to finite lattices but a lot of my
interest in this subject would be infinite structures. Especially structures
from Topology such as a 'frame' which is a complete lattice with infinite meets.
I am also interested in structures from computer science such as domain theory.

My strategy so far is to have two sorts of domains:
\begin{itemize}
\item posets - here the representation is the whole structure.
\item lattices - here the representation is an element of the structure.
\end{itemize}

So for the poset, the representation would be the whole structure, like this:
\begin{verbatim}
Rep := Record(set:List S,struct:List List Boolean)
\end{verbatim}

The lattice is an algebraicizing of this. The lattice constructor would take the poset
as a parameter.
)endif

)abbrev category PREORD Preorder
++ Description: implies operation with reflexivity and transitivity
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: reflexivity forall(x): x<=x
++ Axiom: transitivity forall(x,y,z): x<=y and y<=z implies x<=z
NNI==> NonNegativeInteger
Preorder: Category == SetCategory with
    implies:(s : %,NNI, NNI) -> Boolean


)abbrev domain POSET Poset
++ Author: Martin Baker
++ Description: holds a complete set together with a structure to codify
++   the partial order.
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Date Created: Aug 2015
++ Date Last Updated: Aug 2015
++ Basic Operations: 
++ Related packages: UserDefinedPartialOrdering in setorder.spad
++ Related categories: PartialOrder in catdef.spad
++ Related Domains: DirectedGraph in graph.spad
++ Also See:
++ AMS Classifications:
++ Keywords: poset partial order
++ Examples: power set structure
++ References:
++ Axiom: reflexivity forall(x): x<=x
++ Axiom: antisymmetry forall(x,y): x<=y and y<=x iff x=y
++ Axiom: transitivity forall(x,y,z): x<=y and y<=z implies x<=z

Poset(S) : Exports == Impl where
    S : SetCategory
    PI ==> PositiveInteger
    NNI==> NonNegativeInteger
    SINT==> SingleInteger
    OBJT ==> Record(value : S, posX : NNI, posY : NNI)
    ARROW ==> Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)

    Exports ==> FiniteGraph(S) with
     poset : (set1:List S,struct1:List List Boolean) -> %
      ++ constructor where the set and structure is supplied
     addObject : (s : %, n : S) -> %
      ++ addObject!(s, n) adds object with coordinates n to the
      ++ graph s.
      ++ This is done in a non-mutable way, that is, the original
      ++ poset is not changed instead a new one is constructed.
     addArrow : (s : %, n1 : NNI, n2 : NNI) -> %
      ++ addArrow!(s, nm, n1, n2) adds an arrow to the graph s, where:
      ++ n1 is the index of the start object
      ++ n2 is the index of the end object
      ++ This is done in a non-mutable way, that is, the original
      ++ poset is not changed instead a new one is constructed.
     getVertices : (s : %) -> List S
      ++ getVertices(s) returns a list of all the vertices (or objects)
      ++ of the graph s.
     getArrows : (s : %) -> List List Boolean
      ++ getArrows(s) returns a list of all the arrows (or edges)

     opposite : (s : %) -> %
      ++ constucts the opposite in the category theory sense of reversing
      ++ all the arrows

     powerSetStructure : (objs : S) -> %
      ++ powerSetStructure(set) is a constructor for a Poset
      ++ where each element is a set (implemented as a list)
      ++ and with a subset structure.
      ++ requires S to be a list.

     implies:(s : %,NNI, NNI) -> Boolean
     
     meet:(s : %,a:NNI,b:NNI) -> NNI
      ++ returns the meet of 'a' and 'b'
      ++ In this version of meet nodes are represented as index values.
      ++ In the general case, not every poset will have a meet in which case
      ++ 0 will be returned as an error indication.
     
     join:(s : %,a:NNI,b:NNI) -> NNI
      ++ returns the join of 'a' and 'b'
      ++ In this version of join nodes are represented as index values.
      ++ In the general case, not every poset will have a join in which case
      ++ 0 will be returned as an error indication.

     meet:(s : %,elements:List(NNI)) -> NNI
      ++ returns the meet of a subset of lattice given by list of elements

     join:(s : %,elements:List(NNI)) -> NNI
      ++ returns the join of a subset of lattice given by list of elements

     glb:(s : %,a:List NNI) -> NNI
      ++ 'greatest lower bound' or 'infimum'
      ++ In this version of glb nodes are represented as index values.
      ++ Not every subset of a poset will have a glb in which case
      ++ 0 will be returned as an error indication.

     lub:(s : %,a:List NNI) -> NNI
      ++ 'least upper bound' or 'supremum'
      ++ In this version of lub nodes are represented as index values.
      ++ Not every subset of a poset will have a lub in which case
      ++ 0 will be returned as an error indication.

     indexToObject:(s : %,index:NNI) -> S
      ++ returns the object at a given index

     objectToIndex:(s : %,obj:S) -> NNI
      ++ returns the index of a given object

     completeReflexivity:(s:%) -> %
      ++ Reflexivity requires forall(x): x<=x
      ++ This function inforces this by making sure that every element has
      ++ arrow to itself. That is, the leading diagonal is true.

     completeTransitivity:(s:%) -> %
      ++ Transitivity requires forall(x,y,z): x<=y and y<=z implies x<=z
      ++ This function inforces this by making sure that the composition
      ++ of any two arrows is also an arrow.

     isAntisymmetric?:(s:%) -> Boolean
      ++ Antisymmetric requires forall(x,y): x<=y and y<=x iff x=y
      ++ Returns true if this is the case for every element.

    Impl ==> add

      sayMsg ==> sayBrightly$Lisp

      -- This holds a complete set together with a structure to codify
      -- the partial order. The elements are put in a list so they
      -- can be enumerated and linked to the structure.
      -- The structure is a two dimensional array to determine
      -- is each element is connected to each other element.
      Rep := Record(set1:List S,struct1:List List Boolean)

      -- constructor where the set and structure is supplied
      poset(set1:List S,struct1:List List Boolean) : % ==
        [set1,struct1]

      -- local function to set a single value in the arrow matrix
      setArrow!(arr:List(List(Boolean)),a:NNI,b:NNI,c:Boolean):Void ==
        row:NNI := 1
        for x in arr repeat
          if row=a then
            setelt!(x,b,c)
            return void
          row=row+1
        void

      -- local function to test a single value in the arrow matrix
      isArrow?(arr:List(List(Boolean)),a:NNI,b:NNI):Boolean ==
        row:NNI := 1
        for x in arr repeat
          if row=a then
            val:Boolean := qelt(x,b)
            return val
          row=row+1
        false

      -- adds an object to this poset
      addObject(s : %, n : S) : % ==
        dim : NNI := #(s.set1) + 1
        obs : List S := concat(s.set1,n)
        arrows : List(List(Boolean)) := nil()$List(List(Boolean))
        for a in s.struct1 repeat
          width:NNI := #a
          padding:Union(NNI,"failed") := subtractIfCan(dim,width)
          if padding ~= "failed" then
            diff:NNI := padding::NNI
            --sayMsg concat("addObject diff=",string(diff))$String
            for x in 1..diff repeat
              a := concat(a,false)
          if empty?(arrows)
            then arrows := [a]
            else arrows := concat(arrows,a)
        emptyRow:List Boolean := [false for x in 1..dim]
        arrows := concat(arrows,emptyRow)
        [obs,arrows]

      -- FIXME - make this non-mutable
      -- adds an arrow to this graph, where:
      -- s is the graph where the arrow is to be added
      -- n1 is the index of the start object
      -- n2 is the index of the end object
      addArrow(s : %, n1 : NNI, n2 : NNI) : % ==
        a : List Boolean := qelt(s.struct1,n1)
        setelt!(a,n2,true)
        setelt!(s.struct1,n1,a)
        [s.set1,s.struct1]

      -- returns a list of all the vertices (or objects)
      getVertices(s : %) : List S ==
        s.set1

      -- returns a list of all the arrows (or edges)
      getArrows(s : %) : List List Boolean ==
        s.struct1

      -- start of FiniteGraph implementation

      -- addObject!(s, n) adds object n to the graph s.
      -- mutable version of addObject.
      addObject!(s : %, n : S):% ==
        dim : NNI := #(s.set1) + 1
        obs : List S := concat(s.set1,n)
        arrows : List(List(Boolean)) := nil()$List(List(Boolean))
        for a in s.struct1 repeat
          width:NNI := #a
          padding:Union(NNI,"failed") := subtractIfCan(dim,width)
          if padding ~= "failed" then
            diff:NNI := padding::NNI
            --sayMsg concat("addObject! diff=",string(diff))$String
            for x in 1..diff repeat
              a := concat(a,false)
          if empty?(arrows)
            then arrows := [a]
            else arrows := concat(arrows,a)
        emptyRow:List Boolean := [false for x in 1..dim]
        arrows := concat(arrows,emptyRow)
        s.set1 := obs
        s.struct1 := arrows
        s

      -- addObject!(s, n) adds object with coordinates n to the
      -- graph s.
      addObject!(s : %, n : OBJT):% ==
        ob:S := n.value
        addObject!(s,ob)

      -- addArrow!(s, nm, n1, n2) adds an arrow to the graph s, where:
      -- nm is the name of the arrow
      -- n1 is the index of the start object
      -- n2 is the index of the end object
      addArrow!(s : %, name : String, n1 : NNI, n2 : NNI):% ==
        a : List Boolean := qelt(s.struct1,n1)
        setelt!(a,n2,true)
        setelt!(s.struct1,n1,a)
        [s.set1,s.struct1]

      -- addArrow!(s, nm, n1, n2, mp) adds an arrow to the graph s, where:
      -- nm is the name of the arrow
      -- n1 is the index of the start object
      -- n2 is the index of the end object
      -- mp is a map represented by this arrow
      addArrow!(s : %, name : String, n1 : NNI, n2 : NNI, mp : List NNI):% ==
        addArrow!(s,name,n1,n2)

      -- getVertices(s) returns a list of all the vertices (or objects)
      -- of the graph s.
      getVertices(s : %):List(OBJT) ==
        [[x,0::NNI,0::NNI] for x in s.set1]

      -- getArrows(s) returns a list of all the arrows (or edges)
      getArrows(s : %):List(ARROW) ==
        res:List(ARROW) := nil()
        dim:NNI := #s.struct1
        for x in 1..dim for row in s.struct1 repeat
          for y in 1..dim for val in row repeat
            if val then
              arr:ARROW := ["x", 0::NNI,x pretend NNI,y pretend NNI,0::Integer,0::Integer,nil()$List(NNI)]
              res := concat(res,arr)
        res

      -- flatten(n) takes a second order graph, we don't really need
      -- this here so return an empty poset.
      flatten(n : DirectedGraph(%)):% ==
        [[],[nil()$List(Boolean)]]
   
      -- initial constructs a graph without vertices or edges
      initial():% ==
        [[],nil()$List(List(Boolean))]

      -- terminal(a) constructs a graph over a with a single vertex
      -- and a single loop
      terminal(a : S):% ==
        [[a],[[true]]]

      -- cycleOpen(objs, arrowName) constructs a graph with vertices
      -- (from objs) connected in a cycle but with one gap. The last
      -- vertex in the sequence loops back to itself so all vertices
      -- have one outgoing arrow.
      -- arrowName is a prefix for all arrow names, this will be
      -- followed by a number starting at 1 and incremented for each
      -- arrow
      cycleOpen(objs : List S, arrowName : String):% ==
        [[],[nil()$List(Boolean)]]

      -- cycleClosed: (objs: List S, arrowName: String) constructs a graph
      -- with vertices (from objs) connected in a cycle.
      -- arrowName is a prefix for all arrow names, this will be
      -- followed by a number starting at 1 and incremented for each
      -- arrow
      cycleClosed(objs : List S, arrowName : String):% ==
        [[],[nil()$List(Boolean)]]

      -- unit(objs, arrowName) constructs a graph with vertices
      -- (from objs) and arrows from each object to itself.
      -- arrowName is a prefix for all arrow names, this will be
      -- followed by a number starting at 1 and incremented for each
      -- arrow
      unit(objs : List(S), arrowName : String):% ==
        dim:NNI := #objs
        arrs:List(List(Boolean)) := [nil()$List(Boolean)]
        for x in 1..dim repeat
          row:List Boolean := nil()
          for y in 1..dim repeat
            val:Boolean := (x=y)
            row := concat(row,val)
          arrs := concat(arrs,row)
        [objs,arrs]

      -- kgraph(objs, arrowName)
      -- constructs a graph with vertices (from objs) and fully
      -- connected arrows, that is, each object has an arrow to
      -- every other object except itself.
      -- arrowName is a prefix for all arrow names, this will be
      -- followed by a number starting at 1 and incremented for each
      -- arrow
      kgraph(objs : List S, arrowName : String):% ==
        [[],[[false]]]

      -- isDirectSuccessor?(s, a, b) is
      -- true if 'b' is a direct successor of 'a'
      -- that is, if there is a direct arrow from 'a' to 'b'
      isDirectSuccessor?(s : %, a : NNI, b : NNI):Boolean ==
        row : List Boolean := qelt(s.struct1,a)
        qelt(row,b)

      -- isGreaterThan?((s, a, b) is
      -- true if we can get from vertex 'a' to 'b' through a
      -- sequence of arrows but we can't go in the opposite
      -- direction from 'b' to 'a'
      isGreaterThan?(s : %, a : NNI, b : NNI):Boolean ==
        row : List Boolean := qelt(s.struct1,a)
        qelt(row,b)
   
      -- max(s) returns index of the vertex which can be reached
      -- from all other vertices. Gives 0 if no such node exists
      -- or if it is not unique, if there is a loop for instance.
      max(s : %) : NNI ==
        arr:List(NNI) := nil()
        index:NNI := 1::NNI
        0::NNI
        for x in s.struct1 repeat
          arr := concat(arr,index)
          index := index+1
        meet(s,arr)
   
      -- max(s, sub) returns index of the vertex which
      -- can be reached from a given subset of the vertices. Gives
      -- 0 if no such node exists or if it is not unique, if there
      -- is a loop for instance.
      max(s : %, sub : List NNI):NNI ==
        meet(s,sub)
    
      -- min(s) returns index of the vertex which can reach to all
      -- other vertices. Gives 0 if no such node exists or if it is
      -- not unique, if there is a loop for instance.
      min(s : %) : NNI ==
        arr:List(NNI) := nil()
        index:NNI := 1::NNI
        0::NNI
        for x in s.struct1 repeat
          arr := concat(arr,index)
          index := index+1
        join(s,arr)
  
      -- min(s, sub) returns index of the vertex which can reach
      -- to a given subset of the vertices. Gives 0 if no such node
      -- exists or if it is not unique, if there is a loop for instance.
      min(s : %, sub : List NNI):NNI ==
        join(s,sub)
   
      -- isFixPoint?(s, a) is
      -- true if 'a' has an arrow to itself
      -- should always be true due to reflexivity law
      isFixPoint?(s : %, a : NNI):Boolean ==
        true
   
      -- arrowName(s, a, b) retrieves
      -- the name of arrow a->b
      -- if it does not exist then return "?"
      arrowName(s : %, a : NNI, b : NNI):String ==
        "?"
   
      -- getArrowIndex(s, a, b) retrieves
      -- arrow index of the arrow form a to b
      getArrowIndex(s : %, a : NNI, b : NNI):NNI ==
        0::NNI

      -- inDegree(s, a) gives the number of arrows leading in to node
      -- 'a' in graph 's'
      inDegree(s : %, a : NNI):NNI ==
        0::NNI
   
      -- outDegree(s, a) gives
      -- the number of arrows leading out of node 'a' in graph 's'
      outDegree(s : %, a : NNI):NNI ==
        0::NNI
   
      -- nodeFromNode(s, a) gives list
      -- of all nodes with a direct arrow leading
      -- in to node 'a' in graph 's'
      nodeFromNode(s : %, a : NNI):List NNI ==
        [0::NNI]
   
      -- nodeToNode(s, a) gives list of all nodes with a direct arrow leading
      -- out of node 'a' in graph 's'
      nodeToNode(s : %, a : NNI):List NNI ==
        [0::NNI]

      -- arrowsFromNode(s, a) gives list of all arrows leading to a given node
      arrowsFromNode(s : %, a : NNI):List NNI ==
        [0::NNI]

      -- arrowsToNode(s, a) gives list of all arrows leading from a given node
      arrowsToNode(s : %, a : NNI):List NNI ==
        [0::NNI]
   
      -- nodeFromArrow(s, a) returns index of all nodes with a direct
      -- arrow leading in to arrow 'a' in graph 's'
      nodeFromArrow(s : %, a : NNI):List NNI ==
        [0::NNI]
   
      -- nodeToArrow(s, a) returns index of all nodes with a direct
      -- arrow leading out of arrow 'a' in graph 's'
      nodeToArrow(s : %, a : NNI):List NNI ==
        [0::NNI]

      -- index of all arrows leading to a given arrow
      arrowsFromArrow(s : %, a : NNI):List NNI ==
        [0::NNI]

      -- arrowsToArrow: (s: %, a: NNI) returns index of all arrows leading from
      -- a given arrow
      arrowsToArrow(s : %, a : NNI):List NNI ==
        [0::NNI]

      -- routeNodes(s, a, b) gives the shortest route between
      -- nodes 'a' and 'b' as a sequence of node indexes.
      -- [a] if  'a' = 'b'
      -- [] if it is not possible to go from 'a' to 'b'
      routeNodes(s : %, a : NNI, b : NNI):List NNI ==
        [0::NNI]

      -- routeArrows(s, a, b) gives
      -- the shortest route between nodes 'a' and 'b' as a
      -- sequence of arrow indexes.
      -- [] if  'a' = 'b'
      -- [0] if it is not possible to go from 'a' to 'b'
      routeArrows(s : %, a : NNI, b : NNI):List NNI ==
        [0::NNI]
   
      -- distance(s, a, b) gives the shortest distance between
      -- nodes 'a' and 'b' as a
      -- number of hops.
      -- 0 if  'a' = 'b',
      -- -1 if it is not possible to go from 'a' to 'b'
      distance(s : %, a : NNI, b : NNI):Integer ==
        0::Integer

      -- sum : disjoint union of nodes with arrows from appropriate
      -- input
      "+"(a:%,b:%):% ==
        a
   
      -- merge(a, b) returns sum : union (not necessarily disjoint) of
      -- nodes with arrows merged in from appropriate input, if arrow
      -- exists from both inputs then it will be duplicated.
      merge(a:%,b:%):% ==
        a

      -- isDirected? is true iff % is domain consisting of directed
      -- graphs, false for undirected graphs.
      isDirected?():Boolean ==
        true

      -- createWidth(x) can be used by domains which extend graph
      -- to help in creating coordinates for objects in a graph
      createWidth(x : NNI):NNI ==
        0::NNI

      -- createX(x, n) can be used by domains which extend graph to
      -- help in creating the x coordinate for objects in a graph
      createX(x : NNI, n : NNI):NNI ==
        0::NNI

      -- createY(x, n) can be used by domains which extend graph to
      -- help in creating the y coordinate for objects in a graph
      createY(x : NNI, n : NNI):NNI ==
        0::NNI

      -- looseEquals(x, y) is true if x 'equals' y
      -- this is a looser version of equality test but is not as
      -- general as isomorphism.
      -- it only requires the same number of vertices but does not
      -- require the objects themselves being equal.
      -- the arrows must be the same, that is it may return false
      -- if the order of vertices is changed so this is not
      -- isomorphism test.
      -- I would like to enhance this code into a true isomorphism test
      looseEquals(x : %, y : %):Boolean ==
        false

      -- map(s, m, newOb, offsetX, offsetY) creates a new graph by
      -- mapping from this one
      -- newOb should contain the new list of vertices.
      -- m should contain a NNI value for each vertex, this is the
      -- new index into newOb. It is allowed that newOb may contain
      -- less objects than s (for surjective mapping) or
      -- more objects than s (for injective mapping)
      map(s : %, m : List NNI, newOb : List S, offsetX : Integer, offsetY : Integer):% ==
        s

      -- mapContra(s, m, newOb, offsetX, offsetY) is similar to map
      -- function but reverses the directions of the arrows
      mapContra(s : %, m : List NNI, newOb : List S, offsetX : Integer, offsetY : Integer):% ==
        s

      -- end of FiniteGraph implementation

      -- constucts the opposite in the category theory sense of reversing
      -- all the arrows
      opposite(s : %) : % ==
        arr2 : List List Boolean := [nil]
        for x in s.struct1 repeat
          row: List Boolean := []
          for y in x repeat
            row := concat(row,false)
          arr2:=concat(arr2,row)
        for a in 1..#(s.struct1) repeat
          for b in 1..#(s.struct1) repeat
            if isArrow?(s.struct1,a,b) then setArrow!(arr2,b,a,true)
        [s.set1,arr2]

      implies(s : %,left:NNI,right:NNI) : Boolean ==
        a : List Boolean := qelt(s.struct1,left)
        b : Boolean := qelt(a,right)
        b

      -- local function to display a list
      listToString(a:List NNI):String ==
        res :String := "["
        for x in a repeat
          res := concat(res,string(x))
          res := concat(res,",")
        concat(res,"]")

      -- returns the join of 'a' and 'b'
      -- In this version of join nodes are represented as index values.
      -- In the general case, not every poset will have a join in which case
      -- 0 will be returned as an error indication.
      join(s : %,a:NNI,b:NNI): NNI ==
        res : List NNI := []
        -- flag for each element is true if >= from 'a'
        flaga : List Boolean := qelt(s.struct1,a)
        -- list of all element indexes which are >= from 'a'
        candidatesa: List NNI := []
        index:NNI := 1
        for x in flaga repeat
          if x then candidatesa:= concat(candidatesa,index)
          index := index +1
        -- flag for each element is true if >= from 'b'
        flagb : List Boolean := qelt(s.struct1,b)
        -- list of all element indexes which are >= from 'a'
        candidatesb: List NNI := []
        index := 1
        for x in flagb repeat
          if x then candidatesb:= concat(candidatesb,index)
          index := index +1
        res := setIntersection(candidatesa,candidatesb)
        glb(s,res)

     -- returns the meet of 'a' and 'b'
      -- In this version of meet nodes are represented as index values.
      -- In the general case, not every poset will have a meet in which case
      -- 0 will be returned as an error indication.
      meet(s : %,a:NNI,b:NNI): NNI ==
        res : List NNI := []
        -- flag for each element is true if >= to 'a'
        flaga : List Boolean := []
        -- flag for each element is true if >= to 'b'
        flagb : List Boolean := []
        for x in s.struct1 repeat
          flaga := concat(flaga,qelt(x,a)$List(Boolean))$List(Boolean)
        -- list of all element indexes which are >= than 'a'
        candidatesa: List NNI := []
        index:NNI := 1
        for x in flaga repeat
          if x then candidatesa:= concat(candidatesa,index)
          index := index +1
        for x in s.struct1 repeat
          flagb := concat(flagb,qelt(x,b)$List(Boolean))$List(Boolean)
        -- list of all element indexes which are >= than 'b'
        candidatesb: List NNI := []
        index := 1
        for x in flagb repeat
          if x then candidatesb:= concat(candidatesb,index)
          index := index +1
        res := setIntersection(candidatesa,candidatesb)
        --sayMsg concat("join candidatesa=",listToString(candidatesa))$String
        --sayMsg concat("join candidatesb=",listToString(candidatesb))$String
        --sayMsg concat("join res=",listToString(res))$String
        lub(s,res)

      -- returns the meet of a subset of lattice given by list of elements
      meet(s : %,elements:List(NNI)):NNI ==
        res : List NNI := []
        for e in elements repeat
          -- flag for each element is true if >= to 'e'
          flage : List Boolean := []
          for x in s.struct1 repeat
            flage := concat(flage,qelt(x,e)$List(Boolean))$List(Boolean)
          -- list of all element indexes which are >= than 'e'
          candidates: List NNI := []
          index:NNI := 1
          for x in flage repeat
            if x then candidates:= concat(candidates,index)
            index := index +1
        res := setIntersection(res,candidates)
        --sayMsg concat("join candidates=",listToString(candidates))$String
        --sayMsg concat("join res=",listToString(res))$String
        lub(s,res)

      -- returns the join of a subset of lattice given by list of elements
      join(s : %,elements:List(NNI)):NNI ==
        res : List NNI := []
        for e in elements repeat
          -- flag for each element is true if >= from 'e'
          flage : List Boolean := qelt(s.struct1,e)
          -- list of all element indexes which are >= from 'e'
          candidates: List NNI := []
          index:NNI := 1
          for x in flage repeat
            if x then candidates:= concat(candidates,index)
            index := index +1
          res := setIntersection(res,candidates)
        glb(s,res)

      -- 'greatest lower bound' or 'infimum'
      -- In this version of glb nodes are represented as index values.
      -- Not every subset of a poset will have a glb in which case
      -- 0 will be returned as an error indication.
      glb(s : %,a:List NNI):NNI ==
        if empty?(a) then return 0::NNI
        if #a=1 then return first(a)
        resultList:List(NNI) := copy(a)
        --sayMsg concat("lub res=",listToString(resultList))$String
        for x in a repeat
          --sayMsg concat("glb x=",string(x))$String
          for y in a repeat
            --sayMsg concat("glb y=",string(y))$String
            if implies(s,x,y) then
              if x ~= y then
                if entry?(x,resultList) then
                  --sayMsg concat("glb removing:",string(y))$String
                  resultList := remove(y,resultList)
                  --sayMsg concat("glb res=",listToString(resultList))$String
        if #resultList ~= 1 then return 0::NNI
        first(resultList)

      -- 'least upper bound' or 'supremum'
      -- In this version of lub nodes are represented as index values.
      -- Not every subset of a poset will have a lub in which case
      -- 0 will be returned as an error indication.
      lub(s : %,a:List NNI):NNI ==
        if empty?(a) then return 0::NNI
        if #a=1 then return first(a)
        resultList:List(NNI) := copy(a)
        for x in a repeat
          --sayMsg concat("lub x=",string(x))$String
          for y in a repeat
            --sayMsg concat("lub y=",string(y))$String
            if implies(s,x,y) then
              if x ~= y then
                if entry?(y,resultList) then
                  --sayMsg concat("lub removing:",string(x))$String
                  resultList := remove(x,resultList)
                  --sayMsg concat("lub res=",listToString(resultList))$String
        if  #resultList ~= 1 then return 0::NNI
        first(resultList)

      -- returns the object at a given index
      indexToObject(s : %,index:NNI):S ==
        --sayMsg concat("indexToObject",string(index))$String
        qelt(s.set1,index)

      -- returns the index of a given object
      objectToIndex(s : %,obj:S):NNI ==
        position(obj,s.set1)$List(S) pretend NNI

      -- Reflexivity requires forall(x): x<=x
      -- This function inforces this by making sure that every element has
      -- arrow to itself. That is, the leading diagonal is true.
      completeReflexivity(s:%):% ==
        set2:List S := s.set1
        struct2:List(List(Boolean)) := copy(s.struct1)
        for a in 1..(#set2) repeat
          setArrow!(struct2,a,a,true)
        [set2,struct2]

      -- Transitivity requires forall(x,y,z): x<=y and y<=z implies x<=z
      -- This function inforces this by making sure that the composition
      -- of any two arrows is also an arrow.
      completeTransitivity(s:%):% ==
        set2:List S := s.set1
        dim:NNI := #set2
        struct2:List(List(Boolean)) := copy(s.struct1)
        for a in 1..dim repeat
          for b in 1..dim repeat
            for c in 1..dim repeat
              if isArrow?(struct2,a,b) and isArrow?(struct2,b,c) then
                if not isArrow?(struct2,a,c) then
                  setArrow!(struct2,a,c,true)
        [set2,struct2]

      -- Antisymmetric requires forall(x,y): x<=y and y<=x iff x=y
      -- Returns true if this is the case for every element.
      isAntisymmetric?(s:%):Boolean ==
        dim:NNI := #(s.set1)
        struct2:List(List(Boolean)) := copy(s.struct1)
        for a in 1..dim repeat
          for b in 1..dim repeat
            if isArrow?(struct2,a,b) and isArrow?(struct2,b,a) then
              if a ~= b then return false
        true

      -- start of SetCategory definitions --

      hash(s : %) : SingleInteger == 0$SingleInteger

      -- return string representation
      -- I'm not sure how latex(s: %) is intended to be used but
      -- there is nothing specifically latex here, it just returns a
      -- string description of the graph.
      latex(n : %) : String ==
        -- s holds result that we are constructing
        s:String := ""
        s

      -- returns true if x equals y
      -- this is equality and not isomorphism
      -- that is it returns true only if exact index values and names are used
      -- in addition to the structure(arrows) being the same.
      _=(x : %, y : %) : Boolean ==
        if getVertices(x) ~= getVertices(y) then return false
        if getArrows(x) ~= getArrows(y) then return false
        true

      -- returns true if x is not equal to y
      _~_=(x : %, y : %) : Boolean == not(x = y)

      -- output
      coerce(s : %) : OutputForm ==
        dim:NNI := #(s.set1)
        if empty?(s.struct1) then return bracket(empty()$OutputForm)
        mat:List List OutputForm := empty()$List(List(OutputForm))
        for a in s.struct1 repeat
          row:List OutputForm := empty()$List(OutputForm)
          if empty?(a)
            then
              row := concat(row,bracket(empty()$OutputForm))$List(OutputForm)
            else
              for b in a repeat
                c:Symbol := if b then "true"::Symbol else "false"::Symbol
                row := concat(row,outputForm(c)$OutputForm)$List(OutputForm)
          if #row ~= dim then return outputForm("wrong number of cols")
          mat := concat(mat,row)
        if #mat ~= dim then return outputForm("wrong number of rows")
        matrix(mat)

)abbrev category MEETLAT MeetSemilattice
++ Author: Martin Baker
++ Date Created: Aug 2015
++ Date Last Updated: Aug 2015
++ Basic Operations: Meet
++ Related Constructors: BoundedMeetSemilattice
++  use BoundedMeetSemilattice if the semilattice has a 'top' which will be
++  the case for all finite meet semilattices since we can do a meet of all values
++ Keywords: Meet
++ Description: meet semilattice
++   Implementations in set, logic and orders
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: commutativity forall(x,y): x/\y=y/\x
++ Axiom: associativity forall(x,y,z): (x/\y)/\z=y/\(x/\z)
++ Axiom: idempotence forall x: x/\x=x
MeetSemilattice: Category == SetCategory with
      _/_\: (%, %) -> %
        ++ returns the logical 'meet', e.g. 'and'.

)abbrev category BMEET BoundedMeetSemilattice
++ Author: Martin Baker
++ Date Created: Aug 2015
++ Date Last Updated: Aug 2015
++ Basic Operations: Meet
++ Related Constructors: MeetSemilattice
++  use BoundedMeetSemilattice if the semilattice has a 'top' which will be
++  the case for all finite meet semilattice since we can do a meet of all values
++ Keywords: Meet Top
++ Description: meet semilattice with top
++   Implementations in set, logic and orders
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: unit forall x: x/\ T=x
BoundedMeetSemilattice: Category == MeetSemilattice with
      T: constant -> %
        ++ Top (true in logic).

)abbrev category JOINLAT JoinSemilattice
++ Author: Martin Baker
++ Date Created: Aug 2015
++ Date Last Updated: Aug 2015
++ Basic Operations: Join
++ Related Constructors: BoundedJoinSemilattice
++  use BoundedJoinSemilattice if the semilattice has a 'bottom' which will be
++  the case for all finite join semilattices since we can do a join of all values
++ Keywords: Join
++ Description: join semilattice
++   Different from exterior Grassmann product operator as
++   that anticommutes.
++   need to check precidence when used as an infix operator
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: commutativity forall(x,y): x\/y=y\/x
++ Axiom: associativity forall(x,y,z): (x\/y)\/z=y\/(x\/z)
++ Axiom: idempotence forall x: x\/x=x
JoinSemilattice: Category == SetCategory with
      _\_/: (%, %) -> %
        ++ returns the logical 'join', e.g. 'or'.

)abbrev category BJOIN BoundedJoinSemilattice
++ Author: Martin Baker
++ Date Created: Aug 2015
++ Date Last Updated: Aug 2015
++ Basic Operations: Join
++ Related Constructors: JoinSemilattice
++  use BoundedJoinSemilattice if the semilattice has a 'bottom' which will be
++  the case for all finite join semilattices since we can do a join of all values
++ Keywords: Join Bottom
++ Description: join semilattice with bottom
++   Different from exterior Grassmann product operator as
++   that anticommutes.
++   need to check precidence when used as an infix operator
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: unit forall x: x \/ _|_=x
BoundedJoinSemilattice: Category == JoinSemilattice with
      "__|__": constant -> %
        ++ bottom (false in logic).

)abbrev category LAT Lattice
++ Author: Martin Baker
++ Date Created: Aug 2015
++ Date Last Updated: Aug 2015
++ Basic Operations: Meet Join
++ Related Constructors: BoundedLattice
++  use BoundedLattice if the lattice has a top and 'bottom' which will be
++  the case for all finite lattices since we can do a meet and join of all values
++ Keywords: Meet Top Join Bottom
++ Description: lattice
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: absorptionMeetOverJoin forall(x,y): x/\(x\/y)=x
++ Axiom: absorptionJoinOverMeet forall(x,y): x\/(x/\y)=x
Lattice: Category == Join(MeetSemilattice,JoinSemilattice)

)abbrev category BLAT BoundedLattice
++ Author: Martin Baker
++ Date Created: Aug 2015
++ Date Last Updated: Aug 2015
++ Basic Operations: Meet Join
++ Related Constructors: Lattice
++  use BoundedLattice if the lattice has a top and 'bottom' which will be
++  the case for all finite lattices since we can do a meet and join of all values
++ Keywords: Meet Top Join Bottom
++ Description: lattice with top and bottom
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: absorptionMeetOverJoin forall(x,y): x/\(x\/y)=x
++ Axiom: absorptionJoinOverMeet forall(x,y): x\/(x/\y)=x
BoundedLattice: Category == Join(BoundedMeetSemilattice,BoundedJoinSemilattice)

)abbrev category DISTLAT DistributiveLattice
++ Author: Martin Baker
++ Date Created: Aug 2015
++ Date Last Updated: Aug 2015
++ Basic Operations: Meet Join
++ Related Constructors: BoundedDistributiveLattice
++  use BoundedDistributiveLattice if the lattice has a top and 'bottom' which will be
++  the case for all finite lattices since we can do a meet and join of all values
++ Keywords: Meet Top Join Bottom
++ Description: not every lattice is distributive so treat this
++              as a seperate case
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: distribution1 forall(x,y,z): x/\(y\/z)=(x/\y)\/(x/\z)
++ Axiom: distribution2 forall(x,y,z): x\/(y/\z)=(x\/y)/\(x\/z)
DistributiveLattice: Category == Lattice

)abbrev category BDISTL BoundedDistributiveLattice
++ Author: Martin Baker
++ Date Created: Aug 2015
++ Date Last Updated: Aug 2015
++ Basic Operations: Meet Join
++ Related Constructors: DistributiveLattice
++  use BoundedDistributiveLattice if the lattice has a top and 'bottom' which will be
++  the case for all finite lattices since we can do a meet and join of all values
++ Keywords: Meet Top Join Bottom
++ Description: not every lattice is distributive so treat this
++              as a seperate case
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: distribution1 forall(x,y,z): x/\(y\/z)=(x/\y)\/(x/\z)
++ Axiom: distribution2 forall(x,y,z): x\/(y/\z)=(x\/y)/\(x\/z)
BoundedDistributiveLattice: Category == Join(BoundedLattice,DistributiveLattice)

)abbrev category FRAME Frame
++ Description: frames are used in topology and are the lattice
++              associated with the concept of a 'locale'.
++              see: [1]
++   A Frame is a Lattice where certain subsets are also Lattices
++   for more documatation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
++ Axiom: every subset has a join 
++ Axiom: every finite subset has a meet
++ Axiom: binary meets distribute over joins
Frame(P:Poset(SetCategory)): Category == Join(MeetSemilattice,BoundedJoinSemilattice) with
      meet:(List %) -> %
        ++ returns the logical 'meet' of some subset specified
        ++ by a list of elements.
      join:(List %) -> %
        ++ returns the logical 'join' of some subset specified
        ++ by a list of elements.

)abbrev category LOGIC Logic
++ Note: transferred from boolean.spad
++ Author:
++ Date Created:
++ Change History:
++ Basic Operations: ~, /\, \/
++ Related Constructors:
++ Keywords: boolean
++ Description:
++ 'Logic' adds 'not' operation to lattices,
++ Imlements De Morgan's laws.
++ Axiom: DeMorgan1 forall(x,y): ~(x/\y)=~x\/~y
++ Axiom: DeMorgan2 forall(x,y): ~(x\/y)=~x/\~y
Logic : Category == BoundedDistributiveLattice with
       _~:        % -> %
        ++ ~(x) returns the logical complement of x.
  add
    -- default define 'join' in terms of 'meet' (Is that a good idea?)
    _\_/(x : %, y : %) == _~( _/_\(_~(x), _~(y)))

)abbrev domain FINLAT FiniteLattice
++ Author: Martin Baker
++ Description: This is the algebration of poset. A big difference between
++    this lattice domain and the poset domain is that, in this domain, the
++    REP holds a single node wheras in poset REP holds the whole poset.
FiniteLattice(S:SetCategory,p:Poset(S)) : Exports == Impl where
    NNI==> NonNegativeInteger
    Exports ==> Join(Lattice,CoercibleTo(OutputForm), SetCategory) with
     finiteLattice : (index:NNI) -> %
      ++ construct finite lattice element from index
     finiteLattice : (obj:S) -> %
      ++ construct finite lattice element from object

    Impl ==> add

      -- representation of element of lattice
      Rep := NNI

      -- construct finite lattice element from index
      finiteLattice(index:NNI) : % ==
        index

      -- construct finite lattice element from object
      finiteLattice(obj:S) : % ==
        objectToIndex(p,obj)$Poset(S)

      -- returns the logical 'meet', e.g. 'and'.
      _/_\(a:%,b:%) : % ==
        meet(p,a pretend NNI,b pretend NNI)$Poset(S)

      -- returns the logical 'join', e.g. 'or'.
      _\_/(a:%,b:%) : % ==
        join(p,a pretend NNI,b pretend NNI)$Poset(S)

      -- start of SetCategory definitions --

      hash(s : %) : SingleInteger == 0$SingleInteger

      -- return string representation
      -- I'm not sure how latex(s: %) is intended to be used but
      -- there is nothing specifically latex here, it just returns a
      -- string description of the graph.
      latex(n : %) : String ==
        -- s holds result that we are constructing
        s:String := ""
        s

      -- returns true if x equals y
      -- this is equality and not isomorphism
      -- that is it returns true only if exact index values and names are used
      -- in addition to the structure(arrows) being the same.
      _=(x : %, y : %) : Boolean ==
        (x pretend NNI)=(y pretend NNI)

      -- returns true if x is not equal to y
      _~_=(x : %, y : %) : Boolean == not(x = y)

      -- output
      coerce(s : %) : OutputForm ==
        index:NNI := s pretend NNI
        --if index=0 then return outputForm("error")
        obj:S := indexToObject(p,index)
        (obj::OutputForm)$S

)abbrev domain FINFRM FiniteFrame
++ Author: Martin Baker
++ Description: A Frame is a Lattice where certain subsets are also Lattices
FiniteFrame(S:SetCategory,p:Poset(S)) : Exports == Impl where
    NNI==> NonNegativeInteger
    --Exports ==> Join(Lattice,Frame(Poset(SetCategory)),CoercibleTo(OutputForm), SetCategory) with
    --Exports ==> Join(Lattice,FiniteLattice(SetCategory,Poset(SetCategory)),CoercibleTo(OutputForm), SetCategory) with
    -- *** FIX ME can't work out how to inherit from FiniteLattice
    Exports ==> Join(Lattice,CoercibleTo(OutputForm), SetCategory) with
     finiteFrame : (index:NNI) -> %
      ++ construct finite lattice element from index
     finiteFrame : (obj:S) -> %
      ++ construct finite lattice element from object

    -- *** FIX ME can't work out how to inherit from FiniteLattice
    --Impl == FiniteLattice(SetCategory,Poset(SetCategory)) add
    Impl == add

     -- *** FIX ME representation should really be inherited from FiniteLattice
     Rep := NNI

     -- returns the logical 'meet' of some subset specified
     -- by a list of elements.
     meet(elements:List(%)):% ==
       e:List(NNI) := [(x pretend NNI) for x in elements]
       meet(p,e)$Poset(S)

     -- returns the logical 'join' of some subset specified
     -- by a list of elements.
     join(elements:List(%)):% ==
       e:List(NNI) := [(x pretend NNI) for x in elements]
       join(p,e)$Poset(S)

)abbrev package POSETF PosetFactory
++ Author: Martin Baker
++ Date Created: Aug 2015
++ Date Last Updated: Aug 2015
++ Description:
++  Provides functions to construct various small posets 
++  including powerset.
++  Perhaps it should be called a 'powerlist' but since we do
++  not expect duplicates or reqire specific ordering it is
++  essentially the same.
PI ==> PositiveInteger
NNI==> NonNegativeInteger

PosetFactory(S : SetCategory) : with
  powerset:(List S) -> Poset(List(S))
    ++ generate a poset representing all possible subsets of a
    ++ given set with their subset relationships.
  completelyOrderedSet:(objs:List(S)) -> Poset(S)
    ++ generates a completely ordered set
  posetN5:(objs:List(S)) -> Poset(S)
    ++ generates a poset corresponding to an N5 lattice
  posetM5:(objs:List(S)) -> Poset(S)
    ++ generates a poset corresponding to an M5 lattice
  posetO6:(objs:List(S)) -> Poset(S)
    ++ generates a poset corresponding to an O6 lattice
  posetP6:(objs:List(S)) -> Poset(S)
    ++ generates a poset corresponding to an P6 lattice
  posetL7:(objs:List(S)) -> Poset(S)
    ++ generates a poset corresponding to an L7 lattice

 == add

  -- local function used by powerset
  addDimensionToObjects(a:List(List(S)),newObj:S):List(List(S)) ==
    b:List(List(S)) := nil
    for x in a repeat
      x1:List(S) :=concat(x,newObj)
      b := concat(b,x1)
    concat(a,b)

  -- local function used by powerset
  addDimensionToArrows(a:List(List(Boolean))):List(List(Boolean)) ==
    res:List(List(Boolean)) := [empty()$List(Boolean)]
    fst:Boolean := true
    for xrepeat in 1..2 repeat
      for x in a repeat
        thisRow:List(Boolean) := empty()$List(Boolean)
        for yrepeat in 1..2 repeat
          for y in x repeat
            topRight:Boolean := (xrepeat = 1) and (yrepeat = 2)
            thisRow := concat(thisRow,if topRight then false else y)
        if fst
          then
            res := [copy(thisRow)]
            fst := false
          else
            res := concat(res,copy(thisRow))$List(List(Boolean))
    res

  -- generate a poset representing all possible subsets of a
  -- given set with their subset relationships.
  powerset(objs:List S):Poset(List(S)) ==
    eles:List(List(S)) := [nil]
    arrows: List(List(Boolean)):=[[true]]
    for x in objs repeat
      eles := addDimensionToObjects(eles,x)
      arrows := addDimensionToArrows(arrows)
    poset(eles,arrows)$Poset(List(S))

  -- generates a completely ordered set
  completelyOrderedSet(objs:List(S)):Poset(S) ==
    dim:NNI := #objs
    arrows:List(List(Boolean)) := [nil]
    for x in 1..dim repeat
      row:List Boolean := nil
      for y in 1..dim repeat
        g:Boolean := if x >= y then true else false
        row := concat(row,g)
      arrows := concat(arrows,row)
    poset(objs,arrows)$Poset(S)
    
  -- generates a poset corresponding to an N5 lattice
  posetN5(objs:List(S)):Poset(S) ==
    poset(objs,[[true,true,true,true,true],
    [false,true,false,false,true],
    [false,false,true,true,true],
    [false,false,false,true,true],
    [false,false,false,false,true]
    ])$Poset(S)

  -- generates a poset corresponding to an M5 lattice
  posetM5(objs:List(S)):Poset(S) ==
    poset(objs,[[true,true,true,true,true],
    [false,true,false,false,true],
    [false,false,true,false,true],
    [false,false,false,true,true],
    [false,false,false,false,true]
    ])$Poset(S)

  -- generates a poset corresponding to an O6 lattice
  posetO6(objs:List(S)):Poset(S) ==
    poset(objs,[[true,true,true,true,true,true],
    [false,true,true,false,false,true],
    [false,false,true,false,false,true],
    [false,false,false,true,true,true],
    [false,false,false,false,true,true],
    [false,false,false,false,false,true]
    ])$Poset(S)

  -- generates a poset corresponding to an P6 lattice
  posetP6(objs:List(S)):Poset(S) ==
    poset(objs,[[true,true,true,true,true,true],
    [false,true,true,false,true,true],
    [false,false,true,false,false,true],
    [false,false,true,true,true,true],
    [false,false,false,false,true,true],
    [false,false,false,false,false,true]
    ])$Poset(S)

  -- generates a poset corresponding to an L7 lattice
  posetL7(objs:List(S)):Poset(S) ==
    poset(objs,[[true,true,true,true,true,true,true],
    [false,true,false,true,true,false,true],
    [false,false,true,false,true,true,true],
    [false,false,false,true,false,false,true],
    [false,false,false,false,true,false,true],
    [false,false,false,false,false,true,true],
    [false,false,false,false,false,false,true]
    ])$Poset(S)

)if false
\section{Infinite (unbounded) Littices}
\subsection{Intuitionistic Logic}
The intuitionisticLogic domain implements a Heyting algebra implied
by intuitionistic logic similar to boolean algebra.

Intuitionistic or constructive logic is similar to classical logic
but where the law of excluded middle is not used.

The implementation starts with a 'free logic algebra' that is an
algebra where each combination of inputs to /\ , \/ and - generates
a new element. So an expression like T /\ T is just T /\ T and does
not simplify.

Then by adding "simplification rules" (should I have called them
relators?) then other logic algebras can be implemented (intuitional,
ternary, many-valued, boolean) just by adding the "rules".

These "rules" are hardcoded into the /\ , \/ and - implementations
(rather than implementing a true rule based system).

Simplification rules :

    ~T -> _|_
    ~(~T) -> T
    ~x /\ x -> _|_
    x /\ ~x -> _|_
    x /\ x -> x
    _|_ /\ x -> _|_
    x /\ _|_ -> _|_
    T \/ x -> T
    x \/ T -> T
    x \/ x -> x
    x /\ T -> x
    T /\ x -> x
    x \/ _|_ -> x
    _|_ \/ x -> x

where:

    T = true
    _|_ = false
    x = arbitrary proposition

An opton to generalise this code might be to implement the 'free
logic algebra' as a category, then intuitional, ternary, many-valued,
boolean could be domains which overload /\ , \/ and - with their own
sets of rules.

Note : Please be aware that changes may be made in the future to improve
      and correct intuitionistic logic domain, such as:
\begin{itemize}
\item investigate change of meaning of $=$ for intuitionistic logic to
     represent equivalence rather than equality.
\item implement more complete algorithm to decide if two (quantifier-free)
     intuitionistic formulas are equivalent.
\end{itemize}
\section{Intuitionistic Logic Tutorial}
Intuitionistic logic has many possible values : true $T$, false $_|_$ and
infinitely many other values generated by constructs such as inverse.
These can be constructed as follows:

\begin{verbatim}
(1) -> logicF()

   (1)  "_|_"
                                                             Type : ILogic
(2) -> logicT()

   (2)  "T"
                                                             Type : ILogic
(3) -> ~logicT()

   (3)  "_|_"
                                                             Type : ILogic
\end{verbatim}

This logic has different rules from boolean algebra and all constructions
do not reduce to true or false. To test out our constructs we will use
the following list:

\begin{verbatim}
(4) -> l:List ILogic := [logicF(),logicT(),proposition("a"),~proposition("a"),proposition("b"),~proposition("b")]

 LISP output:
((0 F) (0 T) (1 a) (3 NOT 1 a) (1 b) (3 NOT 1 b))
                                                       Type : List(ILogic)
\end{verbatim}

First we will try 'not':
\begin{verbatim}
(5) -> [(~j)::OutputForm for j in l]

   (5)  ["~(_|_)","_|_","~(a)","~(~(a))","~(b)","~(~(b))"]
                                                   Type : List(OutputForm)
\end{verbatim}

We can print a truth table for 'and' and 'or'. This is the same as
boolean logic for true/false values and extended for the unproven case.
\begin{verbatim}
(6) -> matrix[ [(k /\ j)::OutputForm for j in l] for k in l]

     (6)
    SUB
       matrix
       ["_|_","_|_","_|_","_|_","_|_","_|_"]
      ["_|_","T","a","~(a)","b","~(b)"]
      ["_|_","a","a","_|_","(a/\b)","(a/\~(b))"]
      ["_|_","~(a)","_|_","~(a)","(~(a)/\b)","(~(a)/\~(b))"]
      ["_|_","b","(b/\a)","(b/\~(a))","b","_|_"]
      ["_|_","~(b)","(~(b)/\a)","(~(b)/\~(a))","_|_","~(b)"]
                                                               Type : Symbol

Note : Its hard to read this table in text, it displays better as
html on this page:
http : //www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/

(7) -> matrix[ [(k \/ j)::OutputForm for j in l] for k in l]

     (7)
    SUB
       matrix
      ["_|_","T","a","~(a)","b","~(b)"]
      ["T","T","T","T","T","T"]
      ["a","T","a","(a\/~(a))","(a\/b)","(a\/~(b))"]
      ["~(a)","T","(~(a)\/a)","~(a)","(~(a)\/b)","(~(a)\/~(b))"]
      ["b","T","(b\/a)","(b\/~(a))","b","(b\/~(b))"]
      ["~(b)","T","(~(b)\/a)","(~(b)\/~(a))","(~(b)\/b)","~(b)"]

                                                               Type : Symbol
\end{verbatim}

'implies' produces the following truth table.
\begin{verbatim}
(8) -> matrix[ [implies(k, j)::OutputForm for j in l] for k in l]


   (8)
    SUB
       matrix
       ["T","T","(_|_->a)","(_|_->~(a))","(_|_->b)","(_|_->~(b))"]
       ["_|_","T","(T->a)","(T->~(a))","(T->b)","(T->~(b))"]
       ["(a->_|_)","(a->T)","(a->a)","(a->~(a))","(a->b)","(a->~(b))"]
       ["(~(a)->_|_)", "(~(a)->T)", "(~(a)->a)", "(~(a)->~(a))", "(~(a)->b)",
        "(~(a)->~(b))"]
       ["(b->_|_)","(b->T)","(b->a)","(b->~(a))","(b->b)","(b->~(b))"]
       ["(~(b)->_|_)", "(~(b)->T)", "(~(b)->a)", "(~(b)->~(a))", "(~(b)->b)",
        "(~(b)->~(b))"]
                                                               Type : Symbol
\end{verbatim}

Now that we can do intuitionistic logic with constant values we can
go on to represent theories. We can enter a symbolic value as follows:
\begin{verbatim}
(9) -> proposition("p1")

   (9)  "p1"
                                                             Type : ILogic
\end{verbatim}

When applying a symbolic value, then it may not possible to compress
as a single node, so the result remains as a tree. So (13) can be
reduced to a single value $_|_$, because the result does not depend
on \verb'a', however in (12) we cannot reduce to a single value.
\begin{verbatim}
(10) -> proposition("a") /\ proposition("b")

   (10)  "(a/\b)"
                                                             Type : ILogic
(11) -> implies(proposition("a"),proposition("b"))

   (11)  "(a->b)"
                                                             Type : ILogic
(12) -> proposition("a") /\ logicT()

   (12)  "a"
                                                             Type : ILogic
(13) -> proposition("a") /\ logicF()

   (13)  "_|_"
                                                             Type : ILogic
\end{verbatim}
\section{applying modus ponens}
modus ponens tells us that given : 'a' and 'a->b' then we can imply 'b'.
So we first assert 'a' and 'a->b' as follows:
\begin{verbatim}
(14) -> givens := proposition("a") /\ implies(proposition("a"),proposition("b"))

   (14)  "(a/\(a->b))"
                                                             Type : ILogic
\end{verbatim}
We then factor into seperate terms:
\begin{verbatim}
(15) -> fgivens := factor(givens)

 LISP output:
((1 a) (2 . UNPRINTABLE))
                                                       Type : List(ILogic)
\end{verbatim}
note : List ILOGIC to OutputForm is fixed in latest FriCAS so it will
now display : [a, a->b]

We now apply the deductions function to this list.
\begin{verbatim}
(16) -> deduct := deductions(fgivens)

 LISP output:
((1 b))
                                                       Type : List(ILogic)
\end{verbatim}
so we get the required deduction 'b'

\section{domain ILOGIC ILogic}
)endif

)abbrev domain ILOGIC ILogic
++ Author: Martin Baker
++ Date Created: March 2011
++ Date Last Updated: September 2011
++ Basic Operations:
++ Related Constructors:
++ Keywords: intuitionisticLogic
++ Description: ILogic is an algebra with
++ true, false and other 'unproven' values
++ References:
++ http: //www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/

ILogic() : Exports == Implementation where

 NNI==> NonNegativeInteger
 PR ==> Record(rft : %, pout : NNI)
   ++ parse result includes term returned and new index

 Exports == Join(Logic, CoercibleTo(OutputForm)) with
  logicT : () -> %
    ++ true is a logical constant.
  logicF : () -> %
    ++ false (contradiction) is a logical constant.
  proposition : (s : String) -> %
    ++ Constructs a proposition
  implies : (%, %) -> %
    ++ implies(a, b) returns the logical implication
    ++ of ILogic a and b.
    ++ a is premise, b is conclusion, result is false (contradiction)
    ++ if premise=true and conclusion=false
    ++ does not mean there is a causal connection
  redux : (n : %) -> %
    ++ attempt to simplify theory
    ++ apply recursively to subnodes
    ++ normally this should not be necessary since logic values are
    ++ interpreted when constructed
  factor : (n : %) -> List %
    ++ splits n into a list of factors which must be true for the
    ++ whole to be true.
    ++ This assumes that the top level is already a set of factors
    ++ seperated by /\ otherwise the result will just be a list with
    ++ one entry: 'n'.
    ++ This is used when converting ILogic to types by using the
    ++ Curry-Howard isomorphism.
  deductions : (ln : List %) -> List %
    ++ assumes ln contains a list of factors which must be true for
    ++ the whole to be true (such as the list produced by factor).
    ++ From this deductions attemps to produce a list of other
    ++ proposition that must also be true by using modus ponens.
    ++ This is used to determine the returned type when converting
    ++ ILogic to types by using the Curry-Howard isomorphism.
  "=": (a:%, b:%) -> Boolean
    ++ returns true (boolean true) if intuitionisticLogic values
    ++ are the same.
    ++ Translates from Intuitionistic Logic to Boolean Logic
  opType : (n : %) -> Symbol
    ++ if this is a compound op then opType returns the type of
    ++ that op:
    ++ "IMPLY"::Symbol =implies
    ++ "AND"::Symbol=/\
    ++ "OR"::Symbol=\/
    ++ "NOT"::Symbol=~
    ++ "OTHER"::Symbol=not compound op
  getChildren : (n : %) -> List %
    ++ returns child nodes if this is a compound term
    ++ otherwise returns []
  atom? : (n : %) -> Boolean
    ++ returns true if this is an atom, that is a leaf node
    ++ otherwise return false if this is a compound term
  value : (n : %) -> Symbol
    ++ returns:
    ++   "T"::Symbol = T
    ++   "F"::Symbol = _|_
    ++   "E"::Symbol = error
    ++   "P"::Symbol = proposition
    ++   "C"::Symbol = compound
    ++ Constructs lambda term and bind any variables with the name provided
  parseIL : (t1 : String) -> %
    ++ Constructs intuitionistic logic terms from a string
    ++ notation assumes format like this:
    ++ <term> : := var | <term>/\<term> | <term>\/<term> |
    ++            <term>-><term> | "("<term>")"
  parseIL2 : (t1 : String, pin : NNI) -> PR
    ++ Constructs intuitionistic logic terms from a string
    ++ notation assumes format like this:
    ++ <term2> : := var | "("<term>")"
    ++ <term> : := var | <term>/\<term> | <term>\/<term> |
    ++            <term>-><term> | "("<term>")"
  parseILTerm : (t1 : String, pin : NNI)->PR
    ++ parseTerm is used by parseIL. It would rarely be called
    ++ externally but it is here to allow it to call parseIL
    ++ that is to allow circular calls
  toString : (n : %) -> String
    ++ creates a string representaion of this term and its sub-terms
  toStringUnwrapped : (n : %) -> String
    ++ similar to 'toString' but does not put outer compound terms
    ++ in brackets
  coerce : (n : %) -> OutputForm
    ++ output

 Implementation == add

  Rep := Union(_
         const : Record(val : Symbol), _
         var : Record(str : String), _
         binaryOp : Record(typ : Symbol, c1 : %, c2 : %), _
         unaryOp : Record(typ : Symbol, c1 : %)_
         )
    ++ this allows us to represent an intuitionistic
    ++ expression as a tree structure where the nodes are
    ++ one of:
    ++ 1) const: Record(val: Symbol)
    ++   holds the true and false values:
    ++   "T"::Symbol = T
    ++   "F"::Symbol = _|_
    ++
    ++ 2) var: Record(str: String)
    ++   holds a proposition name
    ++
    ++ 3) binaryOp: Record(typ: Symbol, c1: %, c2: %)
    ++   holds binary operations:
    ++   "IMPLY"::Symbol =implies
    ++   "AND"::Symbol=/\
    ++   "OR"::Symbol=\/
    ++ 4) unaryOp: Record(typ: Symbol, c1: %)
    ++   holds unary operations the only one is
    ++   "NOT"::Symbol = ~

  -- Constructs a proposition
  proposition(s : String) : % == [[s]]

  -- literal constructors
  logicT() == [["T"::Symbol]]
  logicF() == [["F"::Symbol]]

  -- not operator: returns the logical complement
  -- in general case 'x' this will generate a new element '~x'
  -- but for specific cases we can apply the simplification rules:
  -- ~T -> F
  -- ~(~T) -> T
  ~ b ==
    -- apply rule: ~T -> F
    if (b case const) then
      if (b.const.val = "T"::Symbol) then return [["F"::Symbol]]
    -- apply rule: ~(~T) -> T
    if (b case unaryOp) then
      c : % := b.unaryOp.c1
      if (c case unaryOp) then
        d : % := c.unaryOp.c1
        if (d case const) then
          if (d.const.val = "T"::Symbol) then return [["F"::Symbol]]
    [["NOT"::Symbol,b]]

  -- /\ returns the logical 'meet', e.g. 'and'.
  --
  -- simplification rules:
  -- ~x /\ x -> F
  -- x /\ ~x -> F
  -- x /\ x -> x
  -- F /\ x -> F
  -- x /\ F -> F
  -- x /\ T -> x
  -- T /\ x -> x
  --
  _/_\(a : %, b : %) ==
    -- apply rule: F /\ x -> F
    if (a case const) then
      if (a.const.val = "F"::Symbol) then return [["F"::Symbol]]
    -- apply rule: x /\ F -> F
    if (b case const) then
      if (b.const.val = "F"::Symbol) then return [["F"::Symbol]]
    -- apply rule: x /\ x -> x
    if a = b then
      return a
    -- apply rule: x /\ ~x -> F
    if a=(~b) then
      return [["F"::Symbol]]
    -- apply rule: ~x /\ x -> F
    if (~a)=b then
      return [["F"::Symbol]]
    -- apply rule: x /\ T -> x
    if (b case const) then
      if (b.const.val = "T"::Symbol) then return a
    -- apply rule: T /\ x -> x
    if (a case const) then
      if (a.const.val = "T"::Symbol) then return b
    [["AND"::Symbol,a,b]]


  -- \/ returns the logical 'join', e.g. 'or'.
  --
  -- simplification rules:
  -- T \/ x -> T
  -- x \/ T -> T
  -- x \/ x -> x
  -- x \/ _|_ -> x
  -- _|_ \/ x -> x
  --
  _\_/(a : %, b : %) ==
    -- apply rule: T \/ x -> T
    if (a case const) then
      if (a.const.val = "T"::Symbol) then return [["T"::Symbol]]
    -- apply rule: x \/ T -> T
    if (b case const) then
      if (b.const.val = "T"::Symbol) then return [["T"::Symbol]]
    -- apply rule: x \/ x -> x
    if a = b then
      return a
    -- apply rule: x \/ _|_ -> x
    if (b case const) then
      if (b.const.val = "F"::Symbol) then return a
    -- apply rule: _|_ \/ x -> x
    if (a case const) then
      if (a.const.val = "F"::Symbol) then return b
    [["OR"::Symbol,a,b]]

  -- implies(a, b) returns the logical implication
  -- of ILogic a and b.
  -- a is premise, b is conclusion, result is false (contradiction)
  -- if premise=true and conclusion=false
  -- does not mean there is a causal connection
  implies(a : %, b : %) ==
    if (a case const) and (b case const) then
      if (a.const.val ~= "F"::Symbol) and (b.const.val = "F"::Symbol) then return [["F"::Symbol]]
      return [["T"::Symbol]]
    [["IMPLY"::Symbol,a,b]]

  -- attempt to simplify theory
  -- apply recursively to subnodes
  -- normally this should not be necessary since logic values are
  -- interpreted when constructed
  --
  -- simplification rules:
  -- ~T -> F
  -- ~(~T) -> T
  -- ~x /\ x -> F
  -- x /\ ~x -> F
  -- x /\ x -> x
  -- F /\ x -> F
  -- x /\ F -> F
  -- x /\ T -> x
  -- T /\ x -> x
  -- T \/ x -> T
  -- x \/ T -> T
  -- x \/ x -> x
  -- x \/ _|_ -> x
  -- _|_ \/ x -> x
  --
  redux(n : %) : % ==
    if n case const then
      return n
    if n case var then
      return n
    if n case binaryOp then
      if n.binaryOp.typ="IMPLY"::Symbol then
        return implies(redux(n.binaryOp.c1), redux(n.binaryOp.c2))
      if n.binaryOp.typ="AND"::Symbol then
        return _/_\(redux(n.binaryOp.c1), redux(n.binaryOp.c2))
      if n.binaryOp.typ="OR"::Symbol then
        return _\_/(redux(n.binaryOp.c1), redux(n.binaryOp.c2))
    if n case unaryOp then
      return ~(redux(n.unaryOp.c1))
    n

  -- splits n into a list of factors which must be true for the
  -- whole to be true.
  -- This assumes that the top level is already a set of factors
  -- seperated by /\ otherwise the result will just be a list with
  -- one entry: 'n'.
  -- This is used when converting ILogic to types by using the
  -- Curry-Howard isomorphism.
  factor(n : %) : List % ==
    if ~(n case binaryOp) then return [n]
    if ~(n.binaryOp.typ="AND"::Symbol) then return [n]
    ch : List % := getChildren(n)
    concat(factor(first ch), factor(second ch))

  -- remove duplicates. Return elements of 'b' except those that are
  -- in 'a'
  -- I would use duplicate removal built into List but that only
  -- works when the list is defined over SETCAT
  removeDup(a : List %, b : List %) : List % ==
    res : List % := []
    for b1 in b repeat
      fnd : Boolean := false()
      for a1 in a repeat
        if a1 = b1 then fnd := true()
      if not fnd then res := concat(res, b1)
    res

  -- a single iteration for deductions below.
  deductions1(ln : List %) : List % ==
    res : List % := []
    for n in ln repeat
      if n case binaryOp then
        if n.binaryOp.typ="IMPLY"::Symbol then
          ch : List % := getChildren(n)
          for n2 in ln repeat
            if (first ch)=n2 then res := concat(res, second ch)
    res

  -- assumes ln contains a list of factors which must be true for
  -- the whole to be true (such as the list produced by factor).
  -- From this deductions attemps to produce a list of other
  -- proposition that must also be true by using modus ponens.
  -- This is used to determine the returned type when converting
  -- ILogic to types by using the Curry-Howard isomorphism.
  deductions(ln : List %) : List % ==
    res : List % := []
    thisres : List % := deductions1(ln)
    res := concat(res, thisres)$(List %)
    -- these deductions may lead to further deductions so we
    -- need to apply again until there are no more deductions
    emptyres : Boolean := empty?(thisres)$(List %)
    loopbreaker := 1::NNI
    while not emptyres and (loopbreaker<20)repeat
      allres : List % := concat(ln, res)
      thisres := deductions1(allres)
      thisres := removeDup(res, thisres)
      thisres := removeDup(allres, thisres)
      res := concat(res, thisres)$(List %)
      emptyres := empty?(thisres)$(List %)
      loopbreaker := loopbreaker + 1
    res

  -- if this is a compound op then opType returns the type of that op:
  -- "IMPLY"::Symbol =implies
  -- "AND"::Symbol=/\
  -- "OR"::Symbol=\/
  -- "NOT"::Symbol=~
  -- "OTHER"::Symbol=not compound op
  opType(n : %) : Symbol ==
    if n case binaryOp then return n.binaryOp.typ
    if n case unaryOp then return "NOT"::Symbol
    "OTHER"::Symbol

  -- returns true if this is an atom, that is a leaf node
  -- otherwise return false if this is a compound term
  atom?(n : %) : Boolean == (n case var) or (n case const)

  -- returns:
  --   "F"::Symbol = _|_
  --   "T"::Symbol = T
  --   "E"::Symbol = error
  --   "P"::Symbol = proposition
  --   "C"::Symbol = compound
  value(n : %) : Symbol ==
    if n case const then
      if (n.const.val = "F"::Symbol) then return "F"::Symbol
      if (n.const.val = "T"::Symbol) then return "T"::Symbol
      return "E"::Symbol
    if n case var then
      return "P"::Symbol
    "C"::Symbol

  -- returns child nodes if this is a compound term
  -- otherwise returns []
  getChildren(n : %) : List % ==
    if atom?(n) then return []
    if n case binaryOp then
      return [n.binaryOp.c1, n.binaryOp.c2]
    if n case unaryOp then
      return [n.unaryOp.c1]

  -- returns true (boolean true) if intuitionisticLogic values
  -- are the same. The terms must match exactly not just be
  -- equivalent, that is x /\ 1 is not equal to x
  -- Translates from Intuitionistic Logic to Boolean Logic
  a = b ==
    if (a case const) and (b case const) then
      if (a.const.val = "F"::Symbol) and (b.const.val = "F"::Symbol) then return true
      if (a.const.val = "T"::Symbol) and (b.const.val = "T"::Symbol) then return true
      return false
    if (a case var) and (b case var) then
      -- variable node so compare names
      if a.var.str = b.var.str then return true
      return false
    if (a case binaryOp) and (b case binaryOp) then
      -- binary node which has two subnodes c1 and c2
      if (a.binaryOp.typ ~= b.binaryOp.typ) then return false
      if (a.binaryOp.c1 = b.binaryOp.c1) and (a.binaryOp.c2 = b.binaryOp.c2) then return true
      return false
    if (a case unaryOp) and (b case unaryOp) then
      -- unary node which has a subnode c1
      if (a.unaryOp.typ ~= b.unaryOp.typ) then return false
      if a.unaryOp.c1 = b.unaryOp.c1 then return true
      return false
    false

  parseBracketTerm(t1 : String, pin : NNI) : PR ==
    p1 := pin
    trm : % := logicT()
    ch := qelt(t1, p1)
    if not (ch = char("(")) then
      error "bracket term must start with ("
      return [trm, p1]
    p1 := p1 + (1::NNI)
    if p1 > maxIndex(t1) then
      error "opening but no closing bracket"
      return [trm, p1]
    r2 := parseILTerm(t1, p1)
    trm := r2.rft
    p1 := r2.pout
    ch := qelt(t1, p1)
    if not (ch = char(")")) then
      error "can't find closing bracket"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    [trm, p1]

  -- parse /\ term
  -- expects first term to be read already
  -- should now be pointing to /\ characters
  parseILand(t1 : String, pin : NNI, firstTerm : %) : PR ==
    p1 := pin
    pt : NNI := pin
    trm : % := logicT()
    ch := qelt(t1, p1)
    if not (ch = char("/")) then
      error "expecting /\"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    ch := qelt(t1, p1)
    if not (ch = char("\")) then
      error "expecting /\"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    --sayMsg concat("st ch=",ch::String)
    r : PR := parseILTerm(t1, p1)
    secondTerm := r.rft
    p1 := r.pout
    [_/_\(firstTerm, secondTerm), p1]

  -- parse \/ term
  -- expects first term to be read already
  -- should now be pointing to \/ characters
  parseILor(t1 : String, pin : NNI, firstTerm : %) : PR ==
    p1 := pin
    pt : NNI := pin
    trm : % := logicT()
    ch := qelt(t1, p1)
    if not (ch = char("\")) then
      error "expecting \/"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    ch := qelt(t1, p1)
    if not (ch = char("/")) then
      error "expecting \/"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    --sayMsg concat("st ch=",ch::String)
    r : PR := parseILTerm(t1, p1)
    secondTerm := r.rft
    p1 := r.pout
    [_\_/(firstTerm, secondTerm), p1]

  -- parse -> term
  -- expects first term to be read already
  -- should now be pointing to -> characters
  parseILfn(t1 : String, pin : NNI, firstTerm : %) : PR ==
    p1 := pin
    pt : NNI := pin
    trm : % := logicT()
    ch := qelt(t1, p1)
    if not (ch = char("-")) then
      error "expecting ->"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    ch := qelt(t1, p1)
    if not (ch = char(">")) then
      error "expecting ->"
      return [trm, p1]
    p1 := p1 + (1::NNI)
    --sayMsg concat("st ch=",ch::String)
    r : PR := parseILTerm(t1, p1)
    secondTerm := r.rft
    p1 := r.pout
    [implies(firstTerm, secondTerm), p1]

  -- construct a type by parsing a string t1
  -- pin is index to string at start of parse
  parseILName(t1 : String, pin : NNI) : PR ==
    vnm:String := ""
    pt : NNI := pin
    ch := qelt(t1, pt)
    --sayMsg concat("st ch=",ch::String)
    while alphanumeric?(ch) repeat
      vnm := concat(vnm, ch)
      pt := pt + (1::NNI)
      if pt > maxIndex(t1) then
        return [proposition(vnm), pt]
      ch := qelt(t1, pt)
    [proposition(vnm), pt]

  parseILTerm(t1 : String, pin : NNI) : PR ==
    p1 := pin
    res : % := logicT()
    ch := qelt(t1, p1)
    --sayMsg concat(["parseTerm ch=",ch::String," p1=",string(p1)])$String
    -- first remove leading spaces
    while ch = char(" ") repeat
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        --sayMsg concat(["parseTerm(",t1,") 1 giving:",toString(res)])
        return [res, p1]
      ch := qelt(t1, p1)
    r : PR := [res, p1]
    if alphabetic?(ch) then r := parseILName(t1, p1)
    if ch = char("(") then r := parseBracketTerm(t1,p1)
    res := r.rft
    p1 := r.pout
    -- now check for compound term
    if p1 > maxIndex(t1) then
      --sayMsg concat(["parseTerm(",t1,") 2 giving:",toString(res)])
      return [res, p1]
    ch := qelt(t1, p1)
    if ch = char(" ") then
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        --sayMsg concat(["parseTerm(",t1,") 3 giving:",toString(res)])
        return [res, p1]
    ch := qelt(t1, p1)
    if ch = char("/") then
      r := parseILand(t1, p1, res)
      res := r.rft
      p1 := r.pout
    if ch = char("\") then
      r := parseILor(t1, p1, res)
      res := r.rft
      p1 := r.pout
    if ch = char("-") then
      r := parseILfn(t1, p1, res)
      res := r.rft
      p1 := r.pout
    [res, p1]

  -- Constructs intuitionistic logic terms from a string
  -- notation assumes format like this:
  -- <term> : := var | <term>/\<term> | <term>\/<term> |
  --            <term>-><term> | "("<term>")"
  parseIL2(t1 : String, pin : NNI) : PR ==
    p1 := pin
    res : % := logicT()
    ch := qelt(t1, p1)
    --sayMsg concat(["parseIL ch=",ch::String," p1=",string(p1)])$String
    -- first remove leading spaces
    while ch = char(" ") repeat
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        --sayMsg concat(["parseTerm(",t1,") 1 giving:",toString(res)])
        return [res, p1]
      ch := qelt(t1, p1)
    r : PR := [res, p1]
    if alphabetic?(ch) then r := parseILName(t1, p1)
    if ch = char("(") then r := parseBracketTerm(t1,p1)
    res := r.rft
    p1 := r.pout
    [res, p1]

  -- Constructs intuitionistic logic terms from a string
  -- notation assumes format like this:
  -- <term> : := var | <term>/\<term> | <term>\/<term> |
  --            <term>-><term> | "("<term>")"
  parseIL(t1 : String) : % ==
    r := parseILTerm(t1, minIndex(t1)::NNI)
    --sayMsg concat(["parseIL(",t1,") giving:",toString(tm)])
    r.rft

  -- return string representation
  toString(n : %) : String ==
    if n case const then
      if (n.const.val = "F"::Symbol) then return "__|__"
      if (n.const.val = "T"::Symbol) then return "T"
      return "?"
    if n case var then
      return n.var.str
      --sayMsg concat(["toString case i1=",s])
      --sayMsg n
    if n case binaryOp then
      -- binary node which has two subnodes c1 and c2
      s1:String := "->"
      if n.binaryOp.typ = "AND"::Symbol then s1 := "/\"
      if n.binaryOp.typ = "OR"::Symbol then s1 := "\/"
      return concat(["(",toString(n.binaryOp.c1),s1,toString(n.binaryOp.c2),")"])
    if n case unaryOp then
      -- unary node which has a subnode c1
     return concat(["~(",toString(n.unaryOp.c1),")"])
    "error"

  -- similar to 'toString' but does not put outer compound terms
  -- in brackets
  toStringUnwrapped(n : %) : String ==
    if n case const then
      if (n.const.val = "F"::Symbol) then return "__|__"
      if (n.const.val = "T"::Symbol) then return "T"
      return "?"
    if n case var then
      return n.var.str
      --sayMsg concat(["toString case i1=",s])
      --sayMsg n
    if n case binaryOp then
      -- binary node which has two subnodes c1 and c2
      s1:String := "->"
      if n.binaryOp.typ = "AND"::Symbol then s1 := "/\"
      if n.binaryOp.typ = "OR"::Symbol then s1 := "\/"
      return concat([toString(n.binaryOp.c1), s1, toString(n.binaryOp.c2)])
    if n case unaryOp then
      -- unary node which has a subnode c1
     return concat(["~(",toString(n.unaryOp.c1),")"])
    "error"

  -- output
  coerce(n : %) : OutputForm ==
    toString(n)::OutputForm

)if false
\section{Infinite (unbounded) Littices}
\subsection{Distributive Littices}
If the lattice is distributive then we can take advantage of this and make
the representation more efficient by representing it as either:

meet of joins
\begin{verbatim}
(a\/b\/...) /\ (c\/d\/...) /\ ...
\end{verbatim}

join of meets
\begin{verbatim}
(a/\b/\...) \/ (c/\d/\...) \/ ...
\end{verbatim}

So the representation is a list of lists like this:
\begin{verbatim}
Rep := List List Union(_
         const : Record(val : Symbol), _
         var : Record(str : String) _
         )
\end{verbatim}

Here is an example session to show how it works:
\begin{verbatim}
(1) -> MOJ := LatticeMeetOfJoins

   (1)  LatticeMeetOfJoins
                                                             Type: Type
a := variable("a")$MOJ

   (2)  ("a")
                                               Type: LatticeMeetOfJoins
b := variable("b")$MOJ

   (3)  ("b")
                                               Type: LatticeMeetOfJoins
c := variable("c")$MOJ

   (4)  ("c")
                                               Type: LatticeMeetOfJoins
d := variable("d")$MOJ

   (5)  ("d")
                                               Type: LatticeMeetOfJoins
land := a /\ b

   (6)  ("a")/\("b")
                                               Type: LatticeMeetOfJoins
lor := a \/ b

   (7)  ("a"\/"b")
                                               Type: LatticeMeetOfJoins
landor := land \/ c

   (8)  ("a"\/"c")/\("b"\/"c")
                                               Type: LatticeMeetOfJoins
landorand := landor /\ d

   (9)  ("a"\/"c")/\("b"\/"c")/\("d")
                                               Type: LatticeMeetOfJoins

\end{verbatim}
)endif

)abbrev domain LATMOFJ LatticeMeetOfJoins
++ Author: Martin Baker
++ Date Created: Sept 2015
++ Date Last Updated: Sept 2015
++ Basic Operations:
++ Related Constructors: LatticeJoinOfMeets is complementry domain
++ Keywords: Logic Lattice Meet Join
++ Description: Infinite Lattice which is distributive.
++   Representation held as meet of joins.
++ References:
++ http: //www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/

LatticeMeetOfJoins() : Exports == Implementation where

 NNI==> NonNegativeInteger
 PR ==> Record(rft : %, pout : NNI)
   ++ parse result includes term returned and new index
 ELEMENT ==> Union(_
         const : Record(val : Symbol), _
         var : Record(str : String) _
         )

 Exports == Join(BoundedDistributiveLattice, CoercibleTo(OutputForm)) with
  logicT : () -> %
    ++ construct true: a logical constant.
  logicF : () -> %
    ++ construct false (contradiction): a logical constant.
  variable:(v:String) -> %
    ++ construct a variable
  latticeMeetOfJoins:(e:ELEMENT) -> %
    ++ construct a lattice with one element
  emptyLattice:() -> %
    ++ construct an empty lattice
  empty?:(n:%) -> Boolean
    ++ true if empty
  meet : (ln : List %) -> %
    ++ meet of set of elements
  join : (ln : List %) -> %
    ++ join of set of elements
  redux : (n : %) -> %
    ++ attempt to simplify terms
  factor : (n : %) -> List %
    ++ splits n into a list of factors which must be true for the
    ++ whole to be true.
    ++ This assumes that the top level is already a set of factors
    ++ seperated by /\ otherwise the result will just be a list with
    ++ one entry: 'n'.
    ++ This is used when converting ILogic to types by using the
    ++ Curry-Howard isomorphism.
  deductions : (ln : List %) -> List %
    ++ assumes ln contains a list of factors which must be true for
    ++ the whole to be true (such as the list produced by factor).
    ++ From this deductions attemps to produce a list of other
    ++ proposition that must also be true by using modus ponens.
    ++ This is used to determine the returned type when converting
    ++ ILogic to types by using the Curry-Howard isomorphism.
  "=": (a:%, b:%) -> Boolean
    ++ returns true (boolean true) if intuitionisticLogic values
    ++ are the same.
    ++ Translates from Intuitionistic Logic to Boolean Logic
  opType : (n : %) -> Symbol
    ++ if this is a compound op then opType returns the type of
    ++ that op:
    ++ "IMPLY"::Symbol =implies
    ++ "AND"::Symbol=/\
    ++ "OR"::Symbol=\/
    ++ "NOT"::Symbol=~
    ++ "OTHER"::Symbol=not compound op
  getChildren : (n : %) -> List %
    ++ returns child nodes if this is a compound term
    ++ otherwise returns []
  atom? : (n : %) -> Boolean
    ++ returns true if this is an atom, that is a leaf node
    ++ otherwise return false if this is a compound term
  value : (n : %) -> Symbol
    ++ returns:
    ++   "T"::Symbol = T
    ++   "F"::Symbol = _|_
    ++   "E"::Symbol = error
    ++   "P"::Symbol = proposition
    ++   "C"::Symbol = compound
    ++ Constructs lambda term and bind any variables with the name provided
  toString : (n : %) -> String
    ++ creates a string representaion of this term and its sub-terms
  toStringUnwrapped : (n : %) -> String
    ++ similar to 'toString' but does not put outer compound terms
    ++ in brackets
  coerce : (n : %) -> OutputForm
    ++ output

 Implementation == add

  Rep := List(List(ELEMENT))
    ++ This domain is a distributive lattice, this allows us to
    ++ represent the lattice as a meet of joins.
    ++ So the inner list is a list of elements which are joined,
    ++ the outer list represents a meet of these joins.
    ++ The elements of this structure are constants or variables:
    ++ 1) const: Record(val: Symbol)
    ++   holds the true and false values:
    ++   "T"::Symbol = T
    ++   "F"::Symbol = _|_
    ++
    ++ 2) var: Record(str: String)
    ++   holds a proposition name


  -- Constructs a proposition
  proposition(s : String) : % == [[[[s]]]]

  -- literal constructors
  logicT() == [[[["T"::Symbol]]]]
  logicF() == [[[["F"::Symbol]]]]

  -- construct a variable
  variable(v:String):% == [[[[v]]]]

  -- construct a lattice with one element
  latticeMeetOfJoins(e:ELEMENT):% ==
    [[e]]

  emptyLattice() == nil()$List(List(ELEMENT))

  -- true if empty
  empty?(n:%):Boolean ==
    empty?(n)$Rep

  -- /\ returns the logical 'meet', e.g. 'and'.
  --
  -- simplification rules:
  -- ~x /\ x -> F
  -- x /\ ~x -> F
  -- x /\ x -> x
  -- F /\ x -> F
  -- x /\ F -> F
  -- x /\ T -> x
  -- T /\ x -> x
  --
  _/_\(a : %, b : %) ==
    if empty?(a) then return b
    if empty?(b) then return a
    redux(concat(a pretend Rep,b pretend Rep)$List(List(ELEMENT)))

  -- \/ returns the logical 'join', e.g. 'or'.
  --
  -- simplification rules:
  -- T \/ x -> T
  -- x \/ T -> T
  -- x \/ x -> x
  -- x \/ _|_ -> x
  -- _|_ \/ x -> x
  --
  _\_/(a : %, b : %) ==
    if empty?(a) then return b
    if empty?(b) then return a
    r:List(List(ELEMENT)):=[]
    for innera in a repeat
      for innerb in b repeat
        termLeft:List(ELEMENT) := innera
        termRight:List(ELEMENT) := innerb
        term:=concat(termLeft,termRight)$List(ELEMENT)
        r:=concat(r,term)$List(List(ELEMENT))
    redux(r)

  meet(ln : List %):% ==
    r:% := emptyLattice()
    for ele in ln repeat
      r := _/_\(r,ele)
    r

  join(ln : List %):% ==
    r:% := emptyLattice()
    for ele in ln repeat
      r := _\_/(r,ele)
    r

  -- local function used by removeDuplicatesInTerm which is used by
  -- redux to remove duplicates.
  -- Returns true if elements are equal.
  equalElements(a:ELEMENT,b:ELEMENT) :Boolean ==
    if (a case var) and (a case var) then
       return (a.var.str) = (b.var.str)
    if (a case const)  and (b case const) then
       return (a.const.val) = (b.const.val)
    false

  -- local function used by redux to remove duplicates, that is
  -- apply idempotence. We cannot use the removeDuplicates in List
  -- because ELEMENT does not have ATFINAG or BASTYPE.
  removeDuplicatesInTerm(n : List(ELEMENT)) : List(ELEMENT) ==
    r:List(ELEMENT) := nil()$List(ELEMENT)
    for e1 in n for ne1 in 1..#n repeat
      match:Boolean := false
      for e2 in n for ne2 in 1..#n repeat
        if e1=e2 and ne1<ne2 then match := true
      if not match then r:=concat(r,e1)
    r

  -- local function used by redux to remove duplicate lists.
  -- Returns true if lists are equal, that is contain the same elements
  -- (independant of order).
  equalTerms(a:List(ELEMENT),b:List(ELEMENT)) :Boolean ==
    if #a ~= #b then return false
    for a1 in a repeat
      found:Boolean := false
      for b1 in b repeat
        if equalElements(a1,b1) then found:= true
      if not found then return false
    true

  -- local function used by redux to apply absorbtion.
  -- Returns true if a is a sub-term of b.
  subTerm(a:List(ELEMENT),b:List(ELEMENT)) :Boolean ==
    if #a >= #b then return false
    for a1 in a repeat
      found:Boolean := false
      for b1 in b repeat
        if equalElements(a1,b1) then found:= true
      if not found then return false
    true

  -- Attempt to simplify terms
  --
  -- simplification rules:
  -- idempotenceMeet for all x: x /\ x -> x ()
  -- idempotenceJoin for all x: x \/ x -> x
  -- absorptionMeetOverJoin for all(x,y): x/\(x\/y)=x
  -- absorptionJoinOverMeet for all(x,y): x\/(x/\y)=x
  --
  -- TODO add rules for top and bottom
  --
  redux(n : %) : % ==
    r:List(List(ELEMENT)) := nil()$List(List(ELEMENT))
    for outer in n for outern in 1..#n repeat
      -- check for idempotence
      newinnerList:List(ELEMENT) := removeDuplicatesInTerm(outer)
      match:Boolean := false
      for inner in n for innern in 1..#n repeat
        if equalTerms(inner,outer) and innern<outern then match := true      
      -- check for absorption
      isSubTerm:Boolean := false
      for inner in n repeat
        if subTerm(inner,outer) then isSubTerm := true
      if (not match) and (not isSubTerm) then r:=concat(r,newinnerList)$List(List(ELEMENT))
    --print hconcat([("redux"::OutputForm),(n::OutputForm),(","::OutputForm),((r pretend %)::OutputForm)])$OutputForm
    r

  -- splits n into a list of factors which must be true for the
  -- whole to be true.
  -- This assumes that the top level is already a set of factors
  -- seperated by /\ otherwise the result will just be a list with
  -- one entry: 'n'.
  -- This is used when converting ILogic to types by using the
  -- Curry-Howard isomorphism.
  factor(n : %) : List % ==
    [n]

  -- remove duplicates. Return elements of 'b' except those that are
  -- in 'a'
  -- I would use duplicate removal built into List but that only
  -- works when the list is defined over SETCAT
  removeDup(a : List %, b : List %) : List % ==
    a

  -- assumes ln contains a list of factors which must be true for
  -- the whole to be true (such as the list produced by factor).
  -- From this deductions attemps to produce a list of other
  -- proposition that must also be true by using modus ponens.
  -- This is used to determine the returned type when converting
  -- ILogic to types by using the Curry-Howard isomorphism.
  deductions(ln : List %) : List % ==
    ln

  -- if this is a compound op then opType returns the type of that op:
  -- "IMPLY"::Symbol =implies
  -- "AND"::Symbol=/\
  -- "OR"::Symbol=\/
  -- "NOT"::Symbol=~
  -- "OTHER"::Symbol=not compound op
  opType(n : %) : Symbol ==
    "OTHER"::Symbol

  -- returns true if this is an atom, that is a leaf node
  -- otherwise return false if this is a compound term
  atom?(n : %) : Boolean == false

  -- returns:
  --   "F"::Symbol = _|_
  --   "T"::Symbol = T
  --   "E"::Symbol = error
  --   "P"::Symbol = proposition
  --   "C"::Symbol = compound
  value(n : %) : Symbol ==
    "C"::Symbol

  -- returns child nodes if this is a compound term
  -- otherwise returns []
  getChildren(n : %) : List % ==
    [n]

  -- returns true (boolean true) if values
  -- are the same. The terms must match exactly not just be
  -- equivalent, that is x /\ 1 is not equal to x
  -- Translates from Intuitionistic Logic to Boolean Logic
  a = b ==
    false

  -- return string representation
  toString(n : %) : String ==
    a:String:=concat("(",toStringUnwrapped(n))
    a:String:=concat(a,")")
    a

  -- local function used by coerce to String
  -- convert variable or literal to String
  stringVarOrLit(a:Union(const : Record(val : Symbol),var : Record(str : String))) : String ==
     if (a case var) then return (a.var.str)::String
     if (a case const) then
       if (a.const.val) = "T"::Symbol then return "T"
       return "F"
     "error"

  -- similar to 'toString' but does not put outer compound terms
  -- in brackets
  toStringUnwrapped(n : %) : String ==
    outerList:List String := []
    r:String := ""
    for outer in n for outern in 1..#n repeat
      innerList:List String := []
      for inner in outer for innern in (1..#outer) repeat
        r := concat(r::String,stringVarOrLit(inner))
        if innern ~= #outer then r := concat(r::String,"_\_/"::String)
      if outern ~= #n then r := concat(r::String,")_/_\("::String)
    r


  -- local function used by coerce to OutputForm
  -- convert variable or literal to OutputForm
  outputVarOrLit(a:Union(const : Record(val : Symbol),var : Record(str : String))) : OutputForm ==
     if (a case var) then return (a.var.str)::OutputForm
     if (a case const) then return (a.const.val)::OutputForm
     "error"::OutputForm

  -- output
  coerce(n : %) : OutputForm ==
    outerList:List OutputForm := []
    r:OutputForm := "("::OutputForm
    for outer in n for outern in 1..#n repeat
      innerList:List OutputForm := []
      for inner in outer for innern in (1..#outer) repeat
        r := hconcat(r::OutputForm,outputVarOrLit(inner))
        if innern ~= #outer then r := hconcat(r::OutputForm,"_\_/"::OutputForm)
      if outern ~= #n then r := hconcat(r::OutputForm,")_/_\("::OutputForm)
    hconcat(r,")"::OutputForm)::OutputForm

)abbrev domain LATJOFM LatticeJoinOfMeets
++ Author: Martin Baker
++ Date Created: Sept 2015
++ Date Last Updated: Sept 2015
++ Basic Operations:
++ Related Constructors: LatticeMeetOfJoins is complementry domain
++ Keywords: Logic Lattice Meet Join
++ Description: Infinite Lattice which is distributive.
++   Representation held as join of meets.
++ References:
++ http: //www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/

LatticeJoinOfMeets() : Exports == Implementation where

 NNI==> NonNegativeInteger
 PR ==> Record(rft : %, pout : NNI)
   ++ parse result includes term returned and new index
 ELEMENT ==> Union(_
         const : Record(val : Symbol), _
         var : Record(str : String) _
         )

 Exports == Join(BoundedDistributiveLattice, CoercibleTo(OutputForm)) with
  logicT : () -> %
    ++ construct true: a logical constant.
  logicF : () -> %
    ++ construct false (contradiction): a logical constant.
  variable:(v:String) -> %
    ++ construct a variable
  latticeJoinOfMeets:(e:ELEMENT) -> %
    ++ construct a lattice with one element
  emptyLattice:() -> %
    ++ construct an empty lattice
  empty?:(n:%) -> Boolean
    ++ true if empty
  meet : (ln : List %) -> %
    ++ meet of set of elements
  join : (ln : List %) -> %
    ++ join of set of elements
  redux : (n : %) -> %
    ++ attempt to simplify terms
  factor : (n : %) -> List %
    ++ splits n into a list of factors which must be true for the
    ++ whole to be true.
    ++ This assumes that the top level is already a set of factors
    ++ seperated by /\ otherwise the result will just be a list with
    ++ one entry: 'n'.
    ++ This is used when converting ILogic to types by using the
    ++ Curry-Howard isomorphism.
  deductions : (ln : List %) -> List %
    ++ assumes ln contains a list of factors which must be true for
    ++ the whole to be true (such as the list produced by factor).
    ++ From this deductions attemps to produce a list of other
    ++ proposition that must also be true by using modus ponens.
    ++ This is used to determine the returned type when converting
    ++ ILogic to types by using the Curry-Howard isomorphism.
  "=": (a:%, b:%) -> Boolean
    ++ returns true (boolean true) if intuitionisticLogic values
    ++ are the same.
    ++ Translates from Intuitionistic Logic to Boolean Logic
  opType : (n : %) -> Symbol
    ++ if this is a compound op then opType returns the type of
    ++ that op:
    ++ "IMPLY"::Symbol =implies
    ++ "AND"::Symbol=/\
    ++ "OR"::Symbol=\/
    ++ "NOT"::Symbol=~
    ++ "OTHER"::Symbol=not compound op
  getChildren : (n : %) -> List %
    ++ returns child nodes if this is a compound term
    ++ otherwise returns []
  atom? : (n : %) -> Boolean
    ++ returns true if this is an atom, that is a leaf node
    ++ otherwise return false if this is a compound term
  value : (n : %) -> Symbol
    ++ returns:
    ++   "T"::Symbol = T
    ++   "F"::Symbol = _|_
    ++   "E"::Symbol = error
    ++   "P"::Symbol = proposition
    ++   "C"::Symbol = compound
    ++ Constructs lambda term and bind any variables with the name provided
  toString : (n : %) -> String
    ++ creates a string representaion of this term and its sub-terms
  toStringUnwrapped : (n : %) -> String
    ++ similar to 'toString' but does not put outer compound terms
    ++ in brackets
  coerce : (n : %) -> OutputForm
    ++ output
  coerce:(n : %) -> LatticeMeetOfJoins
    ++ convert lattice from join-of-meets to meet-of-joins
  coerce:(n : LatticeMeetOfJoins) -> %
    ++ convert lattice from meet-of-joins to join-of-meets

 Implementation == add

  Rep := List(List(ELEMENT))
    ++ This domain is a distributive lattice, this allows us to
    ++ represent the lattice as a meet of joins.
    ++ So the inner list is a list of elements which are joined,
    ++ the outer list represents a meet of these joins.
    ++ The elements of this structure are constants or variables:
    ++ 1) const: Record(val: Symbol)
    ++   holds the true and false values:
    ++   "T"::Symbol = T
    ++   "F"::Symbol = _|_
    ++
    ++ 2) var: Record(str: String)
    ++   holds a proposition name


  -- Constructs a proposition
  proposition(s : String) : % == [[[[s]]]]

  -- literal constructors
  logicT() == [[[["T"::Symbol]]]]
  logicF() == [[[["F"::Symbol]]]]

  emptyLattice() == nil()$List(List(ELEMENT))

  -- construct a variable
  variable(v:String):% == [[[[v]]]]

  -- construct a lattice with one element
  latticeJoinOfMeets(e:ELEMENT):% ==
    [[e]]

  -- true if empty
  empty?(n:%):Boolean ==
    empty?(n)$Rep

  -- /\ returns the logical 'meet', e.g. 'and'.
  --
  -- simplification rules:
  -- ~x /\ x -> F
  -- x /\ ~x -> F
  -- x /\ x -> x
  -- F /\ x -> F
  -- x /\ F -> F
  -- x /\ T -> x
  -- T /\ x -> x
  --
  _/_\(a : %, b : %) ==
    if empty?(a) then return b
    if empty?(b) then return a
    r:List(List(ELEMENT)):=[]
    for innera in a repeat
      for innerb in b repeat
        termLeft:List(ELEMENT) := innera
        termRight:List(ELEMENT) := innerb
        term:=concat(termLeft,termRight)$List(ELEMENT)
        r:=concat(r,term)$List(List(ELEMENT))
    redux(r)


  -- \/ returns the logical 'join', e.g. 'or'.
  --
  -- simplification rules:
  -- T \/ x -> T
  -- x \/ T -> T
  -- x \/ x -> x
  -- x \/ _|_ -> x
  -- _|_ \/ x -> x
  --
  _\_/(a : %, b : %) ==
    if empty?(a) then return b
    if empty?(b) then return a
    redux(concat(a pretend Rep,b pretend Rep)$List(List(ELEMENT)))

  meet(ln : List %):% ==
    r:% := emptyLattice()
    for ele in ln repeat
      r := _/_\(r,ele)
    r

  join(ln : List %):% ==
    r:% := emptyLattice()
    for ele in ln repeat
      r := _\_/(r,ele)
    r

  -- local function used by removeDuplicatesInTerm which is used by
  -- redux to remove duplicates.
  -- Returns true if elements are equal.
  equalElements(a:ELEMENT,b:ELEMENT) :Boolean ==
    if (a case var) and (a case var) then
       return (a.var.str) = (b.var.str)
    if (a case const)  and (b case const) then
       return (a.const.val) = (b.const.val)
    false

  -- local function used by redux to remove duplicates, that is
  -- apply idempotence. We cannot use the removeDuplicates in List
  -- because ELEMENT does not have ATFINAG or BASTYPE.
  removeDuplicatesInTerm(n : List(ELEMENT)) : List(ELEMENT) ==
    r:List(ELEMENT) := nil()$List(ELEMENT)
    for e1 in n for ne1 in 1..#n repeat
      match:Boolean := false
      for e2 in n for ne2 in 1..#n repeat
        if e1=e2 and ne1<ne2 then match := true
      if not match then r:=concat(r,e1)
    r

  -- local function used by redux to remove duplicate lists.
  -- Returns true if lists are equal, that is contain the same elements
  -- (independant of order).
  equalTerms(a:List(ELEMENT),b:List(ELEMENT)) :Boolean ==
    if #a ~= #b then return false
    for a1 in a repeat
      found:Boolean := false
      for b1 in b repeat
        if equalElements(a1,b1) then found:= true
      if not found then return false
    true

  -- local function used by redux to apply absorbtion.
  -- Returns true if a is a sub-term of b.
  subTerm(a:List(ELEMENT),b:List(ELEMENT)) :Boolean ==
    if #a >= #b then return false
    for a1 in a repeat
      found:Boolean := false
      for b1 in b repeat
        if equalElements(a1,b1) then found:= true
      if not found then return false
    true

  -- Attempt to simplify terms
  --
  -- simplification rules:
  -- idempotenceMeet for all x: x /\ x -> x ()
  -- idempotenceJoin for all x: x \/ x -> x
  -- absorptionMeetOverJoin for all(x,y): x/\(x\/y)=x
  -- absorptionJoinOverMeet for all(x,y): x\/(x/\y)=x
  --
  -- TODO add rules for top and bottom
  --
  redux(n : %) : % ==
    r:List(List(ELEMENT)) := nil()$List(List(ELEMENT))
    for outer in n for outern in 1..#n repeat
      -- check for idempotence
      newinnerList:List(ELEMENT) := removeDuplicatesInTerm(outer)
      match:Boolean := false
      for inner in n for innern in 1..#n repeat
        if equalTerms(inner,outer) and innern<outern then match := true
      -- check for absorption
      isSubTerm:Boolean := false
      for inner in n repeat
        if subTerm(inner,outer) then isSubTerm := true
      if (not match) and (not isSubTerm) then r:=concat(r,newinnerList)$List(List(ELEMENT))
    --print hconcat([("redux"::OutputForm),(n::OutputForm),(","::OutputForm),((r pretend %)::OutputForm)])$OutputForm
    r

  -- splits n into a list of factors which must be true for the
  -- whole to be true.
  -- This assumes that the top level is already a set of factors
  -- seperated by /\ otherwise the result will just be a list with
  -- one entry: 'n'.
  -- This is used when converting ILogic to types by using the
  -- Curry-Howard isomorphism.
  factor(n : %) : List % ==
    [n]

  -- remove duplicates. Return elements of 'b' except those that are
  -- in 'a'
  -- I would use duplicate removal built into List but that only
  -- works when the list is defined over SETCAT
  removeDup(a : List %, b : List %) : List % ==
    a

  -- assumes ln contains a list of factors which must be true for
  -- the whole to be true (such as the list produced by factor).
  -- From this deductions attemps to produce a list of other
  -- proposition that must also be true by using modus ponens.
  -- This is used to determine the returned type when converting
  -- ILogic to types by using the Curry-Howard isomorphism.
  deductions(ln : List %) : List % ==
    ln

  -- if this is a compound op then opType returns the type of that op:
  -- "IMPLY"::Symbol =implies
  -- "AND"::Symbol=/\
  -- "OR"::Symbol=\/
  -- "NOT"::Symbol=~
  -- "OTHER"::Symbol=not compound op
  opType(n : %) : Symbol ==
    "OTHER"::Symbol

  -- returns true if this is an atom, that is a leaf node
  -- otherwise return false if this is a compound term
  atom?(n : %) : Boolean == false

  -- returns:
  --   "F"::Symbol = _|_
  --   "T"::Symbol = T
  --   "E"::Symbol = error
  --   "P"::Symbol = proposition
  --   "C"::Symbol = compound
  value(n : %) : Symbol ==
    "C"::Symbol

  -- returns child nodes if this is a compound term
  -- otherwise returns []
  getChildren(n : %) : List % ==
    [n]

  -- returns true (boolean true) if values
  -- are the same. The terms must match exactly not just be
  -- equivalent, that is x /\ 1 is not equal to x
  -- Translates from Intuitionistic Logic to Boolean Logic
  a = b ==
    false

  -- return string representation
  toString(n : %) : String ==
    a:String:=concat("(",toStringUnwrapped(n))
    a:String:=concat(a,")")
    a

  -- local function used by coerce to String
  -- convert variable or literal to String
  stringVarOrLit(a:Union(const : Record(val : Symbol),var : Record(str : String))) : String ==
     if (a case var) then return (a.var.str)::String
     if (a case const) then
       if (a.const.val) = "T"::Symbol then return "T"
       return "F"
     "error"

  -- similar to 'toString' but does not put outer compound terms
  -- in brackets
  toStringUnwrapped(n : %) : String ==
    outerList:List String := []
    r:String := ""
    for outer in n for outern in 1..#n repeat
      innerList:List String := []
      for inner in outer for innern in (1..#outer) repeat
        r := concat(r::String,stringVarOrLit(inner))
        if innern ~= #outer then r := concat(r::String,"_/_\"::String)
      if outern ~= #n then r := concat(r::String,")_\_/("::String)
    r


  -- local function used by coerce to OutputForm
  -- convert variable or literal to OutputForm
  outputVarOrLit(a:Union(const : Record(val : Symbol),var : Record(str : String))) : OutputForm ==
     if (a case var) then return (a.var.str)::OutputForm
     if (a case const) then return (a.const.val)::OutputForm
     "error"::OutputForm

  -- output
  coerce(n : %) : OutputForm ==
    outerList:List OutputForm := []
    r:OutputForm := "("::OutputForm
    for outer in n for outern in 1..#n repeat
      innerList:List OutputForm := []
      for inner in outer for innern in (1..#outer) repeat
        r := hconcat(r::OutputForm,outputVarOrLit(inner))
        if innern ~= #outer then r := hconcat(r::OutputForm,"_/_\"::OutputForm)
      if outern ~= #n then r := hconcat(r::OutputForm,")_\_/("::OutputForm)
    hconcat(r,")"::OutputForm)::OutputForm

  -- convert lattice from join-of-meets to meet-of-joins
  coerce(n : %) : LatticeMeetOfJoins ==
    r:LatticeMeetOfJoins := emptyLattice()
    for outer in n for outern in 1..#n repeat
      term:LatticeMeetOfJoins := emptyLattice()
      for inner in outer for innern in 1..#outer repeat
        ele:LatticeMeetOfJoins := latticeMeetOfJoins(inner)
        term := _/_\(term,ele)
        --print hconcat([("coerce:"::OutputForm),(ele::OutputForm),(term::OutputForm)])
      r:= _\_/(r,term)
    r

  -- convert lattice from meet-of-joins to join-of-meets
  coerce(n1 : LatticeMeetOfJoins):% ==
    r:% := emptyLattice()
    n:List(List(ELEMENT)) := n1 pretend List(List(ELEMENT))
    for outer in n for outern in 1..#n repeat
      term:% := emptyLattice()
      for inner in outer for innern in 1..#outer repeat
        ele:% := latticeJoinOfMeets(inner)
        term := _\_/(term,ele)
        --print hconcat([("coerce:"::OutputForm),(ele::OutputForm),(term::OutputForm)])
      r:= _/_\(r,term)
    r

)if false
\section{Example Structures}
)endif

)abbrev domain BITST BitStreamFrame
++ Author: Martin Baker
++ Description: An example of a frame taken from Vickers section 3.7
BitStreamFrame() : Exports == Impl where
    NNI==> NonNegativeInteger
    Exports ==> Join(Lattice,CoercibleTo(OutputForm), SetCategory) with
     starts : (index:List(Boolean)) -> %
      ++ construct bit stream
     starts : (str:String) -> %
      ++ construct bit stream by parsing string containing 0,1 and *

    Impl == add

     -- A single bitstream is coded as 'List Boolean', this is the
     -- bit sequence starting from the first bit.
     -- This representaion holds all allowable bitstreams
     -- or'd together as a list of bitstreams.
     Rep := List(List(Boolean))

     -- construct bit stream
     starts(index:List(Boolean)):% ==
       [index]
      
     -- construct bit stream by parsing string containing 0,1 and *
     starts(str:String):% ==
       res:List(Boolean) := []
       cs:List Character := entries(str)
       for c in cs repeat
         if c=char("0") then res:=concat(res,false)
         if c=char("1") then res:=concat(res,true)
       [res]

     -- returns the logical 'meet', e.g. 'and'.
     _/_\(a:%,b:%) : % ==
       res: List(List(Boolean)) := concat(a pretend List(List(Boolean)),b pretend List(List(Boolean)))$List(List(Boolean))
       res

     -- returns the logical 'join', e.g. 'or'.
     _\_/(a:%,b:%) : % ==
       res: List(List(Boolean)) := concat(a pretend List(List(Boolean)),b pretend List(List(Boolean)))$List(List(Boolean))
       res

     -- start of SetCategory definitions --

     hash(s : %) : SingleInteger == 0$SingleInteger

     -- return string representation
     -- I'm not sure how latex(s: %) is intended to be used but
     -- there is nothing specifically latex here, it just returns a
     -- string description of the graph.
     latex(n : %) : String ==
       -- s holds result that we are constructing
       s:String := ""
       s

     -- returns true if x equals y
     -- this is equality and not isomorphism
     -- that is it returns true only if exact index values and names are used
     -- in addition to the structure(arrows) being the same.
     _=(x : %, y : %) : Boolean ==
       if #x ~= #y then return false
       len:NNI := #x
       for i in 1..len repeat
         if x.i ~= y.i then return false
       true

     -- returns true if x is not equal to y
     _~_=(x : %, y : %) : Boolean == not(x = y)

     -- output
     coerce(s : %) : OutputForm ==
       cs:List OutputForm := []
       for row in s repeat
         r:List OutputForm := ["starts:"::OutputForm]
         for x in row repeat
           ro:OutputForm := "0"::OutputForm
           if x then ro := "1"::OutputForm
           r:= concat(r,ro)
           --r:= concat(r," "::OutputForm)
         c:OutputForm := hconcat(r)
         cs:= concat(cs,c)
       vconcat(cs)

--Copyright (c) 2015, Martin J Baker.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of Martin J Baker. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


)if false
\eject
\begin{thebibliography}{99}
For more details see:
[1] Topology Via Logic - Steven Vickers ISBN 0 521 57651 2
[2] J. Lambek, P. J. Scott 1988
     Introduction to Higher-Order Categorical Logic ISBN : 0521356539
     This book shows the relationship between mathematical logic and category
     theory. Although this is not used in the current code, it suggests
     a promising generalisation.
[3] I have put a fuller explanation of this code here:
http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.htm
\end{thebibliography}
\end{document}
)endif

