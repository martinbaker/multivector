)if false
\documentclass{article}
\usepackage{axiom}
\usepackage{url}
\begin{document}
\title{Simplicial Complex Structures}
\author{Martin J Baker}
\maketitle
\begin{abstract}

I would like to code topological spaces in a finite way, simplicial
complexes allow us to do this in a systematic way.

Simplicial Complexes may not be the most efficient tool, for cutting
edge topology, in terms the most economical representation. However,
for computer-science and combinatorial uses, simplicial complexes may
be the best tool because of their combinatorial simplicity.
-- paraphrased from [1].

I have put a fuller explanation of this code here:
\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/simplex/}
\end{abstract}
\section{Related Code}

\section{Introduction}
The representation holds whole Simplicial Complex. This consists of
a vertex set, represented as a vertex list so that we can index it.
Also a list of simplices (that is n-dimensional faces). each simplice
is an array of vertex indexes. So each simplice is a subset of the
vertex set.

If the dimension given for the simplicial complex is 'k' then:
\begin{itemize}
\item The number of elements in each vertex = k.
\item The maximum number of vertexes in each simplice = k + 1.
\end{itemize}
For example, a trangle has 3 vertexes, so it is maximum size face in 3-1=2 dimensions.
\begin{table}[]
\label{Dimensions}
\begin{tabular}{lll}
dimension \ vertex \ simplice - (faces) \\
0 \ 0 elements \ point \\
1 \ 1 element vertex \ line - (edge) \\
2 \ 2 element vertex \ triangle \\
3 \ 3 element vertex \ tetrahedron \\
n \ n element vertex \ simplice \\
\end{tabular}
\end{table}

\section{Abstract Simplicial Complex vs. Simplicial Complex}
If we apply the restrictions explained so far we have an abstract simplicial complex,
However, for a simplicial complex there are some additional conditions.

An Abstract Simplicial Complex is purely combinitorial, that is we don't need the
geometric information.

Therefore the AbstractSimplicialComplex domain does not need coordinates for the
verticies and they can be denoted by symbols.

\section{Operations on Simplicial Complexes}

Closure - closure of X contains X and all the faces touching X
Star -
Link -
Join - We will call it a SimplicialJoin since it is not related to joins in lattices.

\section{Simplicial Maps}
Allow edges to be collapsed into vertices.

\section{Oriented Simplexes Maps}

\section{Vertex Set Code}
We want an indexed set of points, the simplest way to do the indexing is to use
'List' instead of 'Set'.

The vertices themselves may be either:
\begin{itemize}
\item literal coordinates.
\item symbolic vertex names.
\item numeric indexes.
\end{itemize}
So we cave a category that can represent any of these types and then a domain for
each type.
)endif

)abbrev category VERTS VertexSet
++ Author: Martin Baker
++ Description:
++   An indexed set of verticies
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/simplex/
++ Related Domains:
++ Date Created: Dec 2015
++ Date Last Updated: Dec 2015
VertexSet() : Category == Definition where
 NNI==> NonNegativeInteger
 Definition ==> SetCategory() with
   maxFaces:(a:%) -> NNI
     ++ return the maximum number of faces

)if false
This is VertexSet for a geometric simplicial complex. In this case each vertex is
represented by a point in some underlying space.

We want to represent an indexed set of points, the simplest way to do this is to
use a list of points.
)endif

)abbrev domain VERTSC VertexSetCoord
++ Author: Martin Baker
++ Description: 
++   An indexed set of verticies represented as coordinates.
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/simplex/geometric/
++ Date Created: Dec 2015
++ Date Last Updated: Dec 2015
++ Basic Operations:
++ Related packages:
++ Related categories:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples: 
++ References:

VertexSetCoord(F:Field) : Exports == Impl where
  NNI==> NonNegativeInteger
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> VertexSet() with
    vertexSet: (v:List(PrimitiveArray(F))) -> %
     ++ constructor where the vertex set is supplied

    dimension:(a:%) -> NNI
     ++ return dimension of underlying space

  Impl ==> add

   -- Representation holds the vertex set, represented as a
   -- vertex list so that we can index it.
   Rep := List(PrimitiveArray(F))

   -- constructor where the vertex set is supplied
   vertexSet(v:List(PrimitiveArray(F))):% ==
     v

   -- return dimension of underlying space
   -- in this case assume its how many numbers used to specify a point
   dimension(a:%):NNI ==
     res:NNI := 0
     for b in a repeat
       if #b > res then res:=#b
     res

   -- return the maximum number of faces
   maxFaces(a:%):NNI ==
     #a

   -- output
   coerce(s : %) : OutputForm ==
     if empty?(s) then return bracket(empty()$OutputForm)
     mat:List List OutputForm := empty()$List(List(OutputForm))
     for a in s repeat
       row:List OutputForm := empty()$List(OutputForm)
       if empty?(members(a))$List(F)
         then
           row := concat(row,bracket(empty()$OutputForm))$List(OutputForm)
         else
           for b in members(a) repeat
             row := concat(row,b::OutputForm)$List(OutputForm)
       mat := concat(mat,row)
     matrix(mat)

)if false
This is VertexSet for an abstract simplicial complex. In this case each vertex is
represented by an index without any underlying coordinates.

)endif

)abbrev domain VERTSA VertexSetAbstract
++ Author: Martin Baker
++ Description: 
++   An indexed set of abstract verticies without real coordinates.
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/simplex/
++ Date Created: Dec 2015
++ Date Last Updated: Dec 2015
++ Basic Operations:
++ Related packages:
++ Related categories:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples: 
++ References:

VertexSetAbstract(max) : Exports == Impl where
  NNI==> NonNegativeInteger
  max:NNI
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> VertexSet() with
    vertexSeta: (d:NNI) -> %
     ++ constructor for abstract vertex set

  Impl ==> add

   -- Representation holds the vertex set, represented as a
   -- vertex list so that we can index it.
   Rep := NNI

   -- constructor for abstract vertex set
   vertexSeta(d:NNI):% ==
     d

   -- return the maximum number of faces
   maxFaces(a:%):NNI ==
     max

   -- output
   coerce(s : %) : OutputForm == outputForm(s pretend NNI)$OutputForm
 
)if false

)endif

)abbrev domain SIMPC FiniteSimplicialComplex
++ Author: Martin Baker
++ Description: 
++   A Finite Simplicial Complex
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/simplex/
++ Date Created: Dec 2015
++ Date Last Updated: Dec 2015
++ Basic Operations:
++ Related packages:
++ Related categories:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples: 
++ References:

FiniteSimplicialComplex(VS:VertexSet) : Exports == Impl where
  NNI==> NonNegativeInteger
  PAIR ==> Record(fst:NNI,sec:NNI)
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> SetCategory() with
    simplicialComplex: (f:List(List(NNI))) -> %
     ++ constructor where the simplices are supplied
    boundaryLine: (s:%) -> List(List(NNI))
     ++ returns line around area assuming simplexes are all wound in same direction

  Impl ==> add

   -- Representation holds whole Simplicial Complex. This consists of
   -- a vertex set, here represented as a vertex list so that we can
   -- index it.
   -- Also a list of simplices (that is n-dimensional faces). each
   -- simplice is an array of vertex indexes.
   -- So each simplice is a subset of the vertex set.
   Rep := List(List(NNI))

   -- constructor where the vertex set and simplices are supplied
   simplicialComplex(f:List(List(NNI))):% == f

   -- returns line around area assuming simplexes are all wound in same direction
   -- TODO try to put the segments on the line in order
   boundaryLine(s:%):List(List(NNI)) ==
     res:List(List(NNI)) := empty()$List(List(NNI))
     lines:List(PAIR) := empty()$List(PAIR)
     for simp in s repeat
       firstEntry:NNI := 0
       for n in 1..(#simp) repeat
         if n = 1 then firstEntry := simp.n
         if n = #simp then
           line:PAIR := construct(simp.n,firstEntry)$PAIR
           lines := concat(lines,line)$List(PAIR)
         if n < #simp then
           line:PAIR := construct(simp.n,simp.(n+1))$PAIR
           lines := concat(lines,line)$List(PAIR)
     cancel:List(PAIR) := empty()$List(PAIR)
     for x in lines repeat
       pair:List(NNI) := [x.fst,x.sec]
       if member?(x,cancel)
         then
           cancel := remove(x,cancel)$List(PAIR)
         else
           rev:PAIR := construct(x.sec,x.fst)$PAIR
           -- TODO should really check that segment has not already been
           -- canceled
           if member?(rev,lines)
             then
               cancel := concat(cancel,rev)$List(PAIR)
             else
               res := concat(res,pair)$List(List(NNI))
     res

   -- output
   coerce(s : %) : OutputForm ==
     if empty?(s) then return bracket(empty()$OutputForm)
     mat:List List OutputForm := empty()$List(List(OutputForm))
     for a in s repeat
       row:List OutputForm := empty()$List(OutputForm)
       if empty?(a)$List(NNI)
         then
           row := concat(row,bracket(empty()$OutputForm))$List(OutputForm)
         else
           for b in a repeat
             row := concat(row,outputForm(b)$OutputForm)$List(OutputForm)
       mat := concat(mat,row)
     matrix(mat)


--Copyright (c) 2015, Martin J Baker.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of Martin J Baker. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

)if false
\eject
\begin{thebibliography}{99}
For more details see:
[1] Mathematics++ Kantor,Matousek,Samal 2015  ISBN 978-1-4704-2261-5
      Chapter 6 - Topology
[2] Graphs, Surfaces and Homology, Peter Giblin 2010 ISBN 987-0-521-15405-5

[3] Wikipedia
\url{http://https://en.wikipedia.org/wiki/Simplicial_complex/}

[4] Finite simplicial complexes in Sage
\url{http://http://doc.sagemath.org/html/en/reference/homology/sage/homology/simplicial_complex.html}

[5] I have put a fuller explanation of this code here:
\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/simplex/}
\end{thebibliography}
\end{document}
)endif

