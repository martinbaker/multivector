)if false
\documentclass{article}
\usepackage{axiom}
\usepackage{url}
\begin{document}
\title{Algebraic Topology Structures}
\author{Martin J Baker}
\maketitle
\begin{abstract}

I would like to code topological spaces in a finite way, simplicial
complexes and delta complexes allow us to do this in a systematic way.

I have put a fuller explanation of this code here:
\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/}
\end{abstract}
\section{Related Code}

Simplicial Complexes are a generalisation of graph theory as implemented here:
https://github.com/fricas/fricas/blob/master/src/algebra/graph.spad
I will implement coercions from graphs to simplicial complexes.

Delta Complexes are defined by a chain of 'face maps', These can be represented
by a sequence of matricies, in this linear algebra form the homology groups can
be calculated from the Smith normal form:
\url{https://github.com/fricas/fricas/blob/master/src/algebra/smith.spad}
\url{https://github.com/fricas/fricas/blob/master/src/algebra/smith2.spad}

This linear algebra form seems somehow related to regular triangular sets
(regular chains) not exactly sure how?
\url{https://github.com/fricas/fricas/blob/master/src/algebra/regset.spad}
\url{https://github.com/fricas/fricas/blob/master/src/algebra/sregset.spad}
\url{https://github.com/fricas/fricas/blob/master/src/algebra/zerodim.spad}

Zariski topology:
The Zariski topology of an algebraic variety is the topology whose closed sets
are the algebraic subsets of the variety.
\url{https://github.com/fricas/fricas/blob/master/src/algebra/zerodim.spad}
\url{https://github.com/fricas/fricas/blob/master/src/algebra/regset.spad}

I have not yet implemented cohomology but it seems to be related to:
DeRhamComplex:
\url{https://github.com/fricas/fricas/blob/master/src/algebra/derham.spad}
DifferentialGeometry
\url{http://axiom-wiki.newsynthesis.org/SandBoxDifferentialGeometry}

\section{Introduction}

\section{Simplicial Complexes}

The representation holds whole Simplicial Complex. This consists of
a vertex set, represented as a vertex list so that we can index it.
Also a list of simplices (that is n-dimensional faces). each simplice
is an array of vertex indexes. So each simplice is a subset of the
vertex set.

If the dimension given for the simplicial complex is 'k' then:
\begin{itemize}
\item The number of elements in each vertex = k.
\item The maximum number of vertexes in each simplice = k + 1.
\end{itemize}
For example, a trangle has 3 vertexes, so it is maximum size face in 3-1=2 dimensions.
\begin{table}[]
\label{Dimensions}
\begin{tabular}{lll}
dimension \ vertex \ simplice - (faces) \\
0 \ 0 elements \ point \\
1 \ 1 element vertex \ line - (edge) \\
2 \ 2 element vertex \ triangle \\
3 \ 3 element vertex \ tetrahedron \\
n \ n element vertex \ simplice \\
\end{tabular}
\end{table}

\section{Abstract Simplicial Complex vs. Simplicial Complex}
If we apply the restrictions explained so far we have an abstract simplicial complex,
However, for a simplicial complex there are some additional conditions.

An Abstract Simplicial Complex is purely combinitorial, that is we don't need the
geometric information.

Therefore the AbstractSimplicialComplex domain does not need coordinates for the
verticies and they can be denoted by symbols.

\section{Operations on Simplicial Complexes}

Closure - closure of X contains X and all the faces touching X
Star -
Link -
Join - We will call it a SimplicialJoin since it is not related to joins in lattices.

\section{Simplicial Maps}
Allow edges to be collapsed into vertices.

\section{Oriented Simplexes Maps}

\section{Vertex Set Code}
We want an indexed set of points, the simplest way to do the indexing is to use
'List' instead of 'Set'.

The vertices themselves may be either:
\begin{itemize}
\item literal coordinates.
\item symbolic vertex names.
\item numeric indexes.
\end{itemize}
So we cave a category that can represent any of these types and then a domain for
each type.
)endif

)abbrev category VERTS VertexSet
++ Author: Martin Baker
++ Description:
++   An indexed set of vertices
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/
++ Related Domains: VertexSetAbstract, VertexSetCoord
++ Date Created: Dec 2015
++ Date Last Updated: Feb 2016
VertexSet() : Category == Definition where
 NNI==> NonNegativeInteger
 Definition ==> SetCategory() with
   maxFaces:(a:%) -> NNI
     ++ return the maximum number of faces
   setMaxFaces:(a:%,b:NNI) -> Void
     ++ set the maximum number of faces
   join:(a:%,b:%) -> %
     ++ disjoint union of two vertex sets
   prod:(a:%,b:%) -> %
     ++ Cartesian product of two vertex sets

)if false
This is VertexSet for a geometric simplicial complex. In this case each vertex is
represented by a point in some underlying space.

We want to represent an indexed set of points, the simplest way to do this is to
use a list of points.
)endif

)abbrev domain VERTSC VertexSetCoord
++ Author: Martin Baker
++ Description: 
++   An indexed set of vertices represented as coordinates.
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/geometric/
++ Date Created: Dec 2015
++ Date Last Updated: Feb 2016
++ Basic Operations:
++ Related packages:
++ Related categories: VertexSet
++ Related Domains: VertexSetAbstract
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples: 
++ References:

VertexSetCoord(F:Field) : Exports == Impl where
  NNI==> NonNegativeInteger
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> VertexSet() with
    vertexSet: (v:List(PrimitiveArray(F))) -> %
     ++ constructor where the vertex set is supplied

    dimension:(a:%) -> NNI
     ++ return dimension of underlying space

  Impl ==> add

   -- Representation holds the vertex set, represented as a
   -- vertex list so that we can index it.
   Rep := List(PrimitiveArray(F))

   -- constructor where the vertex set is supplied
   vertexSet(v:List(PrimitiveArray(F))):% ==
     v

   -- return dimension of underlying space
   -- in this case assume its how many numbers used to specify a point
   dimension(a:%):NNI ==
     res:NNI := 0
     for b in a repeat
       if #b > res then res:=#b
     res

   -- return the maximum number of faces
   maxFaces(a:%):NNI ==
     #a

   -- set the maximum number of faces
   setMaxFaces(a:%,b:NNI):Void ==
     if #a <= b then return void
     error "too few coordinates"
     void

   -- disjoint union of two vertex sets
   join(a:%,b:%):% ==
     concat(a,b)

   -- Cartesian product of two vertex sets
   prod(a:%,b:%):% ==
     a

   -- output
   coerce(s : %) : OutputForm ==
     if empty?(s) then return bracket(empty()$OutputForm)
     mat:List List OutputForm := empty()$List(List(OutputForm))
     for a in s repeat
       row:List OutputForm := empty()$List(OutputForm)
       if empty?(members(a))$List(F)
         then
           row := concat(row,bracket(empty()$OutputForm))$List(OutputForm)
         else
           for b in members(a) repeat
             row := concat(row,b::OutputForm)$List(OutputForm)
       mat := concat(mat,row)
     matrix(mat)

)if false
This is VertexSet for an abstract simplicial complex. In this case each vertex is
represented by an index without any underlying coordinates.

)endif

)abbrev domain VERTSA VertexSetAbstract
++ Author: Martin Baker
++ Description: 
++   An indexed set of abstract vertices without real coordinates.
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/
++ Date Created: Dec 2015
++ Date Last Updated: Feb 2016
++ Basic Operations:
++ Related packages:
++ Related categories: VertexSet
++ Related Domains: VertexSetCoord
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:

VertexSetAbstract() : Exports == Impl where
  NNI==> NonNegativeInteger
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> VertexSet() with
    vertexSeta: (d:NNI) -> %
     ++ constructor for abstract vertex set

  Impl ==> add

   -- Representation holds number of vertices, it is wrapped in a Reference
   -- because, otherwise, it would be immutable.
   Rep := Reference(NNI)

   -- constructor for abstract vertex set
   vertexSeta(d:NNI):% ==
     ref(d)

   -- return the maximum number of faces
   maxFaces(a:%):NNI ==
     deref(a)

   -- set the maximum number of faces
   setMaxFaces(a:%,b:NNI):Void ==
     setref(a,b)
     void

   -- disjoint union of two vertex sets
   join(a:%,b:%):% ==
     ref(deref(a)+deref(b))

   -- product of two vertex sets
   prod(a:%,b:%):% ==
     ref(deref(a)*deref(b))

   -- output
   coerce(s : %) : OutputForm == outputForm(deref(s) pretend NNI)$OutputForm
 
)if false
Oriented Facet.

Holds single vertex,edge,triangle...
Is indexed, that is it does not hold actual vertices but indexes which
can be used to reference them.

To allow facets to be checked for equality indexes are stored in order
)endif

)abbrev domain OFACET OrientedFacet
++ Author: Martin Baker
++ Description: 
++   A single vertex,edge,triangle...
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/
++ Date Created: March 2016
++ Date Last Updated: March 2016
++ Basic Operations:
++ Related packages:
++ Related categories:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:

OrientedFacet() : Exports == Impl where
  NNI==> NonNegativeInteger
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> Join(SetCategory(),OrderedSet()) with
    orientedFacet: (mul:Integer,fac:List(NNI)) -> %
     ++ constructor for oriented facet
    order:(orf:%) -> NNI
     ++ number of vertices
    getIndexes:(orf:%) -> List(NNI)
     ++ returns indexes in face
    getMult:(orf:%) -> Integer
     ++ returns multipier of face
    setMult! :(orf:%,m:Integer) -> %
     ++ sets multipier of face
    delta:(orf:%) -> List(%)
     ++ boundary
    allSubsets:(orf:%) -> List(%)
     ++ allSubsets
    allSubsets:(orf:%,len:NNI) -> List(%)
     ++ allSubsets of a given length
    isSubsetOf? :(sa:%,sb:%) -> Boolean
     ++ returns true if face 'b' is contained in face 'a'.
    position:(e:%,lst:List(%)) -> Integer
     ++ return index of e in lst. Index will be negative if e has
     ++ negative multiplier.
    subtract:(sa:%,sb:%) -> %
     ++ used by link. Returns face 'a' minus the verticies in face 'b'.
    addVertex:(sa:%,v:NNI)-> %
     ++ used by cone. Adds a vertex to face.
    empty? :(sa:%) -> Boolean
     ++ is empty if it contains no verticies or if multipier is zero

  Impl ==> add

   -- A facet is a list of indexes (ordered)
   -- mul is usually 1 or -1 to reverse direction.
   -- other multipliers are not usually valid but can be used temporarily
   -- to count windings.
   Rep := Record(mul:Integer,fac:List(NNI))

   -- constructor for oriented facet
   orientedFacet(mul:Integer,fac:List(NNI)):% ==
     if first(fac) > last(fac) then mul:= -mul
     [mul,sort(fac)]

   -- number of vertices
   order(orf:%):NNI ==
     facet:List(NNI) := orf.fac
     #facet

   -- is empty if it contains no verticies or if multipier is zero
   empty?(orf:%):Boolean ==
     if order(orf)=0 then return true
     orf.mul =0

   -- returns indexes in face
   getIndexes(orf:%):List(NNI) ==
     orf.fac

   -- returns multipier of face
   getMult(orf:%):Integer ==
     orf.mul

   -- sets multipier of face
   setMult!(orf:%,m:Integer):% ==
     orf.mul := m
     orf

   -- boundary
   delta(orf:%):List(%) ==
     facet:List(NNI) := orf.fac
     revFacet:List(NNI) := reverse(facet) -- reverse outer list to get in numeric order
     mult:Integer := orf.mul
     res:List(%) := empty()$List(%)
     even:Boolean := false
     for x in revFacet repeat
       r:List(NNI) := remove(x,facet)
       m:Integer := if even then -mult else mult
       even := not even
       r1:% := orientedFacet(m,r)
       res:=concat(res,r1)$List(%)
     res

   -- local function to add if new
   addIfNew(lst:List(%),orf:%):List(%) ==
     if member?(orf,lst)$List(%) then return lst
     concat(lst,orf)

   -- local function to add if new
   addIfNew2(lst:List(%),orfs:List(%)):List(%) ==
     res:List(%) := copy(lst)
     for orf in orfs repeat
       if member?(orf,res)$List(%) then
         res := concat(res,orf)
     res

   -- allSubsets
   allSubsets(orf:%):List(%) ==
     --print("allSubsets("::Symbol << orf << ")"::Symbol)
     facet:List(NNI) := orf.fac
     mult:Integer := orf.mul
     res:List(%) := empty()$List(%)
     if order(orf)<1 then return res
     --even:Boolean := false
     for x in facet repeat
       --print("allSubsets x="::Symbol << x << " in facet="::Symbol << facet)
       r:List(NNI) := remove(x,facet)
       --m:Integer := if even then -mult else mult
       --even := not even
       r1:% := orientedFacet(1,r)
       res:=addIfNew(res,r1)
       if order(r1)>1 then
         res:=addIfNew2(res,allSubsets(r1))
     --print("allSubsets of"::Symbol << orf << " result="::Symbol << res)
     res

   -- allSubsets of a given length
   allSubsets(orf:%,len:NNI):List(%) ==
     --print("allSubsets("::Symbol << orf << ","::Symbol << len << ")"::Symbol)
     res:List(%) := allSubsets(orf)
     --print("allSubsets res="::Symbol << res)
     res2:List(%) := empty()$List(%)
     for y in res repeat
       if order(y)=len then
         res2:=concat(res2,y)$List(%)       
     --print("allSubsets result="::Symbol << res2)
     res2

   -- local function, used by link, which returns true if face 'b' is
   -- contained in face 'a'.
   isSubsetOf?(sa:%,sb:%):Boolean ==
     all:List(%) := allSubsets(sb)
     for vertex in all repeat
       if vertex=sa then return true
     --print("isSubsetOf?("::Symbol << sa << ","::Symbol << sb << ")=true"::Symbol)
     false

   -- used by link. Returns face 'a' minus the verticies in face 'b'.
   subtract(sa:%,sb:%):% ==
     --print("subtract("::Symbol << sa << ","::Symbol << sb << ")="::Symbol << setDifference(sb,sa)$SIMPLEX)
     lst:List(NNI) := setDifference(sb.fac,sa.fac)$List(NNI)
     [1,lst]

   -- return index of e in lst. Index will be negative if e has
   -- negative multiplier.
   position(e:%,lst:List(%)):Integer ==
     m:Integer := e.mul
     neg:Boolean := (m<0)
     e2 := copy(e)
     e2.mul := 1
     i := position(e2,lst)$List(%)
     if neg then i:= -i
     i

   -- used by cone. Adds a vertex to face.
   addVertex(sa:%,v:NNI):% ==
    f:List(NNI) := sa.fac
    f := concat(f,v)
    orientedFacet(1,f)
    
   -- less than Local
   -- calls itself recursivly
   ltLocal(a:List(NNI),b:List(NNI)):Boolean ==
     if a=b then return false
     if ((#a) < 1) then return true -- if lists are different lengths then shortest first
     if ((#b) < 1) then return false
     a1:NNI := a.first
     b1:NNI := b.first
     if a1<b1 then return true
     if a1>b1 then return false
     if ((#a) < 2) then return true -- if lists are different lengths then shortest first
     if ((#b) < 2) then return false
     ltLocal(a.rest,b.rest)

   -- less than
   -- define an order so we can sort lists
   ((ain : %) < (bin : %)) : Boolean ==
     --"<"(ain:%,bin:%):Boolean ==
     --print("<("::Symbol << ain << ","::Symbol << bin << ")"::Symbol)
     a:List(NNI) := ain.fac
     b:List(NNI) := bin.fac
     ltLocal(a,b)

   -- less than or equal
   -- define an order so we can sort lists
   ((ain : %) <= (bin : %)) : Boolean ==
     --"<="(ain:%,bin:%):Boolean ==
     --print("<=("::Symbol << ain << ","::Symbol << bin << ")"::Symbol)
     a:List(NNI) := ain.fac
     b:List(NNI) := bin.fac
     if a=b then return true
     ltLocal(a,b)

   -- Returns true if x equals y.
   -- Assumes indexes are in order as this is forced by constructor.
   _=(a : %, b : %) : Boolean ==
     if a.mul ~= b.mul then return false
     a.fac = b.fac

   -- output
   coerce(s : %) : OutputForm ==
     prefix:OutputForm := empty()$OutputForm
     if (s.mul) ~= 1 then
       prefix:=(s.mul)::OutputForm
       prefix:=hconcat(prefix,("*")::Symbol::OutputForm)
     if (s.mul) = -1 then prefix:=("-")::Symbol::OutputForm
     elements:List(OutputForm) := [x::OutputForm for x in s.fac]
     body:OutputForm := paren(elements)
     hconcat(prefix,body)

)if false
This representation defines faces, of any dimension, by their vertices. This is an
efficient way to define them.
As an example consider the representation for a single tetrahedron:
The representation would be: (1,2,3,4)
There is an alternative representation later.
)endif

)abbrev domain SIMPC FiniteSimplicialComplex
++ Author: Martin Baker
++ Description: 
++   A Finite Simplicial Complex
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/
++ Date Created: Dec 2015
++ Date Last Updated: March 2016
++ Basic Operations: star, link, cone, product
++ Related packages:
++ Related categories:
++ Related Domains: DeltaComplex is an alternative representation
++    which is less compact but allows edges, triangles, etc to be indexed.
++ Also See:
++ AMS Classifications:
++ Keywords: topology, finite, simplicial, complex, edge, triangle
++ Examples:
++ References:

FiniteSimplicialComplex(VS:VertexSet) : Exports == Impl where
  NNI==> NonNegativeInteger
  PAIR ==> Record(fst:NNI,sec:NNI)
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> SetCategory() with
    simplicialComplex: (v:VS,f:List(List(NNI))) -> %
     ++ constructor where the simplices are supplied
    simplicialComplex: (v:VS) -> %
     ++ construct empty simplex
    addSimplex: (a:%,f:OrientedFacet) -> %
     ++ add simplex
    grade: (s:%) -> List(List(OrientedFacet))
     ++ a function to grade simplexes according to their lengths.
     ++ This nests the lists according to their length.
     ++ It starts with edges then triangles and so on.
    sort:(s:%) -> %
     ++ sort
    addImpliedFaces:(s:%) -> List(List(OrientedFacet))
     ++ a function to take a set of faces and add those that are implied
     ++ by the simplecicalComplex conventions (if they don't already exist).
     ++ For example, if the input is a triangle ((1,2,3)) then we would add
     ++ its edges ((1,2),(1,3), and (2,3)).
--    boundaryLine: (s:%) -> %
     ++ returns line around area assuming simplexes are all wound in same direction
     ++ For more information about such topological functions see this page:
     ++ http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/topo/
    delta:(s:%) -> %
     ++ Step down to the next lower dimension, this is like hollowing out the complex.
     ++ It takes the highest dimension entries and replaces them with their boundaries,
     ++ cancelling out where it can.
    star:(s:%,simplex:OrientedFacet) -> %
     ++ The 'star' of a simplicial complex and a vertex contains only the simplexes
     ++ of s which include vertex 'v'.
    link:(s:%,simplex:OrientedFacet) -> %
     ++ The 'link' of a simplicial complex and a vertex contains the boundary of the
     ++ simplexes of s which include vertex 'v'.
    cone:(s:%,vertex:NNI) -> %
     ++ The 'cone' of a simplicial complex is formed by adding the vertex to every
     ++ facet.
     ++ 'vertex' should not already be included in existing faces, this is not checked
     ++ and so will lead to simplexed with duplicate verticies.
    simplicialJoin:(a:%,b:%) -> %
     ++ Forms disjoint union of two simplicial complexes.
    product:(a:%,b:%) -> %
     ++ Forms product of two simplicial complexes.
    oneSkeleton:(s:%) -> DirectedGraph(NNI)
     ++ generates graph AKA 1-skeleton
    fundamentalGroup:(s:%) -> GroupPresentation
     ++ Generates fundamental group from this simplicial complex.
     ++ This works by converting to a DeltaComplex and then generating the
     ++ fundamentalGroup from that. This is not the most efficient method
     ++ because the conversion generates lots of higher order faceMaps
     ++ which are not used.
     ++ TODO write a faster implemetation which only generates edge and 
     ++ triangle faceMaps.
    homology:(a:%) -> List(Matrix(Integer))
     ++ calculate homology using SmithNormalForm

    coerce:(s:%) -> DeltaComplex(VS)
     ++ coerce to DeltaComplex

  Impl ==> add

   -- Representation holds whole Simplicial Complex. This consists of
   -- a vertex set, here represented as a vertex list so that we can
   -- index it.
   -- Also a list of simplices (that is n-dimensional faces). each
   -- simplice is an array of vertex indexes.
   -- So each simplice is a subset of the vertex set.
   -- where:
   --  VS is a list of verticies in whatever form we are using.
   --  NNI is an index.
   --  The inner list represents an individual simplex.
   --  The outer list holds a list of simplexes.
   Rep := Record(VERTSET:VS,SIMP:List(OrientedFacet))

   -- constructor where the vertex set and simplices are supplied
   simplicialComplex(v:VS,fs:List(List(NNI))):% ==
     res:List(OrientedFacet) := empty()$List(OrientedFacet)
     for f in fs repeat
       res := concat(res,orientedFacet(1,f))
     [v,res]

   -- construct empty simplex
   simplicialComplex(v:VS):% ==
     res:List(OrientedFacet) := empty()$List(OrientedFacet)
     [v,res]

   -- add simplex
   addSimplex(a:%,f:OrientedFacet):% ==
     res:List(OrientedFacet) := a.SIMP
     -- check for duplicates
     found:Boolean:=false
     for orf in res repeat
       if getIndexes(orf)=getIndexes(f) then
         m:Integer := getMult(orf)+getMult(f)
         setMult!(orf,m)
         found:=true
     if not found then
       res := concat(res,f)
     -- look for empty faces
     res2:List(OrientedFacet) := empty()$List(OrientedFacet)
     for orf in res repeat
       if getMult(orf) ~= 0 then
         res2 := concat(res2,orf)     
     [a.VERTSET,res2]

   -- A function to grade simplexes according to their lengths.
   -- This nests the lists according to their length.
   -- It starts with verticies then edges then triangles and so on.
   grade(s:%):List(List(OrientedFacet)) ==
     simp:List(OrientedFacet) := s.SIMP
     maxGrade:NNI := 0
     for face in simp repeat
       if order(face) > maxGrade then maxGrade := order(face)
     res:List(List(OrientedFacet)) := empty()$List(List(OrientedFacet))
     if maxGrade < 2 then return res
     for a in 2..maxGrade repeat
       res := concat(res,empty()$List(OrientedFacet))
     for face in simp repeat
       gr:Integer := order(face) - 1
       if gr > 0 then
         res.gr := concat(res.gr,face)
     res     

   -- sort faces to be in numeric order
   sort(s:%):% ==
     v:VS := s.VERTSET
     fs:List(OrientedFacet) := s.SIMP -- list of faces
     [v,sort(fs)]

   -- a local function to return a list where each entry:
   -- i) is a permutation of the input list
   -- ii) contains integers in ascending order
   -- iii) is of the specified length
   -- TODO this is in both simplicial and delta complexes so need to find common
   -- home for it.
   orderedPermutation(lst:List(Integer),len: NNI):List(List(Integer)) ==
     if len < 1 then return empty()$List(List(Integer))
     if len > #lst then return empty()$List(List(Integer))
     if len = #lst then return [lst]
     reslt:List(List(Integer)) := empty()$List(List(Integer))
     if len=1 then
       for y in lst repeat
         reslt := concat(reslt,[y])
       return reslt  
     fst:Integer := lst.first
     rst:List(Integer) := lst.rest
     -- in the next line I probably should use 'subtractifcan' rather
     -- than using pretend but it can never be negative due to the tests
     -- at the start of this function.
     for x in orderedPermutation(rst,(len-1) pretend NNI) repeat
       r1:List(Integer) := concat(fst,x)
       -- r1 holds a permutations starting with fst
       reslt := concat(reslt,r1)
     -- now we have combinations staring with fst
     -- so we just have to add the rest
     reslt := concat(reslt,orderedPermutation(rst,len))
     reslt

   -- local function used in listUnion in addImpliedFaces
   -- TODO recognise all permutations of b, not just b and its reverse
   isNewFace?(a:List(OrientedFacet),b:OrientedFacet):Boolean ==
     --print("isNewFace?("::Symbol << a << ","::Symbol << b << ")"::Symbol)
     if member?(b,a)$List(OrientedFacet) then return false
     --if member?(reverse(b),a)$List(OrientedFacet) then return false
     true

   -- local function used in addImpliedFaces
   listUnion(a:List(OrientedFacet),b:List(OrientedFacet)):List(OrientedFacet) ==
     res:List(OrientedFacet) := empty()$List(OrientedFacet)
     for a1 in a repeat
       res:=concat(res,a1)
     for b1 in b repeat
       if isNewFace?(a,b1) then
         res:=concat(res,b1)
     --print("listUnion("::Symbol << a << ","::Symbol << b << ") = "::Symbol << res)
     res

   -- A function to take a set of faces and add those that are implied
   -- by the simplicial complex conventions (if they don't already exist).
   -- For example, if the input is a triangle ((1,2,3)) then we would add
   -- its edges ((1,2),(1,3), and (2,3)).
   addImpliedFaces(s:%):List(List(OrientedFacet)) ==
     --print("addImpliedFaces s="::Symbol << s)
     inputList:List(List(OrientedFacet)) := reverse(grade(s))
     res:List(List(OrientedFacet)) := empty()$List(List(OrientedFacet))
     maxGrade:NNI := #inputList
     if (maxGrade) < 1 then return res
     -- create an empty list for each grade
     for a in 1..(maxGrade) repeat
       res := concat(res,empty()$List(OrientedFacet))
     if maxGrade < 2 then return res -- do we include verticies?
     newFaces:List(OrientedFacet) := empty()$List(OrientedFacet)
     for gr in inputList for grn in 1..(maxGrade) repeat
       --print("addImpliedFaces grade number grn="::Symbol << grn)
       -- add old faces
       for face in gr repeat
         res.grn := concat(res.grn,face)
       -- add new faces
       for face in newFaces repeat
         res.grn := concat(res.grn,face)
       --print("addImpliedFaces empty newFaces. res.grn="::Symbol << res.grn)
       newFaces := empty()$List(OrientedFacet)
       --print("addImpliedFaces res.grn="::Symbol << res.grn)
       for face in res.grn repeat
         len: NNI := (order(face) -1) pretend NNI
         if len > 0 then
           newFaces := listUnion(newFaces,allSubsets(face,len))
       --print("addImpliedFaces get next grade res="::Symbol << res)
     reverse(res)

   -- returns line around area assuming simplexes are all wound in same direction
   -- TODO try to put the segments on the line in order
   -- For more information about such topological functions see this page:
   -- http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/topo/
--   boundaryLine(s:%):% ==
--     res:List(OrientedFacet) := empty()$List(OrientedFacet)
--     lines:List(PAIR) := empty()$List(PAIR)
--     for simp in s.SIMP repeat
--       firstEntry:NNI := 0
--       for n in 1..(#simp) repeat
--         if n = 1 then firstEntry := simp.n
--         if n = #simp then
--           line:PAIR := construct(simp.n,firstEntry)$PAIR
--           lines := concat(lines,line)$List(PAIR)
--         if n < #simp then
--           line:PAIR := construct(simp.n,simp.(n+1))$PAIR
--           lines := concat(lines,line)$List(PAIR)
--     cancel:List(PAIR) := empty()$List(PAIR)
--     for x in lines repeat
--       pair:List(NNI) := [x.fst,x.sec]
--       if member?(x,cancel)
--         then
--           cancel := remove(x,cancel)$List(PAIR)
--         else
--           rev:PAIR := construct(x.sec,x.fst)$PAIR
--           -- TODO should really check that segment has not already been
--           -- canceled
--           if member?(rev,lines)
--             then
--               cancel := concat(cancel,rev)$List(PAIR)
--             else
--               res := concat(res,pair)$List(List(NNI))
--     simplicialComplex(s.VERTSET,res)

   -- Step down to the next lower dimension, this is like hollowing out the complex.
   -- It takes the highest dimension entries and replaces them with their boundaries,
   -- cancelling out where it can.
   delta(s:%):% ==
     res:% := simplicialComplex(s.VERTSET)
     --facets:List(OrientedFacet) := empty()$List(OrientedFacet)
     for facet in s.SIMP repeat
       x:List(OrientedFacet) := delta(facet)
       --print("delta("::Symbol << s.SIMP << ") x="::Symbol << x)
       for y in x repeat
         --facets := concat(facets,y)$List(OrientedFacet)
         res:=addSimplex(res,y)
     --[s.VERTSET,facets]
     res

   -- The 'star' of a simplicial complex and a simplex contains only the simplexes
   -- of s which include simplex.
   star(s:%,simplex:OrientedFacet):% ==
     res:List(OrientedFacet) := empty()$List(OrientedFacet)
     for simp in s.SIMP repeat
       if not isSubsetOf?(simp,simplex) then
         res:=concat(res,simp)
     [s.VERTSET,res]

   -- The 'link' of a simplicial complex and a simplex contains the boundary of the
   -- simplexes of s which include simplex.
   -- If s is continous then link is: boundaryLine(star(s,simplex))
   link(s:%,simplex:OrientedFacet):% ==
     res:List(OrientedFacet) := empty()$List(OrientedFacet)
     for facet in s.SIMP repeat
       if isSubsetOf?(facet,simplex) then
         x:OrientedFacet := subtract(simplex,facet)
         res:=concat(res,x)
     [s.VERTSET,res]

   -- The 'cone' of a simplicial complex is formed by adding the vertex to every
   -- facet.
   -- 'vertex' should not already be included in existing faces, this is not checked
   -- and so will lead to simplexed with duplicate verticies.
   cone(s:%,vertex:NNI):% ==
     res:List(OrientedFacet) := empty()$List(OrientedFacet)
     for facet in s.SIMP repeat
       x:OrientedFacet := addVertex(facet,vertex)
       res:=concat(res,x)
     [s.VERTSET,res]

   -- Forms disjoint union of two simplicial complexes.
   simplicialJoin(a:%,b:%):% ==
     c:VS := join(a.VERTSET,b.VERTSET)
     res:% := copy(a)
     for x in b.SIMP repeat
       res := addSimplex(res,x)
       -- print ("n="::Symbol << n << " offset="::Symbol << offset)
     -- print ("res="::Symbol << res)
     res

   -- local function used in oneSkeleton
   concatIfNew(a:List(Record(value : NNI, posX : NNI, posY : NNI)),b:NNI):_
         List(Record(value : NNI, posX : NNI, posY : NNI)) ==
     OBJT ==> Record(value : NNI, posX : NNI, posY : NNI)
     if member?([b,0::NNI,0::NNI],a)$List(OBJT) then return a
     concat(a,[b,0::NNI,0::NNI])$List(OBJT)

   -- local function used in oneSkeleton
   concatIfNewArrow(a:List(Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)),_
           p:NNI,m:NNI):_
           List(Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)) ==
     ARROW ==> Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)
     if member?(["x",0::NNI,p,m,0::Integer,0::Integer,[]],a)$List(ARROW) then return a
     if member?(["x",0::NNI,m,p,0::Integer,0::Integer,[]],a)$List(ARROW) then return a
     concat(a,["x",0::NNI,p,m,0::Integer,0::Integer,[]])$List(ARROW)

   -- Generates graph AKA 1-skeleton.
   -- Used to generate fundamental group
   oneSkeleton(s:%):DirectedGraph(NNI) ==
     ARROW ==> Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)
     OBJT ==> Record(value : NNI, posX : NNI, posY : NNI)
     GS := DirectedGraph(NNI)
     nodes:List(OBJT) := empty()$List(OBJT)
     edges:List(ARROW) := empty()$List(ARROW)
     for x in s.SIMP repeat
       -- SIMP is List(OrientedFacet) so x is OrientedFacet
       n:NNI := order(x)
       indexes:List(NNI) := getIndexes(x)
       if n=2 then
         nodes := concatIfNew(nodes,indexes.1)
         nodes := concatIfNew(nodes,indexes.2)
         y:ARROW := ["x",0::NNI,indexes.1,indexes.2,0::Integer,0::Integer,[]]
         edges := concat(edges,y)$List(ARROW)
         --print ("nodes="::Symbol << nodes << " edges="::Symbol << edges)
       if n>2 then
         for m in indexes repeat
           nodes := concatIfNew(nodes,m)
           for p in indexes repeat
             if p<m then
               edges := concatIfNewArrow(edges,p::NNI,m::NNI)
     directedGraph(nodes,edges)$GS

   -- Generates fundamental group from this simplicial complex.
   -- This works by converting to a DeltaComplex and then generating the
   -- fundamentalGroup from that. This is not the most efficient method
   -- because the conversion generates lots of higher order faceMaps
   -- which are not used.
   -- TODO write a faster implemetation which only generates edge and 
   -- triangle faceMaps.
   fundamentalGroup(s:%):GroupPresentation ==
     dc:DeltaComplex(VS) := deltaComplex(s pretend FiniteSimplicialComplex(VS))
     fundamentalGroup(dc)

   -- calculate homology using SmithNormalForm
   homology(s:%):List(Matrix(Integer)) ==
     dc:DeltaComplex(VS) := deltaComplex(s pretend FiniteSimplicialComplex(VS))
     homology(dc)

   -- local function used by simplexProduct.
   productIndex(indexA:NNI,indexB:NNI,maxA:NNI):NNI ==
     if indexA<1 then error "productIndex out of range"
     if indexB<1 then error "productIndex out of range"
     ia:Integer := indexA -1
     ib:Integer := indexB -1
     res := ia + ib*maxA
     (res+1)::NNI

   -- local function used by simplexProduct.
   addToPath(listPath:List(OrientedFacet),indexA:NNI,indexB:NNI,maxA:NNI):List(OrientedFacet) ==
     i:NNI := productIndex(indexA,indexB,maxA)
     if empty?(listPath) then return [orientedFacet(1,[i])]
     if empty?(first listPath) then return [orientedFacet(1,[i])]
     return [addVertex(path,i)$OrientedFacet for path in listPath]

   -- local function, used by product of simplicial complexes, this local function returns
   -- the product of two simplexes.
   -- For more detailed explanation of simplex product code see:
   -- \url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/product/}
   -- Also see Hatcher [9].
   -- page 277 - The simplical cross product.
   -- page 278 - The cohomology cross product.
   -- Returns list, each entry is a 'lattice path' from (0,0) to (x,y) where x is number
   -- of entries in sa and y is number of entries in sb.
   -- Calculation of 'lattice paths' is a combinatorics problem so perhaps it should really
   -- be done by combinatorics code?
   simplexProduct(pathList:List(OrientedFacet),minA:NNI,maxA:NNI,minB:NNI,maxB:NNI):List(OrientedFacet) ==
     --print("simplexProduct("::Symbol << pathList << ","::Symbol << minA << ","::Symbol << _
     --         maxA<< ","::Symbol << minB<< ","::Symbol << maxB<< ")"::Symbol)
     diffA:Integer := maxA-minA
     diffB:Integer := maxB-minB
     if diffA = 0 and diffB = 0 then return addToPath(pathList,maxA,maxB,maxA)
     if diffA = 0 then
       return simplexProduct(addToPath(pathList,minA,minB,maxA),minA,maxA,minB+1,maxB)
     if diffB = 0 then
       return simplexProduct(addToPath(pathList,minA,minB,maxA),minA+1,maxA,minB,maxB)
     --print("["::Symbol::OutputForm)
     path1:List(OrientedFacet) := simplexProduct(addToPath(pathList,minA,minB,maxA),minA+1,maxA,minB,maxB)
     --print(","::Symbol::OutputForm)
     path2:List(OrientedFacet) := simplexProduct(addToPath(pathList,minA,minB,maxA),minA,maxA,minB+1,maxB)
     --print("]"::Symbol::OutputForm)
     concat(path1,path2)

   -- Forms product of two simplicial complexes.
   product(a:%,b:%):% ==
     simpsa:List(OrientedFacet) := a.SIMP
     simpsb:List(OrientedFacet) := b.SIMP
     dima:NNI := maxFaces(a.VERTSET)$VS
     dimb:NNI := maxFaces(b.VERTSET)$VS
     vs:VS := prod(a.VERTSET,b.VERTSET)
     res:List(OrientedFacet) := empty()$List(OrientedFacet)
     for simpa in simpsa repeat
       for simpb in simpsb repeat
         res := concat(res,simplexProduct(empty()$List(OrientedFacet),1,dima,1,dimb))
     [vs,res]

   -- Local function used by '=' to check if two simplexes are equal.
   -- To be equal they must contain the same indexes, wound in the same
   -- direction but not necessarily starting at the same value.
   equalSimplex(a:List(NNI),b:List(NNI)):Boolean ==
     --print("equalSimplex:"::Symbol << a << ","::Symbol << b)
     len:NNI := #a
     if len ~= #b then return false
     if len = 0 then return true
     fst:NNI := first a
     offset:Integer := position(fst,b)
     if offset <1 then return false
     for n in 1..#a repeat
       if a.n ~= b.offset then return false
       offset := offset+1
       if offset > #b then offset := 1
     true

   -- Returns true if x equals y.
   -- That is, they contain the same simplexes, although not necessarily in the
   -- same order.
   -- TODO - Assumes point set is exactly the same, for more generality we should allow
   -- the points to be defined in a different order.
   _=(a : %, b : %) : Boolean ==
     as:List(OrientedFacet) := a.SIMP
     bs:List(OrientedFacet) := b.SIMP
     --print("equal:"::Symbol << as << ","::Symbol << bs)
     len:NNI := #as
     if len ~= #bs then return false
     flags:List(Boolean) := [false for x in as] -- flag for every entry in b
     --print("empty flags "::Symbol << flags)
     for a1 in as repeat
       x:NNI := 1
       while (a1 ~= bs.x) or (flags.x) repeat
         --print("loop:"::Symbol << x << " flags"::Symbol << flags)
         x:=x+1
         if x > #as then return false
       flags.x := true
       --print("flags."::Symbol << x << "=true "::Symbol << flags)
     --print("final flags "::Symbol << flags)
     for f in flags repeat
       if f=false then return false
     true

   -- output
   coerce(s : %) : OutputForm ==
     res:OutputForm := empty()$OutputForm
     if empty?(s.SIMP) then return bracket(empty()$OutputForm)
     for a in s.SIMP repeat
       res:=vconcat(res,a::OutputForm)
     res

   -- coerce to DeltaComplex
   coerce(s:%) : DeltaComplex(VS) ==
     deltaComplex(s pretend FiniteSimplicialComplex(VS))
)if false
\section{Chain Complex}

Delta Complexes are defined by a sequence of 'face maps', These can be represented
by a list of matricies.

In this linear algebra form the homology groups can
be calculated from the Smith normal form:
)endif

)abbrev domain CHAINC ChainComplex
++ Author: Martin Baker
++ Description: 
++   Delta Complexes are defined by a sequence of 'face maps', These can
++   be represented by a list of matricies.
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/
++ Date Created: March 2016
++ Date Last Updated: March 2016
++ Basic Operations:
++ Related packages:
++ Related categories:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples: 
++ References:

ChainComplex() : Exports == Impl where
  NNI==> NonNegativeInteger
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> VertexSet() with
    chainComplex: (v:List(Matrix(Integer))) -> %
     ++ constructor
    validate:(a:%) -> Boolean
     ++ true if this is a valid chain complex, that is:
     ++ 1) maps compose
     ++ 2) product of adjacent maps is zero
    homology:(a:%) -> List(Matrix(Integer))
     ++ calculate homology using SmithNormalForm

  Impl ==> add

   -- Representation contains sequence of face maps in matrix
   -- form
   Rep := List(Matrix(Integer))

   -- constructor
   chainComplex(v:List(Matrix(Integer))):% ==
     v

   -- true if this is a valid chain complex, that is:
   -- 1) maps compose
   -- 2) product of adjacent maps is zero
   validate(a:%):Boolean ==
     len:NNI := #a
     if len < 2 then return true
     last:Matrix(Integer):=a.1
     for x in 2..len repeat
       m:Matrix(Integer):=a.x
       if maxRowIndex(m) ~= maxColIndex(last) then
         print("validate failed nRows="::Symbol << maxRowIndex(m) <<_
           " not equal to nCols "::Symbol << maxColIndex(last))
         return false
       prod:Matrix(Integer):= last*m
       if not zero?(prod) then
         print("validate failed "::Symbol << last << " * "::Symbol <<_
           m << " = "::Symbol << prod)
         return false
       last:=m     
     true

   -- calculate homology using SmithNormalForm
   homology(a:%):List(Matrix(Integer)) ==
     res:List(Matrix(Integer)) := empty()$List(Matrix(Integer))
     for m1 in a repeat
       m2:Matrix(Integer):=smith(m1)$IntegerSmithNormalForm
       res := concat(res,m2)
     res

   -- output
   coerce(s : %) : OutputForm ==
     lst: List(OutputForm) := [x::OutputForm for x in s]
     commaSeparate(lst)

)if false
\section{Delta Complex}

The FiniteSimplicialComplex representation defines faces, of any dimension, by
their vertices. This is an efficient way to define them, a disadvantage
is that intermediate parts, such as edges, are not indexed. It is
sometimes useful to be able to do this, for example, when generating
homotopy groups such as the fundamental group.

Therefore the following alternative representation can be used instead.
)endif

)abbrev domain DELTAC DeltaComplex
++ Author: Martin Baker
++ Description: 
++   Similar to Simplicial Complex but faces (edges, tringles, etc.) are
++   indexed by 'face maps' into the next lower face map until we get
++   down to the verticies.
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/delta/
++ Date Created: Feb 2016
++ Date Last Updated: Feb 2016
++ Basic Operations:
++ Related packages:
++ Related categories:
++ Related Domains: FiniteSimplicialComplex is a simpler and more compact
++    representation which can be used if edges, triangles, etc. don't need
++    to be indexed.
++ Also See:
++ AMS Classifications:
++ Keywords: topology, finite, simplicial, complex, edge, triangle
++ Examples:
++ References:

DeltaComplex(VS:VertexSet) : Exports == Impl where
  NNI==> NonNegativeInteger
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> SetCategory() with
    deltaComplex: (v:VS,f:List(List(List(Integer)))) -> %
     ++ constructor where the simplices are supplied
    deltaComplex:(fsc:FiniteSimplicialComplex(VS)) -> %
     ++ construct from FiniteSimplicialComplex. This builds indexes of
     ++ edges, triangles and so on.
    link:(a:NNI,b:NNI) -> %
     ++ a simplical complex with one link
    triangle:(a:NNI,b:NNI,c:NNI) -> %
     ++ a simplical complex with one triangle
    faceMap:(s:%,n:NNI) -> List(List(Integer))
     ++ returns an individual face map specified by n.
     ++ Where 'n' is the dimension required, so n=1 returns
     ++ one dimentional faces (edges), n=2 returns
     ++ two dimentional faces (triamgles), and so on.
    faceMapMatrixAll:(s:%) -> ChainComplex
     ++ returns a matrix sequence representing the face maps
     ++ in linear algebra form
    oneSkeleton:(s:%) -> DirectedGraph(NNI)
     ++ generates graph AKA 1-skeleton
    fundamentalGroup:(s:%) -> GroupPresentation
     ++ Generates fundamental group from this simplicial complex.
    homology:(a:%) -> List(Matrix(Integer))
     ++ calculate homology using SmithNormalForm

  Impl ==> add

   -- Representation holds whole Complex. This consists of
   -- a vertex set, here represented as a vertex list so that we can
   -- index it.
   -- Also a sequence of tables (known as 'face maps') representing
   -- edges, triangles, tetrahedrons, etc. containing indexes into
   -- the next lower map.
   -- Since edges, triangles, tetrahedrons, etc. are oriented we use
   -- a positive or negative index to indicate winding direction. 
   Rep := Record(VERTSET:VS,MAPS:List(List(List(Integer))))

   -- constructor where the vertex set and simplices are supplied
   deltaComplex(v:VS,f:List(List(List(Integer)))):% == [v,f]

   -- construct from FiniteSimplicialComplex. This builds indexes of
   -- edges, triangles and so on.
   deltaComplex(fsc:FiniteSimplicialComplex(VS)):% ==
     -- first grade and add implied faces
     allFacets:List(List(OrientedFacet)) := addImpliedFaces(fsc)
     --print("deltaComplex allFacets="::Symbol << allFacets )
     -- sort each grade
     allFacetsGraded:List(List(OrientedFacet)) := empty()$List(List(OrientedFacet))
     for gradedList in allFacets repeat
       --print("deltaComplex gradedList="::Symbol << gradedList )
       allFacetsGraded := concat(allFacetsGraded,sort(gradedList))
     --print("deltaComplex allFacetsGraded="::Symbol << allFacetsGraded )
     -- now change base indexed to heirarcical indexed
     faceMaps:List(List(List(Integer))) := empty()$List(List(List(Integer)))
     previousFaceList:List(OrientedFacet) := empty()$List(OrientedFacet)
     for gradeList in allFacetsGraded for grn in 1..(#allFacetsGraded) repeat
       faceMaps := concat(faceMaps,empty()$List(List(Integer)))
       if grn=1 then
         -- edges - no need to change
         faceMaps.grn := [(getIndexes(x) pretend List(Integer)) for x in gradeList]
       if grn>1 then
         -- triangles and above
         -- we need to build up a map from oldFaceHigh to oldFacesLow
         newMap:List(List(Integer))  := empty()$List(List(Integer)) 
         for oldFaceHigh in gradeList repeat
           --print("  deltaComplex oldFaceHigh="::Symbol << oldFaceHigh )
           --oldFacesLow:List(OrientedFacet) := allSubsets(oldFaceHigh,grn)
           oldFacesLow:List(OrientedFacet) := delta(oldFaceHigh)
           --print("  deltaComplex oldFacesLow="::Symbol << oldFacesLow )
           newIndexes:List(Integer) := empty()$List(Integer)
           for oldFaceLow in oldFacesLow repeat
             --print("    deltaComplex oldFaceLow="::Symbol << oldFaceLow << _
             --      " previousFaceList="::Symbol << previousFaceList << _
             --      " allFacetsGraded.1="::Symbol << allFacetsGraded.1)
             i:=position(oldFaceLow,previousFaceList)$OrientedFacet
             i2:Integer := abs(i)
             if i2 < 1 then
               print("  deltaComplex oldFaceLow="::Symbol << oldFaceLow << _
                 " not found in previousFaceList="::Symbol << previousFaceList )
               error concat("cant find index:",string(i))
             newIndexes := concat(newIndexes,i)
           newMap := concat(newMap,newIndexes)
         faceMaps.grn := newMap
       previousFaceList := gradeList
     vs:VS := (fsc pretend Record(VERTSET:VS,SIMP:List(List(NNI)))).VERTSET
     --print("deltaComplex faceMaps="::Symbol << faceMaps )
     [vs ,faceMaps]

   -- a simplical complex with one link
   link(a:NNI,b:NNI):% ==
     vs:VS := (vertexSeta(2::NNI)$VertexSetAbstract) pretend VS
     simp:List(List(List(Integer))) := [[[a,b]]]
     [vs,simp]

   -- a simplical complex with one triangle
   triangle(a:NNI,b:NNI,c:NNI):% ==
     vs:VS := (vertexSeta(3::NNI)$VertexSetAbstract) pretend VS
     edges:List(List(Integer)) := [[a,b],[a,c],[b,c]]
     triangles:List(List(Integer)) := [[a,-b,c]]
     simp:List(List(List(Integer))) := [edges,triangles]
     [vs,simp]

   -- returns an individual face map specified by n.
   -- Where 'n' is the dimension required, so n=1 returns
   -- one dimentional faces (edges), n=2 returns
   -- two dimentional faces (triamgles), and so on.
   faceMap(s:%,n:NNI):List(List(Integer)) ==
     maps1:List(List(List(Integer))) := s.MAPS
     if n > #maps1 then return empty()$List(List(Integer))
     maps1.n

   -- returns a matrix sequence representing the face maps
   -- in linear algebra form
   faceMapMatrixAll(s:%):ChainComplex ==
     res:List(Matrix(Integer)) := empty()$List(Matrix(Integer))
     maps1:List(List(List(Integer))) := s.MAPS
     for faces in maps1 repeat
       --print("faceMapMatrix faces="::Symbol << faces << " res="::Symbol << res)
       nCols:NNI := #(faces)
       if nCols<1 then return chainComplex(res)
       nRows:NNI := 0
       for u in faces repeat
         for v in u repeat
           if abs(v)>nRows then nRows := abs(v) pretend NNI
       --print("faceMapMatrix nRows="::Symbol << nRows << " nCols="::Symbol << nCols)
       m : Matrix(Integer) := new(nRows,nCols,0)
       for u in faces for nu in 1..(#faces) repeat
         for v in u for nv in 1..(#u) repeat
           v2:Integer := abs(v)
           --print("faceMapMatrix row="::Symbol << nu << " col="::Symbol << v2 << _
           --  " nRows="::Symbol << nRows << " nCols="::Symbol << nCols)
           ele:Integer := 1
           if even?(nv) then ele := -1
           setelt!(m,v2,nu,ele) -- params are (matrix,row number,col number, value)
       res := concat(res,m)
     chainComplex(res)

   -- calculate homology using SmithNormalForm
   homology(a:%):List(Matrix(Integer)) ==
     cc:ChainComplex := faceMapMatrixAll(a)
     validate(cc)
     homology(cc)

   -- local function used in oneSkeleton
--   concatIfNew(a:List(Record(value : NNI, posX : NNI, posY : NNI)),b:NNI):_
--         List(Record(value : NNI, posX : NNI, posY : NNI)) ==
--     OBJT ==> Record(value : NNI, posX : NNI, posY : NNI)
--     if member?([b,0::NNI,0::NNI],a)$List(OBJT) then return a
--     concat(a,[b,0::NNI,0::NNI])$List(OBJT)

   -- local function used in oneSkeleton
--   concatIfNewArrow(a:List(Record(name : String, arrType : NNI, fromOb : NNI, _
--           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)),_
--           p:NNI,m:NNI):_
--           List(Record(name : String, arrType : NNI, fromOb : NNI, _
--           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)) ==
--     ARROW ==> Record(name : String, arrType : NNI, fromOb : NNI, _
--           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)
--     if member?(["x",0::NNI,p,m,0::Integer,0::Integer,[]],a)$List(ARROW) then return a
--     if member?(["x",0::NNI,m,p,0::Integer,0::Integer,[]],a)$List(ARROW) then return a
--     concat(a,["x",0::NNI,p,m,0::Integer,0::Integer,[]])$List(ARROW)

   -- Generates graph AKA 1-skeleton.
   -- Used to generate fundamental group
   oneSkeleton(s:%):DirectedGraph(NNI) ==
     ARROW ==> Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)
     OBJT ==> Record(value : NNI, posX : NNI, posY : NNI)
     GS := DirectedGraph(NNI)
     nodes:List(OBJT) := empty()$List(OBJT)
     edges:List(ARROW) := empty()$List(ARROW)
     m:NNI := maxFaces(s.VERTSET)
     edgeIndexes:List(List(Integer)) := first(s.MAPS)
     for x in edgeIndexes repeat
         --print("oneSkeleton x="::Symbol << x)
         from1:NNI := abs(x.1) pretend NNI
         if from1>m then m:=from1
         to1:NNI := abs(x.2) pretend NNI
         if to1>m then m:=to1
         y:ARROW := ["x",0::NNI,from1,to1,0::Integer,0::Integer,[]]
         edges := concat(edges,y)$List(ARROW)
     setMaxFaces(s.VERTSET,m)
     --print("oneSkeleton nodes="::Symbol << nodes << " edges="::Symbol << edges  << _
     --     " maxVerts="::Symbol << m  << " maxVerts="::Symbol << maxFaces(s.VERTSET))
     for m1 in 1..m repeat
       nodes:= concat(nodes,[m1,0::NNI,0::NNI])$List(OBJT)
     directedGraph(nodes,edges)$GS

   -- local function to list all the links in a given tree
   linksInTree(res:List(List(Integer)),a:Tree(Integer)):List(List(Integer)) ==
     --print("linksInTree value="::Symbol << value(a) << " children="::Symbol << children(a))
     fromNode:Integer := value(a)
     for x in children(a) repeat
       toNode:Integer := value(x)
       newLink:List(Integer) := [fromNode,toNode]
       res := concat(res,newLink)
     for x in children(a) repeat
       res := linksInTree(res,x)
     res

   -- Generates fundamental group from this delta complex.
   fundamentalGroup(s:%):GroupPresentation ==
     --print("fundamentalGroup("::Symbol << s  <<")"::Symbol)
     -- fundamental group is about triangles so get face map
     -- for triangles (2 dimensional)
     -- compute edge-path group
     graph:DirectedGraph(NNI) := oneSkeleton(s)
     --print("fundamentalGroup graph="::Symbol << graph )
     -- choose a spanning tree for the 1-skeleton
     span:Tree(Integer) := spanningTreeNode(graph,1::NNI)$DirectedGraph(NNI)
     --print("fundamentalGroup span="::Symbol << span )
     edges:List(List(Integer)) := faceMap(s,1::NNI)
     res:List(List(Integer)) := empty()$List(List(Integer))
     res := linksInTree(res,span)
     edgesInTree:List(Boolean) := [false for y in edges]
     for edge in edges for edgen in 1..(#edges) repeat
       if member?(edge,res) then edgesInTree.edgen := true
     --print("fundamentalGroup linksInTree="::Symbol << res << " edgesInTree="::Symbol << edgesInTree)
     triangles:List(List(Integer)) := faceMap(s,2::NNI)
     rules:List(List(Integer)) := empty()$List(List(Integer))
     --print("fundamentalGroup triangles="::Symbol << triangles )
     for t in triangles repeat
       rule:List(Integer) := empty()$List(Integer)
       if not edgesInTree.(abs(t.1)) then rule:= concat(rule,t.1)
       if not edgesInTree.(abs(t.2)) then rule:= concat(rule,-t.2)
       if not edgesInTree.(abs(t.3)) then rule:= concat(rule,t.3)
       if not empty?(rule) then rules := concat(rules,rule)
     --print("fundamentalGroup rules="::Symbol << rules )
     -- groups generators: edges in 1-skeleton
     -- groups relations: for every 2-simplex
     --                   e0 e1^-1 e2
     --                   (e0,e1,e2 are edges)
     -- set m to maximum index in the face map
     m:NNI := #edges
     generators:List(NNI) := empty()$List(NNI)
     for x in 1..m repeat
       if not edgesInTree.x then
         generators := concat(generators,x::NNI)
     gp:GroupPresentation := groupPresentation(generators,rules)$GroupPresentation
     simplify(gp)$GroupPresentation

   -- Local function used by '=' to check if two simplexes are equal.
   -- To be equal they must contain the same indexes, wound in the same
   -- direction but not necessarily starting at the same value.
   equalSimplex(a:List(Integer),b:List(Integer)):Boolean ==
     --print("equalSimplex:"::Symbol << a << ","::Symbol << b)
     len:NNI := #a
     if len ~= #b then return false
     if len = 0 then return true
     fst:Integer := first a
     offset:Integer := position(fst,b)
     if offset <1 then return false
     for n in 1..#a repeat
       if a.n ~= b.offset then return false
       offset := offset+1
       if offset > #b then offset := 1
     true

   -- Returns true if x equals y.
   -- That is, they contain the same simplexes, although not necessarily in the
   -- same order.
   -- TODO - Assumes point set is exactly the same, for more generality we should allow
   -- the points to be defined in a different order.
   _=(a : %, b : %) : Boolean ==
     as := a.MAPS
     bs := b.MAPS
     --print("equal:"::Symbol << as << ","::Symbol << bs)
     len:NNI := #as
     if len ~= #bs then return false
--     flags:List(Boolean) := [false for x in as] -- flag for every entry in b
     --print("empty flags "::Symbol << flags)
--     for a1 in as repeat
--       x:NNI := 1
--       while (not equalSimplex(a1,bs.x)) or (flags.x) repeat
--         --print("loop:"::Symbol << x << " flags"::Symbol << flags)
--         x:=x+1
--         if x > #as then return false
--       flags.x := true
       --print("flags."::Symbol << x << "=true "::Symbol << flags)
     --print("final flags "::Symbol << flags)
--     for f in flags repeat
--       if f=false then return false
     true

   -- output
   coerce(s : %) : OutputForm ==
     res:OutputForm :=empty()$OutputForm -- holds result
     if empty?(s.MAPS) then return res
     tabNum:NNI := 1::NNI
     for a in s.MAPS repeat
       if tabNum = 1::NNI then res := hconcat(res,message("edge:"))
       if tabNum = 2::NNI then res := hconcat(res,message(" triangle:"))
       if tabNum = 3::NNI then res := hconcat(res,message(" tetrahedron:"))
       if tabNum > 3::NNI then res := hconcat(res,message(" higher:"))
       res := hconcat(res,a::OutputForm)
       tabNum := tabNum+1
     res

)if false
SimplicialComplexFactory contructs example simplicial complexes for us.
)endif

)abbrev package SIMPCF SimplicialComplexFactory
++ Author: Martin Baker
++ Date Created: Jan 2016
++ Date Last Updated: Jan 2016
++ Description:
++  Provides functions to construct various simplicial complexes.
PI ==> PositiveInteger
NNI==> NonNegativeInteger
x<<y ==> hconcat(x::OutputForm,y::OutputForm)

SimplicialComplexFactory() : with
  sphereSolid:(dim:NNI) -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ Generate a simplicial complex equivalent to a solid hyper-sphere. That
    ++ is, a solid volume with no holes in it, so we use a single n-dimensional
    ++ simplex.
  sphereSurface:(dim:NNI) -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ Generate a simplicial complex equivalent to the surface of a hyper-sphere.
    ++ That is, the surface of a volume with no holes in it, so we use a minimal
    ++ triangulation of the faces of a single simplex.
  torusSurface:() -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ generate a minimal triangulation of the surface of an 3-dimensional torus.
  band:() -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ Generate a minimal triangulation of the surface of a cylinder without ends
  moebiusBand:() -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ Generate a minimal triangulation of the surface of a Moebius band.
    ++ A one sided surface with a single external boundary line.
  projectivePlane:() -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ Generate a minimal triangulation of the surface of a projective plane.
    ++ A one sided surface which cannot be embedded in 3D space without
    ++ intersecting itself. There are no external boundaries, every edge
    ++ connects two faces.
    ++ (A punctured projective plane is equivalent to a Moebius band)
  kleinBottle:() -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ generate a minimal triangulation of the surface of a Klein bottle.

 == add

  -- generate a simplicial complex equivalent to a solid hyper-sphere. That
  -- is, a solid volume with no holes in it, so we use a single n-dimensional
  -- simplex.
  sphereSolid(dim:NNI):FiniteSimplicialComplex(VertexSetAbstract) ==
    ASIMP := FiniteSimplicialComplex(VertexSetAbstract)
    v1:List(List(NNI)) := [[n for n in 1..(dim+1)]]
    vs1:VertexSetAbstract := vertexSeta(dim)
    simplicialComplex(vs1,v1)$ASIMP

  -- generate a simplicial complex equivalent to the surface of a hyper-sphere.
  -- That is, the surface of a volume with no holes in it, so we use a minimal
  -- triangulation of the faces of a single simplex.
  sphereSurface(dim:NNI):FiniteSimplicialComplex(VertexSetAbstract) ==
    s:=sphereSolid(dim)
    delta(s)

  -- generate a minimal triangulation of the surface of an 3-dimensional torus.
  torusSurface():FiniteSimplicialComplex(VertexSetAbstract) ==
    ASIMP := FiniteSimplicialComplex(VertexSetAbstract)
    v1:List(List(NNI)) := [[1,2,3],[2,3,5],[2,4,5],[2,4,7],[1,2,6],[2,6,7],_
                           [3,4,6],[3,5,6],[3,4,7],[1,3,7],[1,4,5],[1,4,6],_
                           [5,6,7],[1,5,7]]
    vs1:VertexSetAbstract := vertexSeta(7::NNI)
    simplicialComplex(vs1,v1)$ASIMP

  -- generate a minimal triangulation of the surface of a cylinder without ends
  band() : FiniteSimplicialComplex(VertexSetAbstract) ==
    ASIMP := FiniteSimplicialComplex(VertexSetAbstract)
    v1:List(List(NNI)) := [[1,2,3],[1,2,6],[1,5,6],[2,3,4],[3,4,5],[4,5,6]]
    vs1:VertexSetAbstract := vertexSeta(6::NNI)
    simplicialComplex(vs1,v1)$ASIMP

  -- generate a minimal triangulation of the surface of a Moebius band.
  moebiusBand() : FiniteSimplicialComplex(VertexSetAbstract) ==
    ASIMP := FiniteSimplicialComplex(VertexSetAbstract)
    v1:List(List(NNI)) := [[1,2,3],[2,3,4],[3,4,5],[1,4,5],[1,2,5]]
    vs1:VertexSetAbstract := vertexSeta(5::NNI)
    simplicialComplex(vs1,v1)$ASIMP

  -- generate a minimal triangulation of the surface of a projective plane.
  -- (A punctured projective plane is equivalent to a Moebius band)
  projectivePlane():FiniteSimplicialComplex(VertexSetAbstract) ==
    ASIMP := FiniteSimplicialComplex(VertexSetAbstract)
    v1:List(List(NNI)) := [[1,2,3],[1,3,4],[1,2,6],[1,5,6],[1,4,5],[2,3,5],_
                           [2,4,5],[2,4,6],[3,4,6],[3,5,6]]
    vs1:VertexSetAbstract := vertexSeta(6::NNI)
    simplicialComplex(vs1,v1)$ASIMP

  -- generate a minimal triangulation of the surface of a Klein bottle.
  kleinBottle():FiniteSimplicialComplex(VertexSetAbstract) ==
    ASIMP := FiniteSimplicialComplex(VertexSetAbstract)
    v1:List(List(NNI)) := [[3,4,8],[2,3,4],[2,4,6],[2,6,8],[2,5,8],[3,5,7],_
                           [2,3,7],[2,7,1],[2,5,1],[3,5,1],[4,5,8],[4,5,7],_
                           [4,6,7],[6,7,1],[3,6,1],[3,6,8]]
    vs1:VertexSetAbstract := vertexSeta(8::NNI)
    simplicialComplex(vs1,v1)$ASIMP

--Copyright (c) 2016, Martin J Baker.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of Martin J Baker. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

)if false
\eject
\begin{thebibliography}{99}
For more details see:
[1] Mathematics++ Kantor,Matousek,Samal 2015  ISBN 978-1-4704-2261-5
      Chapter 6 - Topology. Contains a relatively gentle introduction to homology.

[2] Graphs, Surfaces and Homology, Peter Giblin 2010 ISBN 987-0-521-15405-5
      Builds up to homology groups via graphs and simplicial complexes.

[3] Wikipedia
\url{http://https://en.wikipedia.org/wiki/Simplicial_complex/}

[4] I have put a fuller explanation of this code here:
\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/}

[5] Finite simplicial complexes in Sage
\url{http://doc.sagemath.org/html/en/reference/homology/sage/homology/simplicial_complex.html}

[6] Finite simplicial complexes in NPM
\url{https://www.npmjs.com/package/simplicial-complex}

[7] Simpcomp - a GAP package for working with simplicial complexes
\url{https://code.google.com/p/simpcomp/}

[8] A Macaulay2 package for working with simplicial complexes
\url{http://www.math.uiuc.edu/Macaulay2/doc/Macaulay2-1.8.2/share/doc/Macaulay2/SimplicialComplexes/html}

[9] Hatcher - Algebraic Topology - book also available free online. 
\url{https://www.math.cornell.edu/~hatcher/AT/AT.pdf}

[10]Computational Geometry - Algorithms and Applications by
    Mark de Berg, Otfried Cheong, Marc van Kreveld and Mark Overmars
    This book looks at the algorithms from a computer science, rather
    than pure mathematics, point-of-view. So homotopy or homology is
    not mentioned but subjects like Voronoi Diagrams, Delauney
    Triangulations, Convex Hulls and many similar topics are covered.

\end{thebibliography}
\end{document}
)endif

