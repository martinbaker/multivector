)if false
\documentclass{article}
\usepackage{axiom}
\usepackage{url}
\begin{document}
\title{Algebraic Topology Structures}
\author{Martin J Baker}
\maketitle
\begin{abstract}

I would like to code topological spaces in a finite way, simplicial
complexes and delta complexes allow us to do this in a systematic way.

Simplicial Complexes may not be the most efficient tool, for cutting
edge topology, in terms the most economical representation. However,
for computer-science and combinatorial uses, simplicial complexes may
be the best tool because of their combinatorial simplicity.
- paraphrased from [1].

I have put a fuller explanation of this code here:
\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/}
\end{abstract}
\section{Related Code}

Simplicial Complexes are a generalisation of graph theory as implemented here:
https://github.com/fricas/fricas/blob/master/src/algebra/graph.spad
I will implement coercions from graphs to simplicial complexes.

I have not yet investigated whether this code can be linked to existing code such as:

Smith normal form and unit Gaussian elimination:
\url{https://github.com/fricas/fricas/blob/master/src/algebra/smith.spad}
\url{https://github.com/fricas/fricas/blob/master/src/algebra/smith2.spad}

Zariski topology:
The Zariski topology of an algebraic variety is the topology whose closed sets
are the algebraic subsets of the variety.
\url{https://github.com/fricas/fricas/blob/master/src/algebra/zerodim.spad}
\url{https://github.com/fricas/fricas/blob/master/src/algebra/regset.spad}

DeRhamComplex
\url{https://github.com/fricas/fricas/blob/master/src/algebra/derham.spad}

DifferentialGeometry
\url{http://axiom-wiki.newsynthesis.org/SandBoxDifferentialGeometry}

\section{Introduction}

\section{Homotopy Group}
The homotopy group is finitely presented by generators and relations.
This representation of a group is not, in general, algorithmically computable
into other representations of a group.

We can therefore compute 'a' (not 'the') homotopy group for a given simplicial
complex. We may also be able to apply some simplifications to this group.
However, in the general case, we cannot determine if this is the simplest
representation or determine if two such groups are isomophic (their corresponding
simplicial complexes are homeomorphic).

Despite these fundamental limits on what is theoretically possible I still
believe it is worthwhile to have the capability to generate 'a' homotopy
group for a given structure.
)endif

)abbrev domain GROUPP GroupPresentation
++ Author: Martin Baker
++ Description: 
++   Group represented by its generators and relations.
++   Here we use it to hold homotopy group such as fundamental group.
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/
++ Date Created: Jan 2016
++ Date Last Updated: Feb 2016
++ Basic Operations:
++ Related packages:
++ Related categories:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples: 
++ References:

GroupPresentation() : Exports == Impl where
  NNI==> NonNegativeInteger
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> SetCategory() with
    groupPresentation: (v:List(NNI),rels1: List(List(Integer))) -> %
     ++ construct from generators

  Impl ==> add

   -- Representation holds the group as a set of generators and a set of
   -- relations
   -- Each generator is a NNI
   -- Each relation is a list of indexes to generators. Negative values indicate
   -- reversal of direction.
   Rep := Record(gens:PrimitiveArray(NNI),rels: List(List(Integer)))

   -- constructor where the vertex set is supplied
   groupPresentation(gens1:List(NNI),rels1: List(List(Integer))):% ==
     g:PrimitiveArray(NNI) := construct(gens1)$PrimitiveArray(NNI)
     [g,rels1]

   -- Hard/impossible to determine if finitely presented groups are
   -- isomorphic so just test exact equality for now
   _=(a : %, b : %) : Boolean ==
     a.gens=b.gens

   -- output
   coerce(s : %) : OutputForm ==
     ps:List(NNI) := parts((s.gens) pretend PrimitiveArray(NNI))
     res:List(OutputForm) := empty()$List(OutputForm)
     for p in ps repeat
       res := concat(res,p::OutputForm)
     bracket(res)

)if false
\section{Simplicial Complexes}

The representation holds whole Simplicial Complex. This consists of
a vertex set, represented as a vertex list so that we can index it.
Also a list of simplices (that is n-dimensional faces). each simplice
is an array of vertex indexes. So each simplice is a subset of the
vertex set.

If the dimension given for the simplicial complex is 'k' then:
\begin{itemize}
\item The number of elements in each vertex = k.
\item The maximum number of vertexes in each simplice = k + 1.
\end{itemize}
For example, a trangle has 3 vertexes, so it is maximum size face in 3-1=2 dimensions.
\begin{table}[]
\label{Dimensions}
\begin{tabular}{lll}
dimension \ vertex \ simplice - (faces) \\
0 \ 0 elements \ point \\
1 \ 1 element vertex \ line - (edge) \\
2 \ 2 element vertex \ triangle \\
3 \ 3 element vertex \ tetrahedron \\
n \ n element vertex \ simplice \\
\end{tabular}
\end{table}

\section{Abstract Simplicial Complex vs. Simplicial Complex}
If we apply the restrictions explained so far we have an abstract simplicial complex,
However, for a simplicial complex there are some additional conditions.

An Abstract Simplicial Complex is purely combinitorial, that is we don't need the
geometric information.

Therefore the AbstractSimplicialComplex domain does not need coordinates for the
verticies and they can be denoted by symbols.

\section{Operations on Simplicial Complexes}

Closure - closure of X contains X and all the faces touching X
Star -
Link -
Join - We will call it a SimplicialJoin since it is not related to joins in lattices.

\section{Simplicial Maps}
Allow edges to be collapsed into vertices.

\section{Oriented Simplexes Maps}

\section{Vertex Set Code}
We want an indexed set of points, the simplest way to do the indexing is to use
'List' instead of 'Set'.

The vertices themselves may be either:
\begin{itemize}
\item literal coordinates.
\item symbolic vertex names.
\item numeric indexes.
\end{itemize}
So we cave a category that can represent any of these types and then a domain for
each type.
)endif

)abbrev category VERTS VertexSet
++ Author: Martin Baker
++ Description:
++   An indexed set of vertices
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/
++ Related Domains: VertexSetAbstract, VertexSetCoord
++ Date Created: Dec 2015
++ Date Last Updated: Feb 2016
VertexSet() : Category == Definition where
 NNI==> NonNegativeInteger
 Definition ==> SetCategory() with
   maxFaces:(a:%) -> NNI
     ++ return the maximum number of faces
   setMaxFaces:(a:%,b:NNI) -> Void
     ++ set the maximum number of faces
   join:(a:%,b:%) -> %
     ++ disjoint union of two vertex sets
   prod:(a:%,b:%) -> %
     ++ Cartesian product of two vertex sets

)if false
This is VertexSet for a geometric simplicial complex. In this case each vertex is
represented by a point in some underlying space.

We want to represent an indexed set of points, the simplest way to do this is to
use a list of points.
)endif

)abbrev domain VERTSC VertexSetCoord
++ Author: Martin Baker
++ Description: 
++   An indexed set of vertices represented as coordinates.
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/geometric/
++ Date Created: Dec 2015
++ Date Last Updated: Feb 2016
++ Basic Operations:
++ Related packages:
++ Related categories: VertexSet
++ Related Domains: VertexSetAbstract
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples: 
++ References:

VertexSetCoord(F:Field) : Exports == Impl where
  NNI==> NonNegativeInteger
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> VertexSet() with
    vertexSet: (v:List(PrimitiveArray(F))) -> %
     ++ constructor where the vertex set is supplied

    dimension:(a:%) -> NNI
     ++ return dimension of underlying space

  Impl ==> add

   -- Representation holds the vertex set, represented as a
   -- vertex list so that we can index it.
   Rep := List(PrimitiveArray(F))

   -- constructor where the vertex set is supplied
   vertexSet(v:List(PrimitiveArray(F))):% ==
     v

   -- return dimension of underlying space
   -- in this case assume its how many numbers used to specify a point
   dimension(a:%):NNI ==
     res:NNI := 0
     for b in a repeat
       if #b > res then res:=#b
     res

   -- return the maximum number of faces
   maxFaces(a:%):NNI ==
     #a

   -- set the maximum number of faces
   setMaxFaces(a:%,b:NNI):Void ==
     if #a <= b then return void
     error "too few coordinates"
     void

   -- disjoint union of two vertex sets
   join(a:%,b:%):% ==
     concat(a,b)

   -- Cartesian product of two vertex sets
   prod(a:%,b:%):% ==
     a

   -- output
   coerce(s : %) : OutputForm ==
     if empty?(s) then return bracket(empty()$OutputForm)
     mat:List List OutputForm := empty()$List(List(OutputForm))
     for a in s repeat
       row:List OutputForm := empty()$List(OutputForm)
       if empty?(members(a))$List(F)
         then
           row := concat(row,bracket(empty()$OutputForm))$List(OutputForm)
         else
           for b in members(a) repeat
             row := concat(row,b::OutputForm)$List(OutputForm)
       mat := concat(mat,row)
     matrix(mat)

)if false
This is VertexSet for an abstract simplicial complex. In this case each vertex is
represented by an index without any underlying coordinates.

)endif

)abbrev domain VERTSA VertexSetAbstract
++ Author: Martin Baker
++ Description: 
++   An indexed set of abstract vertices without real coordinates.
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/
++ Date Created: Dec 2015
++ Date Last Updated: Feb 2016
++ Basic Operations:
++ Related packages:
++ Related categories: VertexSet
++ Related Domains: VertexSetCoord
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:

VertexSetAbstract() : Exports == Impl where
  NNI==> NonNegativeInteger
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> VertexSet() with
    vertexSeta: (d:NNI) -> %
     ++ constructor for abstract vertex set

  Impl ==> add

   -- Representation holds number of vertices, it is wrapped in a Reference
   -- because, otherwise, it would be immutable.
   Rep := Reference(NNI)

   -- constructor for abstract vertex set
   vertexSeta(d:NNI):% ==
     ref(d)

   -- return the maximum number of faces
   maxFaces(a:%):NNI ==
     deref(a)

   -- set the maximum number of faces
   setMaxFaces(a:%,b:NNI):Void ==
     setref(a,b)
     void

   -- disjoint union of two vertex sets
   join(a:%,b:%):% ==
     ref(deref(a)+deref(b))

   -- product of two vertex sets
   prod(a:%,b:%):% ==
     ref(deref(a)*deref(b))

   -- output
   coerce(s : %) : OutputForm == outputForm(deref(s) pretend NNI)$OutputForm
 
)if false
This representation defines faces, of any dimension, by their vertices. This is an
efficient way to define them.
As an example consider the representation for a single tetrahedron:
The representation would be: (1,2,3,4)
There is and alternative representation later.
)endif

)abbrev domain SIMPC FiniteSimplicialComplex
++ Author: Martin Baker
++ Description: 
++   A Finite Simplicial Complex
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/
++ Date Created: Dec 2015
++ Date Last Updated: Jan 2016
++ Basic Operations: star, link, cone, product
++ Related packages:
++ Related categories:
++ Related Domains: DeltaComplex is an alternative representation
++    which is less compact but allows edges, triangles, etc to be indexed.
++ Also See:
++ AMS Classifications:
++ Keywords: topology, finite, simplicial, complex, edge, triangle
++ Examples:
++ References:

FiniteSimplicialComplex(VS:VertexSet) : Exports == Impl where
  NNI==> NonNegativeInteger
  PAIR ==> Record(fst:NNI,sec:NNI)
  SIMPLEX ==> List(NNI)
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> SetCategory() with
    simplicialComplex: (v:VS,f:List(List(NNI))) -> %
     ++ constructor where the simplices are supplied
    boundaryLine: (s:%) -> %
     ++ returns line around area assuming simplexes are all wound in same direction
     ++ For more information about such topological functions see this page:
     ++ http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/topo/
    star:(s:%,simplex:SIMPLEX) -> %
     ++ The 'star' of a simplicial complex and a vertex contains only the simplexes
     ++ of s which include vertex 'v'.
    link:(s:%,simplex:SIMPLEX) -> %
     ++ The 'link' of a simplicial complex and a vertex contains the boundary of the
     ++ simplexes of s which include vertex 'v'.
    cone:(s:%,vertex:NNI) -> %
     ++ The 'cone' of a simplicial complex is formed by adding the vertex to every
     ++ facet.
     ++ 'vertex' should not already be included in existing faces, this is not checked
     ++ and so will lead to simplexed with duplicate verticies.
    simplicialJoin:(a:%,b:%) -> %
     ++ Forms disjoint union of two simplicial complexes.
    product:(a:%,b:%) -> %
     ++ Forms product of two simplicial complexes.
    oneSkeleton:(s:%) -> DirectedGraph(NNI)
     ++ generates graph AKA 1-skeleton
    fundamentalGroup:(s:%) -> GroupPresentation
     ++ Generates fundamental group from this simplicial complex.
     ++ under construction

  Impl ==> add

   -- Representation holds whole Simplicial Complex. This consists of
   -- a vertex set, here represented as a vertex list so that we can
   -- index it.
   -- Also a list of simplices (that is n-dimensional faces). each
   -- simplice is an array of vertex indexes.
   -- So each simplice is a subset of the vertex set.
   --where:
   -- VS is a list of verticies in whatever form we are using.
   -- NNI is an index.
   -- The inner list represents an individual simplex.
   -- The outer list holds a list of simplexes.
   Rep := Record(VERTSET:VS,SIMP:List(List(NNI)))

   -- constructor where the vertex set and simplices are supplied
   simplicialComplex(v:VS,f:List(List(NNI))):% == [v,f]

   -- returns line around area assuming simplexes are all wound in same direction
   -- TODO try to put the segments on the line in order
   -- For more information about such topological functions see this page:
   -- http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/topo/
   boundaryLine(s:%):% ==
     res:List(List(NNI)) := empty()$List(List(NNI))
     lines:List(PAIR) := empty()$List(PAIR)
     for simp in s.SIMP repeat
       firstEntry:NNI := 0
       for n in 1..(#simp) repeat
         if n = 1 then firstEntry := simp.n
         if n = #simp then
           line:PAIR := construct(simp.n,firstEntry)$PAIR
           lines := concat(lines,line)$List(PAIR)
         if n < #simp then
           line:PAIR := construct(simp.n,simp.(n+1))$PAIR
           lines := concat(lines,line)$List(PAIR)
     cancel:List(PAIR) := empty()$List(PAIR)
     for x in lines repeat
       pair:List(NNI) := [x.fst,x.sec]
       if member?(x,cancel)
         then
           cancel := remove(x,cancel)$List(PAIR)
         else
           rev:PAIR := construct(x.sec,x.fst)$PAIR
           -- TODO should really check that segment has not already been
           -- canceled
           if member?(rev,lines)
             then
               cancel := concat(cancel,rev)$List(PAIR)
             else
               res := concat(res,pair)$List(List(NNI))
     simplicialComplex(s.VERTSET,res)

   -- local function, used by isFaceOf and subtract, which returns true if
   -- vertex 'b' is contained in face 'a'.
   isVertexOf(sa:SIMPLEX,vb:NNI):Boolean ==
     for vertex in sa repeat
       if vertex=vb then
         --print("isVertexOf("::Symbol << sa << ","::Symbol << vb << ")=true"::Symbol)
         return true
     --print("isVertexOf("::Symbol << sa << ","::Symbol << vb << ")=false"::Symbol)
     false

   -- local function, used by link, which returns true if face 'b' is
   -- contained in face 'a'.
   isFaceOf(sa:SIMPLEX,sb:SIMPLEX):Boolean ==
     for vertex in sb repeat
       if not isVertexOf(sa,vertex) then return false
     --print("isFaceOf("::Symbol << sa << ","::Symbol << sb << ")=true"::Symbol)
     true
 
   -- local function, used by link, which returns face 'a' minus
   -- the verticies in face 'b'.
   subtract(sa:SIMPLEX,sb:SIMPLEX):SIMPLEX ==
     --print("subtract("::Symbol << sa << ","::Symbol << sb << ")="::Symbol << setDifference(sb,sa)$SIMPLEX)
     setDifference(sb,sa)$SIMPLEX

   -- The 'star' of a simplicial complex and a simplex contains only the simplexes
   -- of s which include simplex.
   star(s:%,simplex:SIMPLEX):% ==
     res:List(List(NNI)) := empty()$List(List(NNI))
     for simp in s.SIMP repeat
       if isFaceOf(simp,simplex) then
         res:=concat(res,simp)
     simplicialComplex(s.VERTSET,res)

   -- The 'link' of a simplicial complex and a simplex contains the boundary of the
   -- simplexes of s which include simplex.
   -- If s is continous then link is: boundaryLine(star(s,simplex))
   link(s:%,simplex:SIMPLEX):% ==
     res:List(List(NNI)) := empty()$List(List(NNI))
     for facet in s.SIMP repeat
       if isFaceOf(facet,simplex) then
         x:SIMPLEX := subtract(simplex,facet)
         res:=concat(res,x)
     simplicialComplex(s.VERTSET,res)

   -- The 'cone' of a simplicial complex is formed by adding the vertex to every
   -- facet.
   -- 'vertex' should not already be included in existing faces, this is not checked
   -- and so will lead to simplexed with duplicate verticies.
   cone(s:%,vertex:NNI):% ==
     res:List(List(NNI)) := empty()$List(List(NNI))
     for facet in s.SIMP repeat
       x:SIMPLEX := concat(facet,vertex)
       res:=concat(res,x)
     simplicialComplex(s.VERTSET,res)

   -- Forms disjoint union of two simplicial complexes.
   simplicialJoin(a:%,b:%):% ==
     c:VS := join(a.VERTSET,b.VERTSET)
     offset:NNI := maxFaces(a.VERTSET)
     res:List(List(NNI)) := copy(a.SIMP)
     for x in b.SIMP repeat
       thisSimp:List(NNI) := empty()$List(NNI)
       for n in x repeat
         -- print ("n="::Symbol << n << " offset="::Symbol << offset)
         thisSimp := concat(thisSimp,n+offset)
       res := concat(res,thisSimp)
     -- print ("res="::Symbol << res)
     simplicialComplex(c,res)

   -- local function used in oneSkeleton
   concatIfNew(a:List(Record(value : NNI, posX : NNI, posY : NNI)),b:NNI):_
         List(Record(value : NNI, posX : NNI, posY : NNI)) ==
     OBJT ==> Record(value : NNI, posX : NNI, posY : NNI)
     if member?([b,0::NNI,0::NNI],a)$List(OBJT) then return a
     concat(a,[b,0::NNI,0::NNI])$List(OBJT)

   -- local function used in oneSkeleton
   concatIfNewArrow(a:List(Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)),_
           p:NNI,m:NNI):_
           List(Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)) ==
     ARROW ==> Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)
     if member?(["x",0::NNI,p,m,0::Integer,0::Integer,[]],a)$List(ARROW) then return a
     if member?(["x",0::NNI,m,p,0::Integer,0::Integer,[]],a)$List(ARROW) then return a
     concat(a,["x",0::NNI,p,m,0::Integer,0::Integer,[]])$List(ARROW)

   -- Generates graph AKA 1-skeleton.
   -- Used to generate fundamental group
   oneSkeleton(s:%):DirectedGraph(NNI) ==
     ARROW ==> Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)
     OBJT ==> Record(value : NNI, posX : NNI, posY : NNI)
     GS := DirectedGraph(NNI)
     nodes:List(OBJT) := empty()$List(OBJT)
     edges:List(ARROW) := empty()$List(ARROW)
     for x in s.SIMP repeat
       n:NNI := #x
       if n=2 then
         nodes := concatIfNew(nodes,x.1)
         nodes := concatIfNew(nodes,x.2)
         y:ARROW := ["x",0::NNI,x.1,x.2,0::Integer,0::Integer,[]]
         edges := concat(edges,y)$List(ARROW)
         --print ("nodes="::Symbol << nodes << " edges="::Symbol << edges)
       if n>2 then
         for m in x repeat
           nodes := concatIfNew(nodes,m)
           for p in x repeat
             if p<m then
               edges := concatIfNewArrow(edges,p::NNI,m::NNI)
     directedGraph(nodes,edges)$GS

   -- Generates fundamental group from this simplicial complex.
   -- under construction
   fundamentalGroup(s:%):GroupPresentation ==
     print("fundamentalGroup("::Symbol << s  <<")"::Symbol)
     -- under construction
     -- compute edge-path group
     graph:DirectedGraph(NNI) := oneSkeleton(s)
     print("fundamentalGroup graph="::Symbol << graph )
     -- choose a spanning tree for the 1-skeleton
     span := spanningTreeNode(graph,1::NNI)$DirectedGraph(NNI)
     print("fundamentalGroup span="::Symbol << span )
     -- groups generators: edges in 1-skeleton
     -- groups relations: for every 2-simplex
     --                   e0 e1^-1 e2
     --                   (e0,e1,e2 are edges)
     generators:List(NNI) := [0::NNI]
     r:List(List(Integer)) := empty()$List(List(Integer))
     groupPresentation(generators,r)$GroupPresentation

   -- local function used by simplexProduct.
   productIndex(indexA:NNI,indexB:NNI,maxA:NNI):NNI ==
     if indexA<1 then error "productIndex out of range"
     if indexB<1 then error "productIndex out of range"
     ia:Integer := indexA -1
     ib:Integer := indexB -1
     res := ia + ib*maxA
     (res+1)::NNI

   -- local function used by simplexProduct.
   addToPath(listPath:List(SIMPLEX),indexA:NNI,indexB:NNI,maxA:NNI):List(SIMPLEX) ==
     i:NNI := productIndex(indexA,indexB,maxA)
     if empty?(listPath) then return [[i]]
     if empty?(first listPath) then return [[i]]
     return [concat(path,i)$SIMPLEX for path in listPath]

   -- local function, used by product of simplicial complexes, this local function returns
   -- the product of two simplexes.
   -- For more detailed explanation of simplex product code see:
   -- \url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/product/}
   -- Also see Hatcher [9].
   -- page 277 - The simplical cross product.
   -- page 278 - The cohomology cross product.
   -- Returns list, each entry is a 'lattice path' from (0,0) to (x,y) where x is number
   -- of entries in sa and y is number of entries in sb.
   -- Calculation of 'lattice paths' is a combinatorics problem so perhaps it should really
   -- be done by combinatorics code?
   simplexProduct(pathList:List(SIMPLEX),minA:NNI,maxA:NNI,minB:NNI,maxB:NNI):List(SIMPLEX) ==
     --print("simplexProduct("::Symbol << pathList << ","::Symbol << minA << ","::Symbol << _
     --         maxA<< ","::Symbol << minB<< ","::Symbol << maxB<< ")"::Symbol)
     diffA:Integer := maxA-minA
     diffB:Integer := maxB-minB
     if diffA = 0 and diffB = 0 then return addToPath(pathList,maxA,maxB,maxA)
     if diffA = 0 then return simplexProduct(addToPath(pathList,minA,minB,maxA),minA,maxA,minB+1,maxB)
     if diffB = 0 then return simplexProduct(addToPath(pathList,minA,minB,maxA),minA+1,maxA,minB,maxB)
     --print("["::Symbol::OutputForm)
     path1:List(SIMPLEX) := simplexProduct(addToPath(pathList,minA,minB,maxA),minA+1,maxA,minB,maxB)
     --print(","::Symbol::OutputForm)
     path2:List(SIMPLEX) := simplexProduct(addToPath(pathList,minA,minB,maxA),minA,maxA,minB+1,maxB)
     --print("]"::Symbol::OutputForm)
     concat(path1,path2)

   -- Forms product of two simplicial complexes.
   product(a:%,b:%):% ==
     simpsa:List(SIMPLEX) := a.SIMP
     simpsb:List(SIMPLEX) := b.SIMP
     dima:NNI := maxFaces(a.VERTSET)$VS
     dimb:NNI := maxFaces(b.VERTSET)$VS
     vs:VS := prod(a.VERTSET,b.VERTSET)
     res:List(SIMPLEX) := [empty()$SIMPLEX]
     for simpa in simpsa repeat
       for simpb in simpsb repeat
         res := concat(res,simplexProduct([empty()$SIMPLEX],1,dima,1,dimb))
     simplicialComplex(vs,res)

   -- Local function used by '=' to check if two simplexes are equal.
   -- To be equal they must contain the same indexes, wound in the same
   -- direction but not necessarily starting at the same value.
   equalSimplex(a:List(NNI),b:List(NNI)):Boolean ==
     --print("equalSimplex:"::Symbol << a << ","::Symbol << b)
     len:NNI := #a
     if len ~= #b then return false
     if len = 0 then return true
     fst:NNI := first a
     offset:Integer := position(fst,b)
     if offset <1 then return false
     for n in 1..#a repeat
       if a.n ~= b.offset then return false
       offset := offset+1
       if offset > #b then offset := 1
     true

   -- Returns true if x equals y.
   -- That is, they contain the same simplexes, although not necessarily in the
   -- same order.
   -- TODO - Assumes point set is exactly the same, for more generality we should allow
   -- the points to be defined in a different order.
   _=(a : %, b : %) : Boolean ==
     as := a.SIMP
     bs := b.SIMP
     --print("equal:"::Symbol << as << ","::Symbol << bs)
     len:NNI := #as
     if len ~= #bs then return false
     flags:List(Boolean) := [false for x in as] -- flag for every entry in b
     --print("empty flags "::Symbol << flags)
     for a1 in as repeat
       x:NNI := 1
       while (not equalSimplex(a1,bs.x)) or (flags.x) repeat
         --print("loop:"::Symbol << x << " flags"::Symbol << flags)
         x:=x+1
         if x > #as then return false
       flags.x := true
       --print("flags."::Symbol << x << "=true "::Symbol << flags)
     --print("final flags "::Symbol << flags)
     for f in flags repeat
       if f=false then return false
     true

   -- output
   coerce(s : %) : OutputForm ==
     if empty?(s.SIMP) then return bracket(empty()$OutputForm)
     mat:List List OutputForm := empty()$List(List(OutputForm))
     -- matrix does not like different row widths so we need to
     -- know the maximum width so we can pad to that width.
     maxWidth:NNI := 0
     for a in s.SIMP repeat
       if #a > maxWidth then maxWidth := #a
     if maxWidth = 0 then return empty()$OutputForm
     for a in s.SIMP repeat
       row:List OutputForm := empty()$List(OutputForm)
       for b in a repeat
         row := concat(row,outputForm(b)$OutputForm)$List(OutputForm)
       w:NNI := #a
       while w < maxWidth repeat
         row := concat(row,empty()$OutputForm)$List(OutputForm)
         w:= w+1
       mat := concat(mat,row)
     matrix(mat)

)if false
\section{Delta Complex}

The above representation defines faces, of any dimension, by their
vertices. This is an efficient way to define them, a disadvantage
is that intermediate parts, such as edges, are not indexed. It is
sometimes useful to be able to do this, for example, when generating
homotopy groups such as the fundamental group.

Therefore the following alternative representation can be used instead.
)endif

)abbrev domain DELTAC DeltaComplex
++ Author: Martin Baker
++ Description: 
++   Similar to Simplicial Complex but faces (edges, tringles, etc.) are
++   indexed by 'face maps' into the next lower face map until we get
++   down to the verticies.
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/delta/
++ Date Created: Feb 2016
++ Date Last Updated: Feb 2016
++ Basic Operations:
++ Related packages:
++ Related categories:
++ Related Domains: FiniteSimplicialComplex is a simpler and more compact
++    representation which can be used if edges, triangles, etc. don't need
++    to be indexed.
++ Also See:
++ AMS Classifications:
++ Keywords: topology, finite, simplicial, complex, edge, triangle
++ Examples:
++ References:

DeltaComplex(VS:VertexSet) : Exports == Impl where
  NNI==> NonNegativeInteger
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)

  Exports ==> SetCategory() with
    deltaComplex: (v:VS,f:List(List(List(Integer)))) -> %
     ++ constructor where the simplices are supplied
    deltaComplex:(fsc:FiniteSimplicialComplex(VS)) -> %
     ++ construct from FiniteSimplicialComplex. This builds indexes of
     ++ edges, triangles and so on.
    link:(a:NNI,b:NNI) -> %
     ++ a simplical complex with one link
    triangle:(a:NNI,b:NNI,c:NNI) -> %
     ++ a simplical complex with one triangle
    oneSkeleton:(s:%) -> DirectedGraph(NNI)
     ++ generates graph AKA 1-skeleton
    fundamentalGroup:(s:%) -> GroupPresentation
     ++ Generates fundamental group from this simplicial complex.
     ++ under construction

  Impl ==> add

   -- Representation holds whole Complex. This consists of
   -- a vertex set, here represented as a vertex list so that we can
   -- index it.
   -- Also a sequence of tables (known as 'face maps') representing
   -- edges, triangles, tetrahedrons, etc. containing indexes into
   -- the next lower map.
   -- Since edges, triangles, tetrahedrons, etc. are oriented we use
   -- a positive or negative index to indicate winding direction. 
   Rep := Record(VERTSET2:VS,SIMP2:List(List(List(Integer))))

   -- constructor where the vertex set and simplices are supplied
   deltaComplex(v:VS,f:List(List(List(Integer)))):% == [v,f]

   -- a simplical complex with one link
   link(a:NNI,b:NNI):% ==
     vs:VS := (vertexSeta(2::NNI)$VertexSetAbstract) pretend VS
     simp:List(List(List(Integer))) := [[[a,b]]]
     [vs,simp]

   -- a simplical complex with one triangle
   triangle(a:NNI,b:NNI,c:NNI):% ==
     vs:VS := (vertexSeta(3::NNI)$VertexSetAbstract) pretend VS
     edges:List(List(Integer)) := [[a,b],[a,c],[b,c]]
     triangles:List(List(Integer)) := [[a,-b,c]]
     simp:List(List(List(Integer))) := [edges,triangles]
     [vs,simp]

   -- a local function which returns the maximum grade (length) of a
   -- list of lists
   maxGrade(a:List(List(NNI))):NNI ==
     res:NNI := 0::NNI
     for lst in a repeat
       if #lst > res then res := #lst
     res

   -- a local function which returns the index of a list in a
   -- list of lists. If the list is not there then add it.
   getIndex!(a:List(Integer),b1:Reference(List(List(Integer)))):Integer ==
     res:Integer := 1::Integer
     b:List(List(Integer)) := deref(b1)
     --print ("getIndex! in a="::Symbol << a << " b="::Symbol << b)
     if empty?(b) then b := [a]
     for lst in b repeat
       if a=lst then
         setref(b1,b)
         --print ("getIndex! old a="::Symbol << a << " b="::Symbol << b << " b1="::Symbol << b1<< " res="::Symbol << res)
         return res
       res := res+1
     b := concat(b,a)
     setref(b1,b)
     --print ("getIndex! new a="::Symbol << a << " b="::Symbol << b << " b1="::Symbol << b1<< " res="::Symbol << res)
     res

   -- a local function to return a list where each entry:
   -- i) is a permutation of the input list
   -- ii) contains integers in ascending order
   -- iii) is of the specified length
   orderedPermutation(lst:List(Integer),len: NNI):List(List(Integer)) ==
     if len < 1 then return empty()$List(List(Integer))
     if len > #lst then return empty()$List(List(Integer))
     if len = #lst then return [lst]
     reslt:List(List(Integer)) := empty()$List(List(Integer))
     if len=1 then
       for y in lst repeat
         reslt := concat(reslt,[y])
       return reslt  
     fst:Integer := lst.first
     rst:List(Integer) := lst.rest
     -- in the next line I probably should use 'subtractifcan' rather
     -- than using pretend but it can never be negative due to the tests
     -- at the start of this function.
     for x in orderedPermutation(rst,(len-1) pretend NNI) repeat
       r1:List(Integer) := concat(fst,x)
       -- r1 holds a permutations starting with fst
       reslt := concat(reslt,r1)
     -- now we have combinations staring with fst
     -- so we just have to add the rest
     reslt := concat(reslt,orderedPermutation(rst,len))
     reslt

   -- construct from FiniteSimplicialComplex. This builds indexes of
   -- edges, triangles and so on.
   deltaComplex(fsc:FiniteSimplicialComplex(VS)):% ==
     emptySimp:List(List(List(Integer))) := [[empty()$List(Integer)]]
     vs:VS := (fsc pretend Record(VERTSET:VS,SIMP:List(List(NNI)))).VERTSET
     simp:List(List(NNI)) := (fsc pretend Record(VERTSET:VS,SIMP:List(List(NNI)))).SIMP
     maxGr:NNI := maxGrade(simp)
     if maxGr < 3 then return [vs ,emptySimp]
     gradedLists:List(List(List(Integer))) := empty()$List(List(List(Integer)))
     -- constuct an empty list for each grade
     for a in 2..maxGr repeat
       gradedLists := concat(gradedLists,empty()$List(List(Integer)))
     for lst in simp repeat
       for grade1 in ((#lst)-1)..2 by -1 repeat
         grade := grade1 pretend NNI
         edgeRef:Reference(List(List(Integer))) := ref(gradedLists.1)
         edges:List(List(Integer)) := orderedPermutation(lst pretend List(Integer),grade)
         indexList := [getIndex!(ed,edgeRef) for ed in edges]
         --print ("deltaComplex edges="::Symbol << edges << " indexList="::Symbol << indexList)
         gradedLists.(grade-1) := deref(edgeRef)
         gradedLists.grade := concat(gradedLists.grade,indexList)$List(List(Integer))
     [vs ,gradedLists]

   -- local function used in oneSkeleton
   concatIfNew(a:List(Record(value : NNI, posX : NNI, posY : NNI)),b:NNI):_
         List(Record(value : NNI, posX : NNI, posY : NNI)) ==
     OBJT ==> Record(value : NNI, posX : NNI, posY : NNI)
     if member?([b,0::NNI,0::NNI],a)$List(OBJT) then return a
     concat(a,[b,0::NNI,0::NNI])$List(OBJT)

   -- local function used in oneSkeleton
   concatIfNewArrow(a:List(Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)),_
           p:NNI,m:NNI):_
           List(Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)) ==
     ARROW ==> Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)
     if member?(["x",0::NNI,p,m,0::Integer,0::Integer,[]],a)$List(ARROW) then return a
     if member?(["x",0::NNI,m,p,0::Integer,0::Integer,[]],a)$List(ARROW) then return a
     concat(a,["x",0::NNI,p,m,0::Integer,0::Integer,[]])$List(ARROW)

   -- Generates graph AKA 1-skeleton.
   -- Used to generate fundamental group
   oneSkeleton(s:%):DirectedGraph(NNI) ==
     ARROW ==> Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)
     OBJT ==> Record(value : NNI, posX : NNI, posY : NNI)
     GS := DirectedGraph(NNI)
     nodes:List(OBJT) := empty()$List(OBJT)
     edges:List(ARROW) := empty()$List(ARROW)
     m:NNI := maxFaces(s.VERTSET2)
     edgeIndexes:List(List(Integer)) := first(s.SIMP2)
     for x in edgeIndexes repeat
         --print("oneSkeleton x="::Symbol << x)
         from1:NNI := abs(x.1) pretend NNI
         if from1>m then m:=from1
         to1:NNI := abs(x.2) pretend NNI
         if to1>m then m:=to1
         y:ARROW := ["x",0::NNI,from1,to1,0::Integer,0::Integer,[]]
         edges := concat(edges,y)$List(ARROW)
     setMaxFaces(s.VERTSET2,m)
     --print("oneSkeleton nodes="::Symbol << nodes << " edges="::Symbol << edges  << _
     --     " maxVerts="::Symbol << m  << " maxVerts="::Symbol << maxFaces(s.VERTSET2))
     for m1 in 1..m repeat
       nodes:= concat(nodes,[m1,0::NNI,0::NNI])$List(OBJT)
     directedGraph(nodes,edges)$GS

   -- Generates fundamental group from this delta complex.
   -- under construction
   fundamentalGroup(s:%):GroupPresentation ==
     print("fundamentalGroup("::Symbol << s  <<")"::Symbol)
     -- under construction
     -- compute edge-path group
     graph:DirectedGraph(NNI) := oneSkeleton(s)
     print("fundamentalGroup graph="::Symbol << graph )
     -- choose a spanning tree for the 1-skeleton
     span := spanningTreeNode(graph,1::NNI)$DirectedGraph(NNI)
     print("fundamentalGroup span="::Symbol << span )
     -- groups generators: edges in 1-skeleton
     -- groups relations: for every 2-simplex
     --                   e0 e1^-1 e2
     --                   (e0,e1,e2 are edges)
     m:NNI := maxFaces(s.VERTSET2)
     generators:List(NNI) := [x::NNI for x in 1..m]
     r:List(List(Integer)) := empty()$List(List(Integer))
     groupPresentation(generators,r)$GroupPresentation

   -- Local function used by '=' to check if two simplexes are equal.
   -- To be equal they must contain the same indexes, wound in the same
   -- direction but not necessarily starting at the same value.
   equalSimplex(a:List(Integer),b:List(Integer)):Boolean ==
     --print("equalSimplex:"::Symbol << a << ","::Symbol << b)
     len:NNI := #a
     if len ~= #b then return false
     if len = 0 then return true
     fst:Integer := first a
     offset:Integer := position(fst,b)
     if offset <1 then return false
     for n in 1..#a repeat
       if a.n ~= b.offset then return false
       offset := offset+1
       if offset > #b then offset := 1
     true

   -- Returns true if x equals y.
   -- That is, they contain the same simplexes, although not necessarily in the
   -- same order.
   -- TODO - Assumes point set is exactly the same, for more generality we should allow
   -- the points to be defined in a different order.
   _=(a : %, b : %) : Boolean ==
     as := a.SIMP2
     bs := b.SIMP2
     --print("equal:"::Symbol << as << ","::Symbol << bs)
     len:NNI := #as
     if len ~= #bs then return false
--     flags:List(Boolean) := [false for x in as] -- flag for every entry in b
     --print("empty flags "::Symbol << flags)
--     for a1 in as repeat
--       x:NNI := 1
--       while (not equalSimplex(a1,bs.x)) or (flags.x) repeat
--         --print("loop:"::Symbol << x << " flags"::Symbol << flags)
--         x:=x+1
--         if x > #as then return false
--       flags.x := true
       --print("flags."::Symbol << x << "=true "::Symbol << flags)
     --print("final flags "::Symbol << flags)
--     for f in flags repeat
--       if f=false then return false
     true

   -- output
   coerce(s : %) : OutputForm ==
     res:OutputForm :=empty()$OutputForm -- holds result
     if empty?(s.SIMP2) then return res
     tabNum:NNI := 1::NNI
     for a in s.SIMP2 repeat
       if tabNum = 1::NNI then res := hconcat(res,message("edge:"))
       if tabNum = 2::NNI then res := hconcat(res,message(" triangle:"))
       if tabNum = 3::NNI then res := hconcat(res,message(" tetrahedron:"))
       if tabNum > 3::NNI then res := hconcat(res,message(" higher:"))
       res := hconcat(res,a::OutputForm)
       tabNum := tabNum+1
     res

)if false
SimplicialComplexFactory contructs example simplicial complexes for us.
)endif

)abbrev package SIMPCF SimplicialComplexFactory
++ Author: Martin Baker
++ Date Created: Jan 2016
++ Date Last Updated: Jan 2016
++ Description:
++  Provides functions to construct various simplicial complexes.
PI ==> PositiveInteger
NNI==> NonNegativeInteger
x<<y ==> hconcat(x::OutputForm,y::OutputForm)

SimplicialComplexFactory() : with
  sphereSolid:(dim:NNI) -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ Generate a simplicial complex equivalent to a solid hyper-sphere. That
    ++ is, a solid volume with no holes in it, so we use a single n-dimensional
    ++ simplex.
  sphereSurface:(dim:NNI) -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ Generate a simplicial complex equivalent to the surface of a hyper-sphere.
    ++ That is, the surface of a volume with no holes in it, so we use a minimal
    ++ triangulation of the faces of a single simplex.
  torusSurface:() -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ generate a minimal triangulation of the surface of an 3-dimensional torus.
  band:() -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ Generate a minimal triangulation of the surface of a cylinder without ends
  moebiusBand:() -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ Generate a minimal triangulation of the surface of a Moebius band.
    ++ A one sided surface with a single external boundary line.
  projectivePlane:() -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ Generate a minimal triangulation of the surface of a projective plane.
    ++ A one sided surface which cannot be embedded in 3D space without
    ++ intersecting itself. There are no external boundaries, every edge
    ++ connects two faces.
    ++ (A punctured projective plane is equivalent to a Moebius band)
  kleinBottle:() -> FiniteSimplicialComplex(VertexSetAbstract)
    ++ generate a minimal triangulation of the surface of a Klein bottle.

 == add

  -- generate a simplicial complex equivalent to a solid hyper-sphere. That
  -- is, a solid volume with no holes in it, so we use a single n-dimensional
  -- simplex.
  sphereSolid(dim:NNI):FiniteSimplicialComplex(VertexSetAbstract) ==
    ASIMP := FiniteSimplicialComplex(VertexSetAbstract)
    v1:List(List(NNI)) := [[n for n in 1..(dim+1)]]
    vs1:VertexSetAbstract := vertexSeta(dim)
    simplicialComplex(vs1,v1)$ASIMP

  -- generate a simplicial complex equivalent to the surface of a hyper-sphere.
  -- That is, the surface of a volume with no holes in it, so we use a minimal
  -- triangulation of the faces of a single simplex.
  sphereSurface(dim:NNI):FiniteSimplicialComplex(VertexSetAbstract) ==
    ASIMP := FiniteSimplicialComplex(VertexSetAbstract)
    v1:List(List(NNI)) := empty()$List(List(NNI))
    for a in 1..(dim+1) repeat
      for b in (a+1)..(dim+1) repeat
        for c in (b+1)..(dim+1) repeat
          --if (b>a) and (c>b) then
            --print("sphere a="::Symbol << a << " b="::Symbol << b << " c="::Symbol << c)
            v1 := concat(v1,[a::NNI,b::NNI,c::NNI])
    vs1:VertexSetAbstract := vertexSeta(dim)
    simplicialComplex(vs1,v1)$ASIMP

  -- generate a minimal triangulation of the surface of an 3-dimensional torus.
  torusSurface():FiniteSimplicialComplex(VertexSetAbstract) ==
    ASIMP := FiniteSimplicialComplex(VertexSetAbstract)
    v1:List(List(NNI)) := [[1,2,3],[2,3,5],[2,4,5],[2,4,7],[1,2,6],[2,6,7],_
                           [3,4,6],[3,5,6],[3,4,7],[1,3,7],[1,4,5],[1,4,6],_
                           [5,6,7],[1,5,7]]
    vs1:VertexSetAbstract := vertexSeta(7::NNI)
    simplicialComplex(vs1,v1)$ASIMP

  -- generate a minimal triangulation of the surface of a cylinder without ends
  band() : FiniteSimplicialComplex(VertexSetAbstract) ==
    ASIMP := FiniteSimplicialComplex(VertexSetAbstract)
    v1:List(List(NNI)) := [[1,2,3],[1,2,6],[1,5,6],[2,3,4],[3,4,5],[4,5,6]]
    vs1:VertexSetAbstract := vertexSeta(6::NNI)
    simplicialComplex(vs1,v1)$ASIMP

  -- generate a minimal triangulation of the surface of a Moebius band.
  moebiusBand() : FiniteSimplicialComplex(VertexSetAbstract) ==
    ASIMP := FiniteSimplicialComplex(VertexSetAbstract)
    v1:List(List(NNI)) := [[1,2,3],[2,3,4],[3,4,5],[1,4,5],[1,2,5]]
    vs1:VertexSetAbstract := vertexSeta(5::NNI)
    simplicialComplex(vs1,v1)$ASIMP

  -- generate a minimal triangulation of the surface of a projective plane.
  -- (A punctured projective plane is equivalent to a Moebius band)
  projectivePlane():FiniteSimplicialComplex(VertexSetAbstract) ==
    ASIMP := FiniteSimplicialComplex(VertexSetAbstract)
    v1:List(List(NNI)) := [[1,2,3],[1,3,4],[1,2,6],[1,5,6],[1,4,5],[2,3,5],_
                           [2,4,5],[2,4,6],[3,4,6],[3,5,6]]
    vs1:VertexSetAbstract := vertexSeta(6::NNI)
    simplicialComplex(vs1,v1)$ASIMP

  -- generate a minimal triangulation of the surface of a Klein bottle.
  kleinBottle():FiniteSimplicialComplex(VertexSetAbstract) ==
    ASIMP := FiniteSimplicialComplex(VertexSetAbstract)
    v1:List(List(NNI)) := [[3,4,8],[2,3,4],[2,4,6],[2,6,8],[2,5,8],[3,5,7],_
                           [2,3,7],[2,7,1],[2,5,1],[3,5,1],[4,5,8],[4,5,7],_
                           [4,6,7],[6,7,1],[3,6,1],[3,6,8]]
    vs1:VertexSetAbstract := vertexSeta(8::NNI)
    simplicialComplex(vs1,v1)$ASIMP

--Copyright (c) 2015, Martin J Baker.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of Martin J Baker. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

)if false
\eject
\begin{thebibliography}{99}
For more details see:
[1] Mathematics++ Kantor,Matousek,Samal 2015  ISBN 978-1-4704-2261-5
      Chapter 6 - Topology. Contains a relatively gentle introduction to homology.

[2] Graphs, Surfaces and Homology, Peter Giblin 2010 ISBN 987-0-521-15405-5
      Builds up to homology groups via graphs and simplicial complexes.

[3] Wikipedia
\url{http://https://en.wikipedia.org/wiki/Simplicial_complex/}

[4] I have put a fuller explanation of this code here:
\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/}

[5] Finite simplicial complexes in Sage
\url{http://doc.sagemath.org/html/en/reference/homology/sage/homology/simplicial_complex.html}

[6] Finite simplicial complexes in NPM
\url{https://www.npmjs.com/package/simplicial-complex}

[7] Simpcomp - a GAP package for working with simplicial complexes
\url{https://code.google.com/p/simpcomp/}

[8] A Macaulay2 package for working with simplicial complexes
\url{http://www.math.uiuc.edu/Macaulay2/doc/Macaulay2-1.8.2/share/doc/Macaulay2/SimplicialComplexes/html}

[9] Hatcher - Algebraic Topology - book also available free online. 
\url{https://www.math.cornell.edu/~hatcher/AT/AT.pdf}

[10]Computational Geometry - Algorithms and Applications by
    Mark de Berg, Otfried Cheong, Marc van Kreveld and Mark Overmars
    This book looks at the algorithms from a computer science, rather
    than pure mathematics, point-of-view. So homotopy or homology is
    not mentioned but subjects like Voronoi Diagrams, Delauney
    Triangulations, Convex Hulls and many similar topics are covered.

\end{thebibliography}
\end{document}
)endif

