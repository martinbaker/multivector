)abbrev domain INTER Interpret
++ Author: Martin Baker
++ Date Created: April 2014
++ Date Last Updated: April 2014
++ Description:
++   This is an experiment to see how much of the FriCAS
++   interpreter that I can write using SPAD code.
++   Currently the interpreter is written in 'boot' code. For
++   example in int-top.boot, server.boot, i-toplev.boot
++   i-syscmd.boot and many others.
++
++   Boot code is poorly documented and loosly typed. There
++   would be lots of advantages if boot code were removed.
++
++   I have made this a domain so that it can hold parameters
++   which would otherwise be global parameters in boot code.
++
++   When the constructor 'spadInterpret' is called it sets up
++   the parameters and then goes into the main interpreter loop
++   reading lines and then acting on them.
++
++   To start with the interpreter loop will just call the 
++   existing lisp functions. The plan is to gradually implement
++   more of these functions in high level code.
++
++   I have put information about running this code here:
++ http://www.euclideanspace.com/maths/standards/program/mycode/system/interpreter/
++   The original interpreter is undocumented so I'm trying to
++   bootstrap my understanding by working out what I can here:
++ http://www.euclideanspace.com/maths/standards/program/internals/interpreter/

Interpret : Exports == Implementation where
  NNI==> NonNegativeInteger

  Exports == with

    spadInterpret:() -> %
      ++ constructor to setup parameters and run interpreter
      ++ inside existing interpreter

  Implementation ==> add

    Rep := Record(_
      op: Symbol,_
      Coerce: Symbol,_
      compErrorMessageStack: Symbol,_
      freeVars: Symbol,_
      mapList: Symbol,_
      compilingMap: Symbol,_
      compilingLoop: Symbol,_
      interpOnly: Symbol,_
      whereCacheList: Symbol,_
      timeGlobalName: Symbol,_
      StreamFrame: Symbol,_
      declaredMode: Symbol,_
      localVars: Symbol,_
      analyzingMapList: Symbol,_
      lastLineInSEQ: Symbol,_
      instantCoerceCount: Symbol,_
      instantCanCoerceCount: Symbol,_
      instantMmCondCount: Symbol,_
      defaultFortVar:Symbol,_
      fortVar: Symbol,_
      defaultFortVar: Symbol,_
      minivector: Symbol,_
      minivectorCode: Symbol,_
      minivectorNames: Symbol,_
      domPvar: Symbol,_
      inRetract: Symbol_
    )
      ++ parameters (was global parameters)
      ++ I have just set everthing to Symbol for now but will
      ++ set them to the correct high level types when I get
      ++ to implementing code that needs them.

    -- if a line starts with ) this indicates a system command
    -- so this will be called
    -- intended to replace ncloopCommand in
    -- int-top.boot
    processSystemCommand(s:String,param:%,lineNum:NNI):Boolean ==
      c := ncloopCommand(s,lineNum)$Lisp
      --InterpExecuteSpadSystemCommand(s)$Lisp
      --doSystemCommand(s)$Lisp
      --mathprint(concat(["process command",mathObject2String$Lisp c])$String)$Lisp
      true

    -- if a line is not a system command then this will be called
    -- intended to replace intloopProcessString in
    -- int-top.boot
    processMath(s:String,param:%,lineNum:NNI):Boolean ==
      --c := intloopProcessString(s,lineNum)$Lisp
      b := incString(s)$Lisp
      mathprint("token:")$Lisp
      print(b::OutputForm)
      c := lineoftoks(b)$Lisp
      mathprint("lineoftoks:")$Lisp
      print(c::OutputForm)
      d := parseFromString(s)$Lisp
      mathprint("parse:")$Lisp
      print(d::OutputForm)
      true

    -- check for system commands 
    -- check for continuation to line
    -- then interpret.
    -- intended to replace intLoopReadConsole in
    -- int-top.boot
    processString(s:String,param:%,lineNum:NNI):Boolean ==
      if s=empty()$String then return true
      if s="" then  return true
      if s="q" then return false
      if position(")",s,1) = 1 then
        return processSystemCommand(s,param,lineNum)
      processMath(s,param,lineNum)

    -- constructor to setup parameters and run interpreter
    -- inside existing interpreter
    spadInterpret():% ==
      -- setup global parameters 
      param:% := ['X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X,_
        'X]
      keepGoing:Boolean := true
      lineNum:NNI := 1
      while keepGoing repeat
        -- display prompt without carrage return
        -- I have added m so that I know this interpreter is running
        PRINC(concat(["(m",string(lineNum),") -> "])$String)$Lisp
        FORCE_-OUTPUT()$Lisp
        -- read a line from stdin to a string
        a := read_-line(_*STANDARD_-INPUT_*$Lisp)$Lisp
        s:String := a pretend String
        keepGoing := processString(s,param,lineNum)
        lineNum := lineNum + 1
      param
@

)abbrev domain TOKENISE Tokeniser
++ Author: Martin Baker
++ Date Created: April 2014
++ Date Last Updated: April 2014
++ Description:
++   This takes the input string and converts it to a list of tokens.
++
++   I have put information about running this code here:
++ http://www.euclideanspace.com/maths/standards/program/mycode/system/interpreter/
++   The original interpreter is undocumented so I'm trying to
++   bootstrap my understanding by working out what I can here:
++ http://www.euclideanspace.com/maths/standards/program/internals/interpreter/

Tokeniser : Exports == Implementation where
  NNI==> NonNegativeInteger
  TOKENTYPE ==> Symbol
    ++ valid token types are:
    ++id: Symbol
    ++key: Symbol
    ++integer: Symbol
    ++rinteger: Symbol
    ++float: Symbol
    ++string: Symbol
    ++comment: Symbol
    ++negcomment: Symbol
    ++error: Symbol
    ++spaces: Symbol
  TOKEN ==> Record(tt:TOKENTYPE,tokVal:String)
  KEYS ==> List Record(a:String,b:String)
    ++ perhaps this should be hash table?
    ++ can be optimised later if needed

  Exports == with

    spadTokenise:(s:String) -> %
      ++ constructor to put string into tokeniser
    coerce: (n: %) -> OutputForm
      ++ output
  Implementation ==> add

    Rep := List TOKEN
      ++ list of tokens.

    makeToken(t:TOKENTYPE,s:String,keys:KEYS):TOKEN ==
      for key in keys repeat
        if s = key.a then return ["key"::Symbol,key.b]
      [t,s]

    -- constructor to put string into tokeniser
    spadTokenise(s:String):% ==
      keys:KEYS := [
           ["add",      "add"], _
           ["and",      "and"], _
           ["break",   "break"], _
           ["by",        "by"], _
           ["case",     "case"], _
           ["catch",  "catch"], _
           ["default",  "DEFAULT" ],_
           ["define",  "DEFN" ],_
           ["do",        "DO"],_
           ["else",    "else"], _
           ["exquo",   "exquo"], _
           ["export","EXPORT" ],_
           ["finally", "finally"], _
           ["for",      "for"], _
           ["free",    "FREE" ],_
           ["from",    "from"], _
           ["generate", "generate"], _
           ["goto",    "goto"], _
           ["has",      "has"], _
           ["if",       "if"], _
           ["import", "import"], _
           ["in", "in"], _
           ["inline", "INLINE" ],_
           ["is", "is"], _
           ["isnt", "isnt"], _
           ["iterate", "ITERATE"],_
           ["local", "local"], _
           ["macro", "MACRO" ],_
           ["mod", "MOD" ],_
           ["not", "not"], _
           ["or", "or"], _
           ["pretend", "pretend"], _
           ["quo", "quo"], _
           ["rem", "rem"], _
           ["repeat", "repeat"],_
           ["return", "return"],_
           ["rule","RULE" ],_
           ["then", "then"],_
           ["try", "try"], _
           ["until", "until"], _
           ["where", "where"], _
           ["while", "while"],_
           ["with", "with"], _
           ["yield", "yield"], _
           ["|","BAR"],_
           [".","DOT" ],_
           ["::","COERCE" ],_
           [":","COLON" ],_
           [":-","COLONDASH" ],_
           ["@","AT" ],_
           ["@@","ATAT" ],_
           [",","COMMA" ],_
           [";","SEMICOLON" ],_
           ["**","POWER" ],_
           ["*","TIMES" ],_
           ["+","PLUS" ],_
           ["-","MINUS" ],_
           ["<","LT" ],_
           [">","GT" ],_
           ["<=","LE" ],_
           [">=","GE" ],_
           ["=", "EQUAL"],_
           ["~=","NOTEQUAL" ],_
           ["~","~" ],_
           ["^","CARAT" ],_
           ["..","SEG" ],_
           ["#","#" ],_
           ["#1", "#1" ],_
           ["&","AMPERSAND" ],_
           ["$","$" ],_
           ["/","SLASH" ],_
           ["\","BACKSLASH" ],_
           ["//","SLASHSLASH" ],_
           ["\\","BACKSLASHBACKSLASH" ],_
           ["/\","SLASHBACKSLASH" ],_
           ["\/","BACKSLASHSLASH" ],_
           ["=>","EXIT" ],_
           [":=","BECOMES" ],_
           ["==","DEF" ],_
           ["==>","MDEF" ],_
           ["->","ARROW" ],_
           ["<-","LARROW" ],_
           ["+->","GIVES" ],_
           ["(","(" ],_
           [")",")" ],_
           ["(|","(|" ],_
           ["|)","|)" ],_
           ["[","[" ],_
           ["]","]" ],_
           ["[__]","[]" ],_
           ["{","{" ],_
           ["}","}" ],_
           ["{__}","{}" ],_
           ["[|","[|" ],_
           ["|]","|]" ],_
           ["[|__|]","[||]" ],_
           ["{|","{|" ],_
           ["|}","|}" ],_
           ["{|__|}","{||}" ],_
           ["<<","OANGLE" ],_
           [">>","CANGLE" ],_
           ["'", "'" ],_
           ["`", "BACKQUOTE" ]_
                         ]
      res:List(TOKEN) := nil()$List(TOKEN)
      cl:List Character := entries(s)
      ttCur:TOKENTYPE := "null"::Symbol
      startIndex:NNI := 1
      for c in cl for i in 1..(#cl) repeat
        ttThis:TOKENTYPE := "error"::Symbol
        if c=space() then ttThis := "spaces"::Symbol
        if alphabetic?(c) then ttThis := "id"::Symbol
        nonAlphaNum:boolean := not (alphanumeric?(c) or c=space())
        if digit?(c) then ttThis := "integer"::Symbol
        -- ids can have numeric characters but not the first
        if ttCur="id"::Symbol and ttThis = "integer"::Symbol then
          ttThis := "id"::Symbol
        -- if reading a float don't change it to integer
        if ttCur="float"::Symbol and ttThis = "integer"::Symbol then
          ttThis := "float"::Symbol
        -- float can contain . e or E
        if ttCur="integer"::Symbol and (_
          c=char(".") or c=char("e") or c=char("E")) then
            ttThis := "float"::Symbol        
            ttCur := "float"::Symbol        
        if ttCur ~= ttThis then
          if ttCur ~= "null"::Symbol then
              subChars:List(Character) := [cl.x for x in (startIndex..(i-1))]
              sub:String := construct(subChars)
              res := concat(res,makeToken(ttCur,sub,keys))
              startIndex := i
          ttCur := ttThis
      if ttCur ~= "null"::Symbol then
        subChars:List(Character) := [cl.x for x in (startIndex..(#cl))]
        sub:String := construct(subChars)
        res := concat(res,makeToken(ttCur,sub,keys))$List(TOKEN)
      res

    coerce(n: %):OutputForm ==
      toks:List(OutputForm) := nil()$List(OutputForm)
      for v in n repeat
        tok:OutputForm := hconcat([(v.tt)::OutputForm,_
          "="::OutputForm,_
          (v.tokVal)::OutputForm_
          ])
        toks := concat(toks,tok)$List(OutputForm)
      bracket(toks)
@
